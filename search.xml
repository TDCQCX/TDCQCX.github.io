<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何使用hexo创建一个博客网站</title>
    <url>/2025/04/17/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[浅谈如何使用 hexo 创建一个博客网站写在前面
最近在学习如何使用 github pages 搭建个人博客网站，在此记录一下我的学习过程。你现在所看到的网站界面都源于一个设想，我会将我学习的知识记录下来，分享给大家。

平台及技术栈
HEXO
Markdown
Github Pages
域名解析

搭建步骤
注册 github 账号
新建一个仓库，仓库名称为：username.github.io，其中 username 为你的 github 用户名。
克隆仓库到本地
安装 HEXO
配置 HEXO
生成静态页面
部署到 github
配置域名解析
完成

1.注册 github 账号这一点就不多说了，你可以在各大搜索引擎上找到相关教程。
2.新建一个仓库
仓库名称为：username.github.io，其中 username 为你的 github 用户名。这一步也很简单，你只需要在 github 上新建一个仓库，仓库名称为：username.github.io，其中 username 为你的 github 用户名。


仓库名称必须为username.github.io，否则无法正常访问。

3.克隆仓库到本地使用 git 命令克隆仓库到本地，命令如下：
git clone URL_ADDRESSgit clone https://github.com/username/username.github.io.git

其中 URL_ADDRESS 为仓库的 URL 地址，你可以在仓库的主页上找到
4.安装 HEXO使用 npm 安装 HEXO，命令如下：
npm install -g hexo-cli

或者
yarn global add hexo-cli

5.配置 HEXO使用 HEXO 命令初始化 HEXO，命令如下：
hexo init blog

其中blog为你的博客名称，你可以根据自己的喜好来命名。现在，你已经成功地创建了一个HEXO博客。你可以在blog目录下找到一个名为_config.yml的文件，这个文件是HEXO的配置文件，你可以根据自己的喜好来修改这个文件。
5.1 如何编写文章使用 HEXO 命令创建一篇文章，命令如下：
hexo new &quot;文章标题&quot;

其中文章标题为你要创建的文章的标题，你可以根据自己的喜好来命名。现在，你已经成功地创建了一篇文章。你可以在blog目录下找到一个名为source/_posts的目录，这个目录就是你的文章目录。你可以在source/_posts目录下找到一篇名为文章标题.md的文件，这个文件就是你的文章。你可以使用 Markdown 语法来编写你的文章。
5.2 如何编写页面使用 HEXO 命令创建一个页面，命令如下：
hexo new page &quot;页面标题&quot;

其中页面标题为你要创建的页面的标题，你可以根据自己的喜好来命名。
6.生成静态页面
使用 HEXO 命令生成静态页面，命令如下：

hexo generate


或者

hexo g

现在，你已经成功地生成了一个静态页面。你可以在blog目录下找到一个名为public的目录，这个目录就是你的静态页面。该目录依据_config.yml文件中的deploy配置项生成。

现在，你可以运行以下命令来启动服务器：

hexo server

如果你觉得每次都要输入hexo server命令很麻烦，你可以在_config.yml文件中添加以下配置项：
server:  open: true

这样，每次启动服务器时，都会自动打开浏览器。

如果你觉得 hexo 的默认主题不好看，你可以使用其他主题。
你可以在[HEXO 官方主题库](URL_ADDRESS 你可以在HEXO 官方主题库中找到你喜欢的主题，然后将其克隆到blog目录下的themes目录中。你可以使用以下命令来安装主题：

git clone URL_ADDRESS themes/your_theme_name

其中 URL_ADDRESS 为主题的 URL 地址，你可以在主题的主页上找到。然后，在_config.yml文件中添加以下配置项：
theme: your_theme_name

其中your_theme_name为你安装的主题名称。

现在，你已经成功地安装了一个主题。你可以在blog目录下找到一个名为themes的目录，这个目录就是你的主题目录。你可以在themes目录下找到一个名为_config.yml的文件，
这个文件是主题的配置文件，你可以根据自己的喜好来修改这个文件。或者根据主题的说明文档来修改。

7.部署到 github使用 HEXO 命令部署到 github，命令如下：
hexo deploy

或者
hexo d

如果你的 github 账号没有配置 SSH 密钥，你需要在_config.yml文件中添加以下配置项：
deploy:  type: git

然后，在blog目录下找到一个名为.deploy_git的文件，这个文件是HEXO的部署配置文件，你可以根据自己的喜好来修改这个文件。

现在，你已经成功地部署到 github。你可以在浏览器中输入你的仓库地址，访问你的博客网站。
访问你的博客网站，链接地址如下：

https://username.github.io/

其中username为你的github用户名。

如果你想使用自定义域名，你可以在_config.yml文件中添加以下配置项：

url:    URL_ADDRESSurl: https://your_domain_name/


其中your_domain_name为你的自定义域名。
请确保你的自定义域名已经解析到你的github仓库地址。

8.配置域名解析使用域名解析服务，将域名解析到 github 的仓库地址，命令如下：
CNAME username.github.io

其中 username 为你的 github 用户名。

现在，你已经成功地配置域名解析。你可以在浏览器中输入你的自定义域名地址，访问你的博客网站。

9.完成现在，你已经成功地创建了一个 HEXO 博客网站。你可以在浏览器中输入你的域名地址，访问你的博客网站。

你可以在blog目录下找到一个名为source的目录，这个目录就是你的博客源文件目录。
你可以在source目录下找到一个名为_posts的目录，这个目录就是你的博客文章目录。
你可以在_posts目录下找到一个名为your_article.md的文件，这个文件就是你的博客文章

]]></content>
      <categories>
        <category>技术教程</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
        <tag>技术教程</tag>
      </tags>
  </entry>
  <entry>
    <title>一些想说的话</title>
    <url>/2025/01/08/%E4%B8%80%E4%BA%9B%E6%83%B3%E8%AF%B4%E7%9A%84%E8%AF%9D/</url>
    <content><![CDATA[致来到博客的新朋友：你好！
有些路，我们能一个人走得快，却无法一个人走得远。让交友更高效，在折腾中彼此照亮，也能在成长的过程中收获更多温暖。人与人的联结，就如同将一座座孤岛连成大陆，每个人都需要光与热，而我们也能成为彼此的光源。我想这就是博客的意义所在———*TDCQCX 写于 2025年2月26日 *


写在前面为什么要搭建博客？
搭建博客，其实最开始的想法很简单，就是想有一个地方可以记录自己的想法，记录自己的成长历程。在后来，我受到很多博客的惠及，他们所分享开发技巧、如何面试和生活经验让我受益匪浅，源自一次偶然，源自一次坚持，源自一次尝试；


而在这里，陌生的朋友，如果恰好你也喜欢编程，喜欢分享，喜欢交流，那么，欢迎来到我的博客。
博客分类我在这里整理博客所发布过的内容，但如果想找到某个东西，欢迎在博客的右上角点击搜索
技术分享编程语言
C++ 快速备忘清单
Java 快速备忘清单
Python 快速备忘清单
JavaScript 快速备忘清单
PHP 快速备忘清单
HTML
CSS
JSON

开发框架
Docker
Vue2
Vue3
JQuery

开发工具开发规范]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>C 备忘录</title>
    <url>/2025/01/08/c/</url>
    <content><![CDATA[C 备忘清单提供基本语法和方法的 C 快速参考备忘单。
入门hello.c#include &lt;stdio.h&gt;int main() &#123;  printf(&quot;Hello World!&quot;);  return 0;&#125;

使用 gcc 编译 hello.c 源文件
$ gcc -o hello hello.c

运行编译后的二进制文件可执行文件(hello)
$ ./hello# 输出 =&gt; Hello World

变量

int myNum = 15; // 定义并初始化变量 myNumint myNum2;     // 声明变量 myNum2myNum2 = 15;    // 初始化变量 myNum2int myNum3 = 15; // 定义并初始化变量 myNum3myNum3 = 10;     // 重新赋值 myNum3

定义不同类型的变量
// 定义并初始化浮点数变量float myFloatNum = 5.99;// 定义并初始化字符变量char myLetter = &#x27;D&#x27;;

变量相加
int x = 5, y = 6;int sum = x + y; // 变量相加

声明并初始化多个变量
int x = 5, y = 6, z = 50;int a, b, c = 10;

仅声明变量不初始化
int result;// 未初始化的变量 result 会导致不可预测的结果result = result + 10; // 错误：未初始化的变量// 部分编译器会警告未初始化的变量可能导致未定义行为

常量 Constants

常量是不能被改变的值，使用常量可以使代码更清晰和安全。
const int minutesPerHour = 60;const float PI = 3.14;

最佳实践
const int BIRTHYEAR = 1980;

命名规范

常量通常使用全大写字母，单词间用下划线分隔（如 BIRTHYEAR、MAX_LENGTH）。
数组大小

使用 const 定义数组大小，编译器将其作为编译时常量处理。
#define 与 const


#define：宏常量在预处理阶段替换，不进行类型检查
const：类型安全的常量，编译器可检查类型，推荐使用

注意事项
const 常量在定义时必须初始化，否则会导致编译错误。
const 常量的值不能被修改，任何尝试修改 const 常量的操作都会导致编译错误。
使用 const 常量可以提高代码的可读性和可维护性，避免魔法数字的使用。

注释// 这是一个单行注释printf(&quot;Hello World!&quot;); // 行内注释/*    多行注释：   用于注释跨多行的内容   注意：多行注释不能嵌套，否则会导致编译错误*/

注意:

单行注释 // 可以嵌套，如 /////。
行内注释应避免过长，以免影响代码可读性。
多行注释不能嵌套，否则会导致编译错误。

/* 这是一个多行注释的开始       /* 嵌套的多行注释，C语言不支持 */*/


打印文本printf(&quot;I am learning C.&quot;);int testInteger = 5;printf(&quot;Number = %d&quot;, testInteger);float f = 5.99; // 浮点数printf(&quot;Value = %f&quot;, f);short a = 0b1010110;  // 2 进制数字int b = 02713;        // 8 进制数字long c = 0X1DAB83;    // 16 进制数字

变量a和c分别为 short 和 long 型，所以输出必须加上对应的修饰符 h 和 l
以 8 进制形式输出printf(&quot;a=%ho, b=%o, c=%lo\n&quot;, a, b, c);// 输出 =&gt; a=126, b=2713, c=7325603

以 10 进制形式输出printf(&quot;a=%hd, b=%d, c=%ld\n&quot;, a, b, c);// 输出 =&gt; a=86, b=1483, c=1944451

以 16 进制形式输出（字母小写）printf(&quot;a=%hx, b=%x, c=%lx\n&quot;, a, b, c);// 输出 =&gt; a=56, b=5cb, c=1dab83

以 16 进制形式输出（字母大写）printf(&quot;a=%hX, b=%X, c=%lX\n&quot;, a, b, c);// 输出 =&gt; a=56, b=5CB, c=1DAB83

控制空格数int a1=20, a2=345, a3=700;int b1=56720, b2=9999, b3=20098;int c1=233, c2=205, c3=1;int d1=34, d2=0, d3=23;// %-9d: 十进制输出，最少宽度为9，左对齐printf(&quot;%-9d %-9d %-9d\n&quot;, a1, a2, a3);printf(&quot;%-9d %-9d %-9d\n&quot;, b1, b2, b3);printf(&quot;%-9d %-9d %-9d\n&quot;, c1, c2, c3);printf(&quot;%-9d %-9d %-9d\n&quot;, d1, d2, d3);

输出结果
20        345       700  56720     9999      20098233       205       1    34        0         23   

解释：%-9d：d 表示十进制输出，9 表示最少占 9 个字符宽度，- 表示左对齐，不使用 - 则默认右对齐。
对于整型数据：
int a = 12345;printf(&quot;%md&quot;, a);


若 m &lt;= 实际数据宽度，则按实际情况输出。
若 m &gt; 实际数据宽度，则在左边用空格补齐。
printf(&quot;%0md&quot;, a); 则在左边用 0 补齐。

对于浮点型数据：
float a = 1.2345; printf(&quot;%m.nf&quot;, a);// m -- 整个数据宽度，n -- 小数位数


实际小数位数 &gt; n，截去多余小数，注意四舍五入。
实际小数位数 &lt; n，在小数最后补 0。
若 m 省略则写作 %.n，整数部分按实际输出，小数部分按以上规则。
若 m &lt; n+1，自动突破宽度限制，按实际数据输出。
若 m &gt; n+1，左边补空格。

字符串 (Strings)在 C 语言中，字符串是以 \0 结尾的字符数组，而不是一种单独的数据类型。可以通过字符数组来表示字符串。
定义并打印字符串char greetings[] = &quot;Hello World!&quot;;printf(&quot;%s&quot;, greetings);

访问字符串中的字符char greetings[] = &quot;Hello World!&quot;;printf(&quot;%c&quot;, greetings[0]);

访问字符串 greetings 的第一个字符 H
修改字符串中的字符char greetings[] = &quot;Hello World!&quot;;greetings[0] = &#x27;J&#x27;; // 修改第一个字符为 &#x27;J&#x27;printf(&quot;%s&quot;, greetings);// 输出 &quot;Jello World!&quot;

另一种创建字符串的方法char greetings[] = &#123;&#x27;H&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;\0&#x27;&#125;;printf(&quot;%s&quot;, greetings);// 输出 &quot;Hell&quot;

注意：C 语言中没有 String 类型，字符串是由字符数组 char[] 表示的，且必须以 \0 结尾以标识字符串的结束。
条件判断int time = 20;if (time &lt; 18) &#123;  printf(&quot;再会！&quot;);&#125; else &#123;  printf(&quot;晚上好！&quot;);&#125;// 输出 -&gt; &quot;晚上好！&quot;int time = 22;if (time &lt; 10) &#123;  printf(&quot;早上好！&quot;);&#125; else if (time &lt; 20) &#123;  printf(&quot;再会！&quot;);&#125; else &#123;  printf(&quot;晚上好！&quot;);&#125;// 输出 -&gt; &quot;晚上好！&quot;int time = 10;if (time &gt; 8) &#123;  //再嵌套一个if  if (time &lt; 12) &#123;    printf(&quot;中午好！&quot;)  &#125;&#125;// 输出 -&gt; &quot;中午好！&quot;

说明
if 语句用于根据条件执行代码块。
else 语句在 if 条件不满足时执行。
else if 语句用于检查多个条件。
可以嵌套 if 语句以检查多个条件。

三元运算符三元运算符（? :）是一种简洁的条件判断方式，用于根据条件选择表达式的值。由三个部分组成：

条件表达式
条件为真时的结果
条件为假时的结果

基本语法：(条件) ? 表达式1 : 表达式2;如果 条件 为真，则返回 表达式1，否则返回 表达式2。
示例int time = 20;(time &lt; 18) ? printf(&quot;再会！&quot;)             : printf(&quot;晚上好！&quot;);// 输出 -&gt; &quot;晚上好！&quot;

嵌套使用示例（不建议过多嵌套）：
int time = 22;printf((time &lt; 10) ? &quot;早上好！&quot;           : (time &lt; 20) ? &quot;再会！&quot;                         : &quot;晚上好！&quot;);// 输出 -&gt; &quot;晚上好！&quot;

Switchint day = 4;switch (day) &#123;  case 3: printf(&quot;周三&quot;); break;  case 4: printf(&quot;周四&quot;); break;  default: printf(&quot;期待周末&quot;);&#125;// 输出 -&gt; &quot;周四&quot;

说明
switch 语句根据表达式的值跳转到匹配的 case 标签。
匹配到 case 后执行相应代码，并通过 break 跳出 switch。
如果没有匹配到任何 case，则执行 default 语句（如果存在）。

注意事项
switch 表达式可以是整型、字符型和枚举型。
case 后的常量表达式值不能相同。
case 后可以有多个语句，不需要 &#123; &#125; 括起来。
case 和 default 语句的顺序不影响程序执行结果。
break 语句用于结束 switch，如果没有 break，程序会继续执行下一个 case。

示例int day = 3;switch (day) &#123;  case 3: printf(&quot;周三&quot;);   case 4: printf(&quot;周四&quot;); break;  default: printf(&quot;期待周末&quot;);&#125;// 输出 -&gt; &quot;周三周四&quot;

While 循环int i = 0;while (i &lt; 5) &#123;  printf(&quot;%d\n&quot;, i);  i++;&#125;// 输出 -&gt; 0 1 2 3 4

解释
while 循环首先检查条件 i &lt; 5 是否为真。
如果为真，程序进入循环体，执行打印操作并增加 i 的值。
循环会继续进行，直到 i 达到 5，此时条件 i &lt; 5 不再为真，循环结束。

打印 1 到 10 的数字int i = 1;while (i &lt;= 10) &#123;  printf(&quot;%d\n&quot;, i);  i++;&#125;// 输出 -&gt; 1 2 3 4 5 6 7 8 9 10

打印偶数int i = 0;while (i &lt;= 10) &#123;  if (i % 2 == 0) &#123;    printf(&quot;%d\n&quot;, i);  &#125;  i++;&#125;// 输出 -&gt; 0 2 4 6 8 10

无限循环（需手动终止）int i = 0;while (1) &#123;  printf(&quot;无限循环\n&quot;);  i++;  if (i == 5) break; // 添加条件以退出循环&#125;// 输出 -&gt; 无限循环 (打印 5 次)

Do&#x2F;While 循环int i = 0;do &#123;  printf(&quot;%d\n&quot;, i);  i++;&#125; while (i &lt; 5);// 输出 -&gt; 0 1 2 3 4

解释
do/while 循环至少执行一次循环体，因为条件检查在循环体执行之后进行。
首先执行 do 中的代码，然后检查条件 i &lt; 5 是否为真。
如果为真，继续执行循环；如果为假，则退出循环。

打印从 5 开始的数字，直到条件不满足int i = 5;do &#123;  printf(&quot;%d\n&quot;, i);  // 输出 5  i++;&#125; while (i &lt; 5);// 输出 -&gt; 5

计算 1 到 10 的和int i = 1;int sum = 0;do &#123;  sum += i;  i++;&#125; while (i &lt;= 10);printf(&quot;Sum: %d\n&quot;, sum);// 输出 -&gt; Sum: 55

For 循环for (表达式1; 表达式2; 表达式3) &#123;  循环体语句;&#125;


表达式1：设置初始条件，只执行一次。
表达式2：循环条件表达式，每次循环前检查。
表达式3：循环体执行后的调整操作。

示例：
int i;for (i = 0; i &lt; 5; i++) &#123;  printf(&quot;%d\n&quot;, i);&#125;// 输出 -&gt; 0 1 2 3 4

注意事项
for 语句的三个表达式不是必须的。
当条件表达式（表达式2）为假时，for 循环结束。
可以在循环体内使用 break、continue、goto 语句。
如果表达式2为空，则表示无限循环，如 for(;;) 相当于 while(1)。

变体
for (i = m; i &lt; n; i++) 从 i = m 开始到 i = n-1，循环 n - m 次。
for (i = m; i &lt;= n; i++) 从 i = m 到 i = n，循环 n - m + 1 次。

跳出循环 (Break&#x2F;Continue&#x2F;Goto)

break 语句跳出当前循环或 switch 语句，执行后续代码。
int i;for (i = 0; i &lt; 10; i++) &#123;  if (i == 4) &#123;    break;  &#125;  printf(&quot;%d\n&quot;, i);&#125;// 输出 -&gt; 0 1 2 3

continue 语句跳过当前循环的剩余语句，直接进入下一次循环。
int i;for (i = 0; i &lt; 10; i++) &#123;  if (i == 4) &#123;    continue;  &#125;  printf(&quot;%d\n&quot;, i);&#125;// 输出 -&gt; 0 1 2 3 5 6 7 8 9

goto 语句无条件跳转到指定标签位置。
int i = 0;while (i &lt; 10) &#123;  if (i == 4) &#123;    goto skip;  // 跳转到 skip 标签  &#125;  printf(&quot;%d\n&quot;, i);  i++;&#125;skip:printf(&quot;Exited the loop at i = %d\n&quot;, i);// 输出 -&gt; 0 1 2 3 Exited the loop at i = 4

注意事项
标签必须在当前函数内定义，命名规则与变量相同。
goto 语句应慎用，避免代码逻辑混乱，通常使用循环或条件语句代替。

设置数组大小// 声明一个由四个整数组成的数组int myNumbers[4];// 添加元素myNumbers[0] = 25;myNumbers[1] = 50;myNumbers[2] = 75;myNumbers[3] = 100;

枚举 Enum

enum week &#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;

定义枚举变量
enum week a, b, c;enum week &#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a, b, c;

有了枚举变量，就可以把列表中的值赋给它
enum week &#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;enum week a = Mon, b = Wed, c = Sat;// 或者enum week&#123; Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a = Mon, b = Wed, c = Sat;

枚举示例应用enum week &#123;Mon = 1, Tues, Wed, Thurs&#125; day;scanf(&quot;%d&quot;, &amp;day);switch(day)&#123;  case Mon:   puts(&quot;Monday&quot;); break;  case Tues:  puts(&quot;Tuesday&quot;); break;  case Wed:   puts(&quot;Wednesday&quot;); break;  case Thurs: puts(&quot;Thursday&quot;); break;  default:    puts(&quot;Error!&quot;);&#125;

数组 Arrays定义和访问数组元素int myNumbers[] = &#123;25, 50, 75, 100&#125;;printf(&quot;%d&quot;, myNumbers[0]); // 输出 25

更改数组元素int myNumbers[] = &#123;25, 50, 75, 100&#125;;myNumbers[0] = 33;printf(&quot;%d&quot;, myNumbers[0]); // 输出 33

循环遍历数组int myNumbers[] = &#123;25, 50, 75, 100&#125;;int i;for (i = 0; i &lt; 4; i++) &#123;  printf(&quot;%d\n&quot;, myNumbers[i]);&#125;// 输出 -&gt; 25 50 75 100

用户输入// 创建一个整数变量来存储我们从用户那里得到的数字int myNum;// 要求用户输入一个数字printf(&quot;请输入一个数字: \n&quot;);// 获取并保存用户输入的号码scanf(&quot;%d&quot;, &amp;myNum);// 输出用户输入的数字printf(&quot;您输入的数字: %d&quot;, myNum);

用户输入字符串// 创建一个字符串char firstName[30];// 要求用户输入一些文本printf(&quot;输入您的名字: \n&quot;);// 获取并保存文本scanf(&quot;%s&quot;, firstName);// 输出文本printf(&quot;Hello %s.&quot;, firstName);

内存地址创建变量时，会为该变量分配一个内存地址。
int myAge = 43;printf(&quot;%p&quot;, &amp;myAge);// 输出 myAge 的内存地址，例如：0x7ffe5367e044

要访问变量的内存地址，请使用引用运算符 (&amp;)。
创建指针

int myAge = 43;      // 一个 int 变量int *ptr = &amp;myAge;   // 创建指向 myAge 的指针printf(&quot;%d\n&quot;, myAge);  // 输出 myAge 的值 -&gt; 43printf(&quot;%p\n&quot;, &amp;myAge); // 输出 myAge 的内存地址，例如：0x7ffe5367e044printf(&quot;%p\n&quot;, ptr);    // 输出指针 ptr 的值（即 myAge 的内存地址）printf(&quot;%d\n&quot;, *ptr);   // 通过指针访问 myAge 的值 -&gt; 43

取消引用int myAge = 43;     // 变量声明int* ptr = &amp;myAge;  // 指针声明// 参考：用指针输出 myAge 的// 内存地址（0x7ffe5367e044）printf(&quot;%p\n&quot;, ptr);// 取消引用：用指针输出 myAge 的值 (43)printf(&quot;%d\n&quot;, *ptr);

指针变量

int myAge = 43;            // 一个 int 变量int* ptr = &amp;myAge;         // 名为 ptr 的指针变量，用于存储 myAge 的地址printf(&quot;%d\n&quot;, myAge);     // 输出 myAge (43) 的值printf(&quot;%p\n&quot;, &amp;myAge);    // 输出 myAge 的内存地址（0x7ffe5367e044）printf(&quot;%p\n&quot;, ptr);       // 用指针（0x7ffe5367e044）输出myAge的内存地址

运算符算术运算符int myNum = 100 + 50;int sum1 = 100 + 50;    // 150 (100 + 50)int sum2 = sum1 + 250;  // 400 (150 + 250)int sum3 = sum2 + sum2; // 800 (400 + 400)





Operator
Name
Description
Example



+
加
将两个值相加
x + y


-
减
从另一个值中减去一个值
x - y


*
乘
将两个值相乘
x * y


/
除
将一个值除以另一个
x / y


%
取模
返回除法余数
x % y


++
增量
将变量的值增加 1
++


--
乘量
将变量的值减 1
--x


赋值运算符


符号
示例
如同



=
x = 5
x = 5


+=
x += 3
x = x + 3


-=
x -= 3
x = x - 3


*=
x *= 3
x = x * 3


/=
x /= 3
x = x / 3


%=
x %= 3
x = x % 3


&amp;=
x &amp;= 3
x = x &amp; 3


|=
x |= 3
x = x | 3


^=
x ^= 3
x = x ^ 3


&gt;&gt;=
x &gt;&gt;= 3
x = x &gt;&gt; 3


&lt;&lt;=
x &lt;&lt;= 3
x = x &lt;&lt; 3


比较运算符int x = 5;int y = 3;printf(&quot;%d&quot;, x &gt; y);// 返回 1（真），因为 5 大于 3





符号
名称
示例



==
等于
x == y


!=
不等于
x != y


&gt;
大于
x &gt; y


&lt;
小于
x &lt; y


&gt;=
大于或等于
x &gt;= y


&lt;=
小于或等于
x &lt;= y


比较运算符用于比较两个值
逻辑运算符




符号
名称
说明
示例



&amp;&amp;
与逻辑
如果两个语句都为真，则返回真
x &lt; 5 &amp;&amp;  x &lt; 10


||
或逻辑
如果其中一个语句为真，则返回真
x &lt; 5 || x &lt; 4


!
非逻辑
反转结果，如果结果为真则返回假
!(x &lt; 5 &amp;&amp; x &lt; 10)


运算符示例

unsigned int a = 60; /* 60 = 0011 1100 */  unsigned int b = 13; /* 13 = 0000 1101 */int c = 0;           c = a &amp; b;      /* 12 = 0000 1100 */ printf(&quot;Line 1 - c 的值是 %d\n&quot;, c );c = a | b;      /* 61 = 0011 1101 */printf(&quot;Line 2 - c 的值是 %d\n&quot;, c );c = a ^ b;      /* 49 = 0011 0001 */printf(&quot;Line 3 - c 的值是 %d\n&quot;, c );c = ~a;         /*-61 = 1100 0011 */printf(&quot;Line 4 - c 的值是 %d\n&quot;, c );c = a &lt;&lt; 2;     /* 240 = 1111 0000 */printf(&quot;Line 5 - c 的值是 %d\n&quot;, c );c = a &gt;&gt; 2;     /* 15 = 0000 1111 */printf(&quot;Line 6 - c 的值是 %d\n&quot;, c );

位运算符




运算符
描述
实例



&amp;
按位与操作，按二进制位进行”与”运算
(A &amp; B) 将得到 12 即为 0000 1100


|
按位或运算符，按二进制位进行”或”运算
(A | B) 将得到 61 即为 0011 1101


^
异或运算符，按二进制位进行”异或”运算
(A ^ B) 将得到 49 即为 0011 0001


~
取反运算符，按二进制位进行”取反”运算
(~A) 将得到 -61 即为 1100 0011


&lt;&lt;
二进制左移运算符
A &lt;&lt; 2 将得到 240 即为 1111 0000


&gt;&gt;
二进制右移运算符
A &gt;&gt; 2 将得到 15 即为 0000 1111


数据类型 Data Types基本数据类型




数据类型
大小 Size
范围 Range
描述 Description



char
1 字节
−128 ~ 127
单个字符&#x2F;字母&#x2F;数字&#x2F;ASCII


signed char
1 字节
−128 ~ 127
-


unsigned char
1 字节
0 ~ 255
-


int
2 到 4 字节
−32,768 ~ 32,767
存储整数


signed int
2 字节
−32,768 ~ 32,767



unsigned int
2 字节
0 ~ 65,535



short int
2 字节
−32,768 ~ 32,767



signed short int
2 字节
−32,768 ~ 32,767



unsigned short int
2 字节
0 ~ 65,535



long int
4 字节
-2,147,483,648 ~ 2,147,483,647



signed long int
4 字节
-2,147,483,648 ~ 2,147,483,647



unsigned long int
4 字节
0 ~ 4,294,967,295



float
4 字节




double
8 字节




long double
10 字节




数据类型// 创建变量int myNum = 5;             // 整数float myFloatNum = 5.99;   // 浮点数char myLetter = &#x27;D&#x27;;       // 字符串// 高精度浮点数据或数字double myDouble = 3.2325467;// 打印输出变量printf(&quot;%d\n&quot;, myNum);printf(&quot;%f\n&quot;, myFloatNum);printf(&quot;%c\n&quot;, myLetter);printf(&quot;%lf\n&quot;, myDouble);





数据类型
说  明



char
字符型


short
短整型


int
整型


long
长整型


float
单精度浮点型


double
双精度浮点型


void
无类型


基本格式说明符


格式说明符
数据类型



%d 或 %i
int 整数


%f
float 单精度的十进制类型


%lf
double 高精度浮点数据或数字


%c
char 字符


%s
用于 strings 字符串


基本格式说明符



short
int
long



8 进制
%ho
%o
%lo


10 进制
%hd
%d
%ld


16 进制
%hx &#x2F; %hX
%x &#x2F; %X
%lx &#x2F; %lX


数据格式示例int myNum = 5;float myFloatNum = 5.99; // 浮点数char myLetter = &#x27;D&#x27;;     // 字符串// 打印输出变量printf(&quot;%d\n&quot;, myNum);printf(&quot;%f\n&quot;, myFloatNum);printf(&quot;%c\n&quot;, myLetter);

预处理器预处理器指令




指令
描述



#define
定义宏


#include
包含一个源代码文件


#undef
取消已定义的宏


#ifdef
如果宏已经定义，则返回真


#ifndef
如果宏没有定义，则返回真


#if
如果给定条件为真，则编译下面代码


#else
#if 的替代方案


#elif
如果 #if 条件为假，当前条件为真


#endif
结束一个 #if……#else 条件编译块


#error
当遇到标准错误时，输出错误消息


#pragma
使用标准化方法，向编译器发布特殊的命令到编译器中


// 所有的 MAX_ARRAY_LENGTH 替换为 20#define MAX_ARRAY_LENGTH 20// 系统库中获取 stdio.h#include &lt;stdio.h&gt;// 本地目录中获取 myheader.h#include &quot;myheader.h&quot;#undef  FILE_SIZE#define FILE_SIZE 42 // 取消已定义并定义为 42

预定义宏




宏
描述



__DATE__
当前日期，一个以 “MMM DD YYYY” 格式表示的字符常量


__TIME__
当前时间，一个以 “HH:MM:SS” 格式表示的字符常量


__FILE__
这会包含当前文件名，一个字符串常量


__LINE__
这会包含当前行号，一个十进制常量


__STDC__
当编译器以 ANSI 标准编译时，则定义为 1




ANSI C 定义了许多宏，您可以使用这些宏，但是不能直接修改这些预定义的宏
预定义宏示例#include &lt;stdio.h&gt;int main() &#123;  printf(&quot;File :%s\n&quot;, __FILE__);  printf(&quot;Date :%s\n&quot;, __DATE__);  printf(&quot;Time :%s\n&quot;, __TIME__);  printf(&quot;Line :%d\n&quot;, __LINE__);  printf(&quot;ANSI :%d\n&quot;, __STDC__);&#125;

宏延续运算符（\）一个宏通常写在一个单行上。
#define  message_for(a, b)  \    printf(#a &quot; 和 &quot; #b &quot;: 我们爱你！\n&quot;)

如果宏太长，一个单行容纳不下，则使用宏延续运算符 \
字符串常量化运算符（#）#include &lt;stdio.h&gt;#define  message_for(a, b)  \  printf(#a &quot; 和 &quot; #b &quot;: 我们爱你！\n&quot;)int main(void) &#123;  message_for(Carole, Debra);  return 0;&#125;

当上面的代码被编译和执行时，它会产生下列结果：
Carole 和 Debra: 我们爱你！

需要把一个宏的参数转换为字符串常量时，使用字符串常量化运算符 #
标记粘贴运算符（##）#include &lt;stdio.h&gt;#define tokenpaster(n) \    printf (&quot;token&quot; #n &quot; = %d&quot;, token##n)int main(void)&#123;  int token34 = 40;  tokenpaster(34);  return 0;&#125;

defined() 运算符#include &lt;stdio.h&gt;#if !defined (MESSAGE)   #define MESSAGE &quot;You wish!&quot;#endifint main(void) &#123;    printf(&quot;信息如下: %s\n&quot;, \        MESSAGE);      return 0;&#125;

参数化的宏int square(int x) &#123;   return x * x;&#125;

宏重写上面的代码，如下：
#define square(x) ((x) * (x))

宏名称和左圆括号之间不允许有空格
#include &lt;stdio.h&gt;#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))int main(void) &#123;    printf(&quot;20 到 10 之间的最大值是 %d\n&quot;, \        MAX(10, 20));      return 0;&#125;

Warning 和 Error

在 C 语言中，警告（Warning）和错误（Error）是编译器用于标识代码潜在问题或阻止代码编译的机制。
警告警告提示代码中可能存在的问题，但不会阻止代码编译。处理警告可以提升代码质量和可移植性。
常见警告示例未使用的变量  
int x; printf(&quot;%d&quot;, x);

类型隐式转换（可能导致数据丢失）  
int x = 3.14; // 浮点数被隐式转换int a = 2147483647 + 1; // 可能溢出

函数声明与定义不匹配
错误错误会阻止代码编译，必须修复才能继续编译。
常见错误示例：
语法错误（如缺少分号）
int x = 1

函数定义冲突
void func(int);void func(double);

函数或变量未定义
y = 10; printf(&quot;%d&quot;, y);

头文件缺失或冲突
#include &lt;unknown.h&gt;

使用编译器指令控制警告和错误

抑制警告可以使用编译器选项来关闭特定的警告，例如在 GCC 中：
gcc -w file.c      # 禁用所有警告gcc -Wall file.c   # 启用所有常见警告gcc -Werror file.c # 将警告视为错误

使用 #pragma 控制警告在某些编译器中，可以使用 #pragma 指令启用或禁用警告：
#include &lt;stdio.h&gt;#pragma warning(disable : 4996) // 禁用警告（适用于 MSVC 编译器）int main() &#123;    printf(&quot;Hello, world!&quot;);    return 0;&#125;

总结


区别点
Warning（警告）
Error（错误）



严重程度
程序可继续编译，但可能存在隐患
编译无法完成，必须修复


编译结果
生成可执行文件
无法生成可执行文件


触发原因
潜在问题，例如隐式转换或未使用的变量
语法或语义错误，例如语法错误或未定义变量


修复必要性
可选择修复，但建议修复以避免潜在问题
必须修复才能继续编译


编译器选项调整
可以忽略或转换为错误（如 -Werror）
无法调整，必须修复


函数函数声明和定义

int main() &#123;  printf(&quot;Hello World!&quot;);  return 0;&#125;

函数由两部分组成
void myFunction() &#123; // 声明 declaration  // 函数体（要执行的代码）(definition)&#125;



Declaration 声明函数名称、返回类型和参数 (如果有)
Definition 函数体 (要执行的代码)


// 函数声明void myFunction();// 主要方法int main() &#123;  myFunction(); // --&gt; 调用函数  return 0;&#125;void myFunction() &#123;// 函数定义  printf(&quot;晚上好！&quot;);&#125;

调用函数// 创建函数void myFunction() &#123;  printf(&quot;晚上好！&quot;);&#125;int main() &#123;  myFunction();  // 调用函数  myFunction();  // 可以被多次调用  return 0;&#125;// 输出 -&gt; &quot;晚上好！&quot;// 输出 -&gt; &quot;晚上好！&quot;

函数参数void myFunction(char name[]) &#123;  printf(&quot;Hello %s\n&quot;, name);&#125;int main() &#123;  myFunction(&quot;Liam&quot;);  myFunction(&quot;Jenny&quot;);  return 0;&#125;// Hello Liam// Hello Jenny

多个参数void myFunction(char name[], int age) &#123;  printf(&quot;你好 %s 你 %d 岁了。\n&quot;,name,age);&#125;int main() &#123;  myFunction(&quot;Liam&quot;, 3);  myFunction(&quot;Jenny&quot;, 14);  return 0;&#125;// 你好 Liam 你 3 岁了。// 你好 Jenny 你 14 岁了。

返回值

int myFunction(int x) &#123;  return 5 + x;&#125;int main() &#123;  printf(&quot;结果: %d&quot;, myFunction(3));  return 0;&#125;// 输出 8 (5 + 3)

两个参数
int myFunction(int x, int y) &#123;  return x + y;&#125;int main() &#123;  printf(&quot;结果: %d&quot;, myFunction(5, 3));  // 将结果存储在变量中  int result = myFunction(5, 3);  printf(&quot;结果 = %d&quot;, result);  return 0;&#125;// 结果: 8 (5 + 3)// 结果 = 8 (5 + 3)

递归示例int sum(int k);int main() &#123;  int result = sum(10);  printf(&quot;%d&quot;, result);  return 0;&#125;int sum(int k) &#123;  if (k &gt; 0) &#123;    return k + sum(k - 1);  &#125; else &#123;    return 0;  &#125;&#125;

数学函数#include &lt;math.h&gt;printf(&quot;%f&quot;, sqrt(16));   // 平方根printf(&quot;%f&quot;, ceil(1.4));  // 四舍五入 (入)printf(&quot;%f&quot;, floor(1.4)); // 四舍五入 (舍)printf(&quot;%f&quot;, pow(4, 3));  // x(4)的y(3)次方



abs(x) 绝对值
acos(x) 反余弦值
asin(x) 反正弦值
atan(x) 反正切
cbrt(x) 立方根
cos(x) 余弦
exp(x) Ex 的值
sin(x) x 的正弦值
tan(x) 角度的正切



Structures 结构创建结构struct MyStructure &#123;  // 结构声明  int myNum;     // 成员（int 变量）  char myLetter; // 成员（char 变量）&#125;; // 用分号结束结构

创建一个名为 s1 的结构变量
&#123;7&#125;struct myStructure &#123;  int myNum;  char myLetter;&#125;;int main() &#123;  struct myStructure s1;  return 0;&#125;

结构中的字符串&#123;9&#125;struct myStructure &#123;  int myNum;  char myLetter;  char myString[30]; // String&#125;;int main() &#123;  struct myStructure s1;  strcpy(s1.myString, &quot;Some text&quot;);  // 打印值  printf(&quot;我字符串: %s&quot;, s1.myString);  return 0;&#125;

使用 strcpy 函数为字符串赋值
访问结构成员

&#123;11,12,16&#125;// 创建一个名为 myStructure 的结构struct myStructure &#123;  int myNum;  char myLetter;&#125;;int main() &#123;  // 创建一个名为 s1 的 myStructure 结构变量  struct myStructure s1;  // 为 s1 的成员赋值  s1.myNum = 13;  s1.myLetter = &#x27;B&#x27;;  // 创建一个名为 s2 的 myStructure 结构变量  // 并为其赋值  struct myStructure s2 = &#123;13, &#x27;B&#x27;&#125;;  // 打印值  printf(&quot;My number: %d\n&quot;, s1.myNum);  printf(&quot;My letter: %c\n&quot;, s1.myLetter);  return 0;&#125;

创建不同的结构变量
struct myStructure s1;struct myStructure s2;// 为不同的结构变量赋值s1.myNum = 13;s1.myLetter = &#x27;B&#x27;;s2.myNum = 20;s2.myLetter = &#x27;C&#x27;;

复制结构&#123;6&#125;struct myStructure s1 = &#123;  13, &#x27;B&#x27;, &quot;Some text&quot;&#125;;struct myStructure s2;s2 = s1;

示例中，将 s1 的值复制到 s2
修改值&#123;6,7&#125;// 创建一个结构变量并为其赋值struct myStructure s1 = &#123;  13, &#x27;B&#x27;&#125;;// 修改值s1.myNum = 30;s1.myLetter = &#x27;C&#x27;;// 打印值printf(&quot;%d %c %s&quot;,    s1.myNum,    s1.myLetter);

文件处理文件处理函数


函数
描述 Description



fopen()
打开新文件或现有文件


fprintf()
将数据写入文件


fscanf()
从文件中读取数据


fputc()
将一个字符写入文件


fgetc()
从文件中读取一个字符


fclose()
关闭文件


fseek()
将文件指针设置到给定位置


fputw()
将整数写入文件


fgetw()
从文件中读取一个整数


ftell()
返回当前位置


rewind()
将文件指针设置为文件的开头


C 库中有许多函数可以打开&#x2F;读取&#x2F;写入&#x2F;搜索和关闭文件
打开模式参数


模式 Mode
描述 Description



r
以读取模式打开一个文本文件，允许读取文件


w
以写模式打开一个文本文件，允许写入文件


a
以追加模式打开一个文本文件如果文件不存在，则会创建一个新文件


r+
以读写模式打开一个文本文件，允许读写文件


w+
以读写模式打开一个文本文件，允许读写文件


a+
以读写模式打开一个文本文件，允许读写文件


rb
以读取模式打开二进制文件


wb
以写入模式打开二进制文件


ab
以追加模式打开二进制文件


rb+
以读写模式打开二进制文件


wb+
以读写模式打开二进制文件


ab+
以读写模式打开二进制文件


打开文件：fopen()&#123;6&#125;#include&lt;stdio.h&gt;void main( ) &#123;  FILE *fp;  char ch;  fp = fopen(&quot;file_handle.c&quot;, &quot;r&quot;);  while (1) &#123;    ch = fgetc(fp);    if (ch == EOF)    break;    printf(&quot;%c&quot;, ch);  &#125;  fclose(fp);&#125;

对文件执行所有操作后，必须关闭 fclose() 该文件
写入文件：fprintf()&#123;7&#125;#include &lt;stdio.h&gt;main() &#123;  FILE *fp;  fp = fopen(&quot;file.txt&quot;, &quot;w&quot;); // 打开文件  // 将数据写入文件  fprintf(fp, &quot;fprintf 的 Hello 文件..\n&quot;);  fclose(fp); // 关闭文件  &#125;  

读取文件：fscanf()&#123;6&#125;#include &lt;stdio.h&gt;  main()&#123;  FILE *fp;  char buff[255]; // 创建char数组存储文件数据  fp = fopen(&quot;file.txt&quot;, &quot;r&quot;);  while(fscanf(fp, &quot;%s&quot;, buff)!=EOF) &#123;    printf(&quot;%s &quot;, buff);  &#125;  fclose(fp);&#125;

写入文件：fputc()&#123;6&#125;#include &lt;stdio.h&gt;main()&#123;  FILE *fp;  fp = fopen(&quot;file1.txt&quot;, &quot;w&quot;); // 打开文件  fputc(&#x27;a&#x27;,fp); // 将单个字符写入文件  fclose(fp);    // 关闭文件&#125;

读取文件：fgetc()&#123;8&#125;#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main() &#123;  FILE *fp;  char c;  clrscr();  fp=fopen(&quot;myfile.txt&quot;, &quot;r&quot;);  while((c=fgetc(fp))!=EOF)&#123;    printf(&quot;%c&quot;, c);  &#125;  fclose(fp);  getch();&#125;

写入文件：fputs()&#123;8&#125;#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main()&#123;  FILE *fp;  clrscr();  fp = fopen(&quot;myfile2.txt&quot;,&quot;w&quot;);  fputs(&quot;hello c programming&quot;,fp);  fclose(fp);  getch();&#125;

读取文件：fgets()&#123;10&#125;#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main() &#123;  FILE *fp;  char text[300];  clrscr();  fp=fopen(&quot;myfile2.txt&quot;, &quot;r&quot;);  printf(&quot;%s&quot;, fgets(text, 200, fp));  fclose(fp);  getch();&#125;

fseek()&#123;8&#125;#include &lt;stdio.h&gt;void main()&#123;  FILE *fp;  fp = fopen(&quot;myfile.txt&quot;,&quot;w+&quot;);  fputs(&quot;This is Book&quot;, fp);  // 将文件指针设置到给定位置  fseek(fp, 7, SEEK_SET);  fputs(&quot;Kenny Wong&quot;, fp);  fclose(fp);&#125;

将文件指针设置到给定位置
rewind()&#123;11&#125;#include&lt;stdio.h&gt;#include&lt;conio.h&gt;void main()&#123;  FILE *fp;  char c;  clrscr();  fp=fopen(&quot;file.txt&quot;, &quot;r&quot;);  while((c=fgetc(fp)) != EOF)&#123;    printf(&quot;%c&quot;, c);  &#125;  rewind(fp); // 将文件指针移动到文件的开头  while((c=fgetc(fp)) != EOF)&#123;    printf(&quot;%c&quot;, c);  &#125;  fclose(fp);  getch();&#125;// 输出// Hello World!Hello World!

ftell()&#123;11&#125;#include &lt;stdio.h&gt;#include &lt;conio.h&gt;void main ()&#123;   FILE *fp;   int length;   clrscr();   fp = fopen(&quot;file.txt&quot;, &quot;r&quot;);   fseek(fp, 0, SEEK_END);   length = ftell(fp); // 返回当前位置   fclose(fp);   printf(&quot;文件大小: %d bytes&quot;, length);   getch();&#125;// 输出// 文件大小: 18 bytes

C 网络编程网络编程介绍C使用sockets进行网络通信。包含头文件：

#include &lt;sys/socket.h&gt;: 套接字操作，如创建、绑定和监听套接字
#include &lt;arpa/inet.h&gt;: IP 地址转换
#include &lt;unistd.h&gt;: 关闭套接字等
#include &lt;netinet/in.h&gt;: 网络地址结构定义和相关敞亮

创建套接字网络通信的第一步是创建套接字。套接字是网络通信的基础，通过它可以与远程主机进行数据交换。
服务端int server_fd, new_socket; // 定义服务器文件描述符和新连接的套接字int port = 8080; // 服务器使用的端口号// 创建套接字文件描述符// AF_INET 表示使用 IPv4 协议，SOCK_STREAM 表示使用 TCP 协议，协议参数通常为 0（默认 TCP）if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == 0) &#123;    perror(&quot;socket failed&quot;);    exit(EXIT_FAILURE);&#125;

客户端int sock = 0;  // 客户端的套接字描述符struct sockaddr_in serv_addr;  // 定义服务器地址结构体// 创建套接字if ((sock = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) &#123;    perror(&quot;Socket creation failed&quot;);    exit(EXIT_FAILURE);&#125;

绑定套接字服务端创建套接字后，需要将其绑定到特定的 IP 地址和端口，以便客户端能够连接。
服务端struct sockaddr_in address;  // 定义存储地址信息的结构体address.sin_family = AF_INET;  // 设置地址族为 IPv4address.sin_addr.s_addr = INADDR_ANY;  // 将服务器绑定到所有可用的网络接口（即本机的所有 IP 地址）address.sin_port = htons(port);  // 将端口号转换为网络字节序，大端模式// 将套接字绑定到指定的地址和端口上// bind() 将服务器的文件描述符与 IP 地址和端口号进行绑定，以便客户端能够通过该地址和端口访问服务器if (bind(server_fd, (struct sockaddr *)&amp;address, sizeof(address)) &lt; 0) &#123;    perror(&quot;bind failed&quot;);    exit(EXIT_FAILURE);&#125;

监听和接收连接服务端在绑定套接字之后，需要进入监听状态，以等待客户端的连接请求。
服务端// 开始监听客户端连接// 监听连接请求// listen() 函数将套接字设置为被动模式，准备接收来自客户端的连接请求if (listen(server_fd, 3) &lt; 0) &#123;  // 第二个参数 3 表示连接请求的队列大小    perror(&quot;listen failed&quot;);    exit(EXIT_FAILURE);&#125;int addrlen = sizeof(address);  // 获取地址结构体的大小// accept() 函数会阻塞等待客户端的连接请求，一旦连接请求到来，创建一个新的套接字 new_socket 用于数据传输if ((new_socket = accept(server_fd, (struct sockaddr *)&amp;address, (socklen_t*)&amp;addrlen)) &lt; 0) &#123;    perror(&quot;accept failed&quot;);    exit(EXIT_FAILURE);&#125;

连接到服务端客户端使用 connect() 函数连接到服务器的 IP 地址和端口。
客户端// 设置服务器地址serv_addr.sin_family = AF_INET;  // 设置地址族为 IPv4serv_addr.sin_port = htons(port);  // 将端口号转换为网络字节序// 将 IP 地址转换为二进制并存储在 serv_addr 结构体中if (inet_pton(AF_INET, &quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr) &lt;= 0) &#123;    perror(&quot;Invalid address/ Address not supported&quot;);    exit(EXIT_FAILURE);&#125;// 连接服务器// connect() 函数将客户端的套接字与服务器的地址绑定，从而建立连接if (connect(sock, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) &lt; 0) &#123;    perror(&quot;Connection Failed&quot;);    exit(EXIT_FAILURE);&#125;

发送和接收数据一旦连接建立，服务端和客户端可以通过套接字发送和接收数据。
服务端// 服务端从客户端接收数据char buffer[1024] = &#123;0&#125;;  // 缓冲区，用于存储接收的数据int valread = read(new_socket, buffer, 1024);  // 从客户端读取数据printf(&quot;Client: %s\n&quot;, buffer);  // 打印接收到的客户端数据// 服务端发送响应数据给客户端const char *response = &quot;Hello from server&quot;;  // 响应消息send(new_socket, response, strlen(response), 0);  // 发送数据到客户端printf(&quot;Server message sent\n&quot;);

客户端// 客户端发送数据给服务端const char *message = &quot;Hello from client&quot;;  // 要发送的消息send(sock, message, strlen(message), 0);  // 发送数据到服务端printf(&quot;Client message sent\n&quot;);// 客户端从服务端接收响应数据char buffer[1024] = &#123;0&#125;;  // 缓冲区，用于存储接收到的数据int valread = read(sock, buffer, 1024);  // 读取服务端的响应数据printf(&quot;Server: %s\n&quot;, buffer);  // 打印接收到的服务端数据

关闭套接字完成通信后，双方都应关闭各自的套接字以释放资源。
服务端// 关闭服务端套接字close(new_socket);  // 关闭用于数据传输的客户端套接字close(server_fd);   // 关闭服务器的监听套接字

客户端// 关闭客户端套接字close(sock);  // 关闭客户端的套接字

I&#x2F;O多路复用多路复用介绍在网络编程中，服务端可以使用 I&#x2F;O 多路复用 技术，如 select、poll 或 epoll。这些技术允许服务端同时监听多个文件描述符（如套接字），并在其中一个发生事件时进行处理，提升系统效率。包含头文件：

#include &lt;sys/select.h&gt;: 提供 select
#include &lt;poll.h&gt;: 提供 poll
#include &lt;sys/epoll.h&gt;: 提供epoll

使用selectfd_set read_fds;  // 定义文件描述符集合FD_ZERO(&amp;read_fds);  // 清空集合FD_SET(server_socket, &amp;read_fds);  // 将服务端套接字加入集合int max_fd = server_socket;int activity = select(max_fd + 1, &amp;read_fds, NULL, NULL, NULL);  // 等待事件发生if (activity &lt; 0 &amp;&amp; errno != EINTR) &#123;    perror(&quot;select error&quot;);&#125;

使用pollstruct pollfd fds[2];  // 定义文件描述符数组fds[0].fd = server_socket;fds[0].events = POLLIN;  // 监听读事件int poll_count = poll(fds, 2, -1);  // 等待事件if (poll_count &lt; 0) &#123;    perror(&quot;poll error&quot;);&#125;

使用epollint epoll_fd = epoll_create1(0);  // 创建 epoll 文件描述符struct epoll_event event;event.events = EPOLLIN;event.data.fd = server_socket;if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_socket, &amp;event) == -1) &#123;    perror(&quot;epoll_ctl failed&quot;);&#125;struct epoll_event events[10];  // 事件数组int event_count = epoll_wait(epoll_fd, events, 10, -1);  // 等待事件发生for (int i = 0; i &lt; event_count; i++) &#123;    if (events[i].data.fd == server_socket) &#123;        // 处理服务端套接字上的事件    &#125;&#125;

杂项Docker 运行环境


安装 Docker

创建 Dockerfile 文件
  FROM alpine:3.14RUN apk add --no-cache gcc musl-devRUN apk add --no-cache g++

生成本地 myalpine 镜像
  docker build -t myalpine .

运行映像，把当前路径 ($PWD) 映射至容器的 /test 目录，用 gcc 编译程序，exit返回
  docker run -it -v $PWD:/test myalpineroot@b1a38bd7107a:/# cd testroot@b1a38bd7107a:/test# gcc -o hello hello.cHello Worldroot@b1a38bd7107a:/test# exitexit



另见
C 教程 (jaywcjlove.github.io)

]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>后端编程</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 备忘录</title>
    <url>/2025/01/08/cpp/</url>
    <content><![CDATA[C++ 备忘清单提供基本语法和方法的 C++ 快速参考备忘单
入门hello.cpp#include &lt;iostream&gt;int main() &#123;    std::cout &lt;&lt; &quot;Hello Quick Reference\n&quot;;    return 0;&#125;

编译运行
$ g++ hello.cpp -o hello$ ./helloHello Quick Reference

变量int number = 5;       // 整数float f = 0.95;       // 浮点数double PI = 3.14159;  // 浮点数char yes = &#x27;Y&#x27;;       // 特点std::string s = &quot;ME&quot;; // 字符串（文本）bool isRight = true;  // 布尔值// 常量const float RATE = 0.8;


int age &#123;25&#125;;      // 自 C++11std::cout &lt;&lt; age;  // 打印 25

原始数据类型


数据类型
大小
范围



int
4 bytes
-231 到 231-1


float
4 bytes
N&#x2F;A


double
8 bytes
N&#x2F;A


char
1 byte
-128 到 127


bool
1 byte
true &#x2F; false


void
N&#x2F;A
N&#x2F;A


wchar_t
2 到 4 bytes
1 个宽字符




用户输入int num;std::cout &lt;&lt; &quot;Type a number: &quot;;std::cin &gt;&gt; num;std::cout &lt;&lt; &quot;You entered &quot; &lt;&lt; num;

交换int a = 5, b = 10;std::swap(a, b);// 输出: a=10, b=5std::cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; &quot;, b=&quot; &lt;&lt; b;// 整数交换的奇技淫巧(x ^= y), (y ^= x), (x ^= y);// 注意！ 以下操作会造成  undefined behaviorx ^= y ^= x ^= y;

注释// C++中的单行注释/* 这是一个多行注释    在 C++ 中 */

If 语句if (a == 10) &#123;    // do something&#125;

查看: 条件
循环for (int i = 0; i &lt; 10; i++) &#123;    std::cout &lt;&lt; i &lt;&lt; &quot;\n&quot;;&#125;

查看: 循环 Loops
函数

#include &lt;iostream&gt;void hello();   // 声明int main() &#123;    // 主函数    hello();    // 执行函数&#125;void hello() &#123; // 定义  std::cout &lt;&lt; &quot;Hello Quick Reference!\n&quot;;&#125;

查看: 函数 Functions
引用int i = 1;int&amp; ri = i; // ri 是对 i 的引用ri = 2; // i 现在改为 2std::cout &lt;&lt; &quot;i=&quot; &lt;&lt; i;i = 3;   // i 现在改为 3std::cout &lt;&lt; &quot;ri=&quot; &lt;&lt; ri;

ri 和 i 指的是相同的内存位置
命名空间#include &lt;iostream&gt;namespace ns1 &#123;int val()&#123;return 5;&#125;&#125;int main()&#123;    std::cout &lt;&lt; ns1::val();&#125;


#include &lt;iostream&gt;namespace ns1 &#123;int val()&#123;return 5;&#125;&#125;using namespace ns1;using namespace std;int main()&#123;    cout &lt;&lt; val();&#125;

名称空间允许名称下的全局标识符
C++ 数组定义std::array&lt;int, 3&gt; marks; // 定义marks[0] = 92;marks[1] = 97;marks[2] = 98;// 定义和初始化std::array&lt;int, 3&gt; marks = &#123;92, 97, 98&#125;;// 有空成员std::array&lt;int, 3&gt; marks = &#123;92, 97&#125;;std::cout &lt;&lt; marks[2]; // 输出: 0

操控┌─────┬─────┬─────┬─────┬─────┬─────┐| 92  | 97  | 98  | 99  | 98  | 94  |└─────┴─────┴─────┴─────┴─────┴─────┘   0     1     2     3     4     5


std::array&lt;int, 6&gt; marks = &#123;  92, 97, 98, 99, 98, 94&#125;;// 打印第一个元素std::cout &lt;&lt; marks[0];// 将第 2 个元素更改为 99marks[1] = 99;// 从用户那里获取输入std::cin &gt;&gt; marks[2];

展示char ref[5] = &#123;&#x27;R&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;;// 基于范围的for循环for (const int &amp;n : ref) &#123;    std::cout &lt;&lt; std::string(1, n);&#125;// 传统的for循环for (int i = 0; i &lt; sizeof(ref); ++i) &#123;    std::cout &lt;&lt; ref[i];&#125;

多维     j0   j1   j2   j3   j4   j5   ┌────┬────┬────┬────┬────┬────┐i0 | 1  | 2  | 3  | 4  | 5  | 6  |   ├────┼────┼────┼────┼────┼────┤i1 | 6  | 5  | 4  | 3  | 2  | 1  |   └────┴────┴────┴────┴────┴────┘


int x[2][6] = &#123;    &#123;1,2,3,4,5,6&#125;, &#123;6,5,4,3,2,1&#125;&#125;;for (int i = 0; i &lt; 2; ++i) &#123;    for (int j = 0; j &lt; 6; ++j) &#123;        std::cout &lt;&lt; x[i][j] &lt;&lt; &quot; &quot;;    &#125;&#125;// 输出: 1 2 3 4 5 6 6 5 4 3 2 1

C++ 条件If Clauseif (a == 10) &#123;    // do something&#125;


int number = 16;if (number % 2 == 0)&#123;    std::cout &lt;&lt; &quot;even&quot;;&#125;else&#123;    std::cout &lt;&lt; &quot;odd&quot;;&#125;// 输出: even

Else if 语句int score = 99;if (score == 100) &#123;    std::cout &lt;&lt; &quot;Superb&quot;;&#125;else if (score &gt;= 90) &#123;    std::cout &lt;&lt; &quot;Excellent&quot;;&#125;else if (score &gt;= 80) &#123;    std::cout &lt;&lt; &quot;Very Good&quot;;&#125;else if (score &gt;= 70) &#123;    std::cout &lt;&lt; &quot;Good&quot;;&#125;else if (score &gt;= 60)    std::cout &lt;&lt; &quot;OK&quot;;else    std::cout &lt;&lt; &quot;What?&quot;;

运算符

关系运算符


:–
–



a == b
a 等于 b


a != b
a 不等于 b


a &lt; b
a 小于 b


a &gt; b
a 大于 b


a &lt;= b
a 小于或等于 b


a &gt;= b
a 大于或等于 b


赋值运算符


范例
相当于



a += b
Aka a = a + b


a -= b
Aka a = a - b


a *= b
Aka a = a * b


a /= b
Aka a = a / b


a %= b
Aka a = a % b


逻辑运算符


Example
Meaning



exp1 &amp;&amp; exp2
Both are true (AND)


&#96;exp1



!exp
exp is false (NOT)


位运算符


Operator
Description



a &amp; b
Binary AND


&#96;a
b&#96;


a ^ b
Binary XOR


a ~ b
Binary One’s Complement


a &lt;&lt; b
Binary Shift Left


a &gt;&gt; b
Binary Shift Right


三元运算符           ┌── True ──┐Result = Condition ? Exp1 : Exp2;           └───── False ─────┘


int x = 3, y = 5, max;max = (x &gt; y) ? x : y;// 输出: 5std::cout &lt;&lt; max &lt;&lt; std::endl;


int x = 3, y = 5, max;if (x &gt; y) &#123;    max = x;&#125; else &#123;    max = y;&#125;// 输出: 5std::cout &lt;&lt; max &lt;&lt; std::endl;

switch 语句int num = 2;switch (num) &#123;    case 0:        std::cout &lt;&lt; &quot;Zero&quot;;        break;    case 1:        std::cout &lt;&lt; &quot;One&quot;;        break;    case 2:        std::cout &lt;&lt; &quot;Two&quot;;        break;    case 3:        std::cout &lt;&lt; &quot;Three&quot;;        break;    default:        std::cout &lt;&lt; &quot;What?&quot;;        break;&#125;

C++ 循环Whileint i = 0;while (i &lt; 6) &#123;    std::cout &lt;&lt; i++;&#125;// 输出: 012345

Do-whileint i = 1;do &#123;    std::cout &lt;&lt; i++;&#125; while (i &lt;= 5);// 输出: 12345

Continue 语句for (int i = 0; i &lt; 10; i++) &#123;    if (i % 2 == 0) &#123;        continue;    &#125;    std::cout &lt;&lt; i;&#125; // 输出: 13579

无限循环while (true) &#123; // true or 1    std::cout &lt;&lt; &quot;无限循环&quot;;&#125;


for (;;) &#123;    std::cout &lt;&lt; &quot;无限循环&quot;;&#125;


for(int i = 1; i &gt; 0; i++) &#123;    std::cout &lt;&lt; &quot;infinite loop&quot;;&#125;

for_each (C++11 起)#include &lt;iostream&gt;int main()&#123;    auto print = [](int num) &#123;      std::cout &lt;&lt; num &lt;&lt; std::endl;    &#125;;    std::array&lt;int, 4&gt; arr = &#123;1, 2, 3, 4&#125;;    std::for_each(arr.begin(), arr.end(), print);    return 0;&#125;


基于范围 (C++11 起)for (int n : &#123;1, 2, 3, 4, 5&#125;) &#123;    std::cout &lt;&lt; n &lt;&lt; &quot; &quot;;&#125;// 输出: 1 2 3 4 5


std::string hello = &quot;Quick Reference.ME&quot;;for (char c: hello)&#123;    std::cout &lt;&lt; c &lt;&lt; &quot; &quot;;&#125;// 输出: Q u i c k R e f . M E

中断语句int password, times = 0;while (password != 1234) &#123;    if (times++ &gt;= 3) &#123;        std::cout &lt;&lt; &quot;Locked!\n&quot;;        break;    &#125;    std::cout &lt;&lt; &quot;Password: &quot;;    std::cin &gt;&gt; password; // input&#125;

Several variationsfor (int i = 0, j = 2; i &lt; 3; i++, j--)&#123;    std::cout &lt;&lt; &quot;i=&quot; &lt;&lt; i &lt;&lt; &quot;,&quot;;    std::cout &lt;&lt; &quot;j=&quot; &lt;&lt; j &lt;&lt; &quot;;&quot;;&#125;// 输出: i=0,j=2;i=1,j=1;i=2,j=0;

autostd:: string s = &quot;hello world&quot;;for(auto c: s)&#123;    std:: cout &lt;&lt; c &lt;&lt; &quot; &quot;;&#125;// 输出: h e l l o   w o r l d

C++ 函数参数和返回#include &lt;iostream&gt;int add(int a, int b) &#123;    return a + b;&#125;int main() &#123;    std::cout &lt;&lt; add(10, 20);&#125;

add 是一个接受 2 个整数并返回整数的函数
重载void fun(string a, string b) &#123;    std::cout &lt;&lt; a + &quot; &quot; + b;&#125;void fun(string a) &#123;    std::cout &lt;&lt; a;&#125;void fun(int a) &#123;    std::cout &lt;&lt; a;&#125;

内置函数#include &lt;iostream&gt;#include &lt;cmath&gt; // 导入库int main() &#123;    // sqrt() 来自 cmath    std::cout &lt;&lt; sqrt(9);&#125;

Lambda 表达式

Lambda 表达式可以在函数内定义，可以理解为在函数内定义的临时函数。格式：
auto func = []() -&gt; return_type &#123; &#125;;


[]为捕获列表，能够捕获其所在函数的局部变量

一个空的捕获列表代表Lambda表达式不捕获任何的变量

对于值捕获，直接在中括号中填写要捕获的变量即可：
  int val = 5;auto func = [val]() -&gt; return_type &#123; &#125;;


对于引用捕获，需要在捕获的变量前添加&amp;：
string str(&quot;hello world!&quot;);auto func = [&amp;str]() -&gt; return_type &#123; &#125;;

如果变量太多，需要编译器根据我们编写的代码自动捕获，可以采用隐式捕获的方式。

全部值捕获：
  int val1, val2;auto func = [=]() -&gt; int    &#123;        return val1 + val2;    &#125;;

全部引用捕获：
  string str1(&quot;hello&quot;), str2(&quot;word!&quot;);auto func = [&amp;]() -&gt; string    &#123;        return str1 + str2;    &#125;;

混合隐式捕获：
  如果希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用：
  int val1 = 123, val2 = 456;string str1(&quot;123&quot;), str2(456);auto func1 = [=, &amp;str1]() -&gt; int    &#123;        return   val1 == std::stoi(str1)              ? val1 : val2;    &#125;;auto func2 = [&amp;, val1]() -&gt; int    &#123;        return   str1 == std::to_string(val1)              ? str1 : str2;    &#125;;


() 是参数列表，我们只需要按照普通函数的使用方法来使用即可

return_type 是函数的返回类型，-&gt; return_type 可以不写，编译器会自动推导

&#123;&#125; 中的内容就是函数体，依照普通函数的使用方法使用即可




此处给出一个 Lambda 表达式的实际使用例子(当然可以使用 str::copy):
// vec中包含1, 2, 3, 4, 5std::vector&lt;int&gt; vec(&#123;1, 2, 3, 4, 5&#125;);std::for_each(vec.begin(), vec.end(),              [](int&amp; ele) -&gt; void          &#123;              std::cout &lt;&lt; ele                          &lt;&lt; &quot; &quot;;          &#125;);

C++多线程多线程介绍g++编译选项：-std=c++11。包含头文件：

#include &lt;thread&gt;：C++多线程库
#include &lt;mutex&gt;：C++互斥量库
#include &lt;future&gt;：C++异步库

线程的创建

以普通函数作为线程入口函数：
void entry_1() &#123; &#125;void entry_2(int val) &#123; &#125;std::thread my_thread_1(entry_1);std::thread my_thread_2(entry_2, 5);

以类对象作为线程入口函数：
class Entry&#123;    void operator()() &#123; &#125;    void entry_function() &#123; &#125;&#125;;Entry entry;// 调用operator()()std::thread my_thread_1(entry);// 调用Entry::entry_functionstd::thread my_thread_2(&amp;Entry::entry_function, &amp;entry);

以lambda表达式作为线程入口函数：
std::thread my_thread([]() -&gt; void      &#123;         // ...      &#125;);

线程的销毁thread my_thread;// 阻塞my_thread.join();// 非阻塞my_thread.detach();

this_thread// 获取当前线程IDstd::this_thread::get_id();// 使当前线程休眠一段指定时间std::this_thread::sleep_for();// 使当前线程休眠到指定时间std::this_thread::sleep_until();// 暂停当前线程的执行，让别的线程执行std::this_thread::yield();

锁


#include &lt;mutex&gt;

锁的基本操作创建锁
std::mutex m;

上锁
m.lock();

解锁
m.unlock();

尝试上锁：成功返回true，失败返回false
m.try_lock();

解锁
m.unlock();

更简单的锁 —— std::lock_guard&lt;Mutex&gt;构造时上锁，析构时解锁
std::mutex m;std::lock_guard&lt;std::mutex&gt; lock(m);

额外参数：std::adopt_lock：只需解锁，无需上锁
// 手动上锁m.lock();std::lock_guard&lt;mutex&gt; lock(m,    std::adopt_lock);

unique_lock&lt;Mutex&gt;构造上锁，析构解锁
std::mutex m;std::unique_lock&lt;mutex&gt; lock(m);

std::adopt_lock只需解锁，无需上锁
// 手动上锁m.lock();std::unique_lock&lt;mutex&gt; lock(m,    std::adopt_lock);

std::try_to_lock尝试上锁，可以通过std::unique_lock&lt;Mutex&gt;::owns_lock()查看状态
std::unique_lock&lt;mutex&gt; lock(m,    std::try_to_lock);if (lock.owns_lock())&#123;    // 拿到了锁&#125;else&#123;    // 没有&#125;

std::defer_lock绑定锁，但不上锁
std::unique_lock&lt;mutex&gt; lock(m,    std::defer_lock);lock.lock();lock.unlock();

std::unique_lock&lt;Mutex&gt;::release返回所管理的mutex对象指针，**释放所有权。**一旦释放了所有权，那么如果原来互斥量处于互斥状态，程序员有责任手动解锁。
std::call_once当多个线程通过这个函数调用一个可调用对象时，只会有一个线程成功调用。
std::once_flag flag;void foo() &#123; &#125;std::call_once(flag, foo);

std::condition_variable创建条件变量std::condition_variable cond;

等待条件变量被通知std::unique_lock&lt;std::mutex&gt;    lock;extern bool predicate();// 调用方式 1cond.wait(lock);// 调用方式 2cond.wait(lock, predicate);



wait不断地尝试重新获取并加锁该互斥量，如果获取不到，它就卡在这里并反复尝试重新获取，如果获取到了，执行流程就继续往下走
wait在获取到互斥量并加锁了互斥量之后：
如果wait被提供了可调用对象，那么就执行这个可调用对象：
如果返回值为false，那么wait继续加锁，直到再次被 notified
如果返回值为true，那么wait返回，继续执行流程


如果wait没有第二个参数，那么直接返回，继续执行



std::condition_variable::notify_onenotify_one 唤醒一个调用 wait 的线程。注意在唤醒之前要解锁，否则调用 wait 的线程也会因为无法加锁而阻塞。
std::condition_variable::notify_all唤醒所有调用 wait 的线程。
获取线程的运行结果


#include &lt;future&gt;

创建异步任务double func(int val);// 使用std::async创建异步任务// 使用std::future获取结果// future模板中存放返回值类型std::future&lt;double&gt; result =    std::async(func, 5);

获取异步任务的返回值等待异步任务结束，但是不获取返回值：
result.wait();

获取异步任务的返回值：
int val = result.get();

注：

get()返回右值，因此只可调用一次
只要调用上述任意函数，线程就会一直阻塞到返回值可用（入口函数运行结束）

std::async 的额外参数额外参数可以被放在 std::async 的第一个参数位置，用于设定 std::async 的行为：

std::launch::deferred：入口函数的运行会被推迟到std::future&lt;T&gt;::get()或者std::future&lt;T&gt;::wait()被调用时。此时调用线程会直接运行线程入口函数，换言之，不会创建子线程
std::launch::async：立即创建子线程，并运行线程入口函数
std::launch::deferred | std::launch::async：默认值，由系统自行决定

返回值的状态让当前线程等待一段时间（等待到指定时间点），以期待返回值准备好：
extern double foo(int val) &#123;&#125;std::future&lt;double&gt; result =    async(foo, 5);//返回值类型std::future_status status;// 等待一段时间status = result.wait_for(  std::chrono::seconds(1)  );// 等待到某一时间点status = result.wait_for(  std::chrono::now() +    std::chrono::seconds(1)  );

在指定的时间过去后，可以获取等待的结果：
// 返回值已经准备好if (status ==     std::future_status::ready)&#123;&#125;// 超时：尚未准备好else if (status ==    std::future_status::timeout)&#123; &#125;// 尚未启动: std::launch::deferredelse if (status ==    std::future_status::deferred)&#123; &#125;

多个返回值如果要多次获取结果，可以使用std::shared_future，其会返回结果的一个拷贝。
std::shared_future&lt;T&gt; result;

对于不可拷贝对象，可以在std::shared_future中存储对象的指针，而非指针本身。
创建线程void threadFunction() &#123;  // 线程函数体  std::cout &lt;&lt; &quot;From thread&quot; &lt;&lt; std::endl;&#125;int main() &#123;  // 创建线程并开始执行线程函数  std::thread t(threadFunction);    // 等待线程执行完毕  t.join();    return 0;&#125;

传递参数给线程函数void threadFunction(int value) &#123;  // 线程函数体  std::cout &lt;&lt; &quot;Received value: &quot; &lt;&lt; value &lt;&lt; std::endl;&#125;int main() &#123;  int data = 42;  std::thread t(threadFunction, data);  t.join();  return 0;&#125;

使用Lambda表达式创建线程int main() &#123;  int data = 42;  std::thread t([data]() &#123;      // Lambda 表达式作为线程函数      std::cout &lt;&lt; &quot;Received value: &quot; &lt;&lt; data &lt;&lt; std::endl;  &#125;);  t.join();  return 0;&#125;

处理线程间的同步：#include &lt;mutex&gt;std::mutex mtx;void threadFunction() &#123;  std::lock_guard&lt;std::mutex&gt; lock(mtx);  std::cout &lt;&lt; &quot;Thread safe output.&quot; &lt;&lt; std::endl;&#125;int main() &#123;  std::thread t1(threadFunction);  std::thread t2(threadFunction);  t1.join();  t2.join();  return 0;&#125;

使用std::async启动异步任务：#include &lt;future&gt;int taskFunction() &#123;  // 异步任务  return 42;&#125;int main() &#123;  // 启动异步任务  std::future&lt;int&gt; fut = std::async(std::launch::async, taskFunction);    // 获取异步任务的结果  int result = fut.get();    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; result &lt;&lt; std::endl;  return 0;&#125;

C++ 预处理器预处理器


if
elif
else
endif
ifdef
ifndef
define
undef
include
line
error
pragma
defined
__has_include
__has_cpp_attribute
export
import
module



Includes#include &quot;iostream&quot;#include &lt;iostream&gt;

Defines#define FOO#define FOO &quot;hello&quot;#undef FOO

If

#ifdef DEBUG  console.log(&#x27;hi&#x27;);#elif defined VERBOSE  ...#else  ...#endif

Error#if VERSION == 2.0  #error Unsupported  #warning Not really supported#endif

宏#define DEG(x) ((x) * 57.29)

令牌连接#define DST(name) name##_s name##_tDST(object);   #=&gt; object_s object_t;

字符串化#define STR(name) #namechar * a = STR(object);   #=&gt; char * a = &quot;object&quot;;


文件和行#define LOG(msg) console.log(__FILE__, __LINE__, msg)#=&gt; console.log(&quot;file.txt&quot;, 3, &quot;hey&quot;)


各种各样的转义序列


转义序列
说明



\b
退格键


\f
换页


\n
换行


\r
返回


\t
水平制表符


\v
垂直制表符


\\
反斜杠


\&#39;
单引号


\&quot;
双引号


\?
问号


\0
空字符


关键字


alignas
alignof
and
and_eq
asm
atomic_cancel
atomic_commit
atomic_noexcept
auto
bitand
bitor
bool
break
case
catch
char
char8_t
char16_t
char32_t
class
compl
concept
const
consteval
constexpr
constinit
const_cast
continue
co_await
co_return
co_yield
decltype
default
delete
do
double
dynamic_cast
else
enum
explicit
export
extern
false
float
for
friend
goto
if
inline
int
long
mutable
namespace
new
noexcept
not
not_eq
nullptr
operator
or
or_eq
private
protected
public
reflexpr
register
reinterpret_cast
requires
return
short
signed
sizeof
static
static_assert
static_cast
struct
switch
synchronized
template
this
thread_local
throw
true
try
typedef
typeid
typename
union
unsigned
using
virtual
void
volatile
wchar_t
while
xor
xor_eq
final
override
transaction_safe
transaction_safe_dynamic



预处理器
if
elif
else
endif
ifdef
ifndef
define
undef
include
line
error
pragma
defined
__has_include
__has_cpp_attribute
export
import
module



另见
C++ Infographics &amp; Cheat Sheets (hackingcpp.com)
C++ reference (cppreference.com)
C++ Language Tutorials (cplusplus.com)

]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>后端编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 备忘录</title>
    <url>/2025/01/08/css/</url>
    <content><![CDATA[CSS 备忘清单这是一份关于 CSS 优点的快速参考备忘单，列出了选择器语法、属性、单位和其他有用的信息
入门介绍

CSS 功能丰富，不仅仅是布局页面
外部样式表 &lt;link&gt;&lt;/link&gt;&lt;link  href=&quot;./path/to/stylesheet/style.css&quot;  rel=&quot;stylesheet&quot;  type=&quot;text/css&quot;&gt;


内部样式表 &lt;style&gt;&lt;style&gt;  body &#123;    background-color: linen;  &#125;&lt;/style&gt;

内联样式 style&lt;h2 style=&quot;text-align: center;&quot;&gt;  居中文本&lt;/h2&gt;&lt;p style=&quot;color: blue; font-size: 18px;&quot;&gt;  蓝色，18像素文本&lt;/p&gt;


添加 class 类&lt;div class=&quot;classname&quot;&gt;&lt;/div&gt;&lt;div class=&quot;class1 ... classn&quot;&gt;&lt;/div&gt;

支持一个元素上的多个类
!important.post-title &#123;    color: blue !important;&#125;

覆盖所有以前的样式规则
选择器h1 &#123; &#125; #job-title &#123; &#125;div.hero &#123; &#125;div &gt; p &#123; &#125;

查看: CSS 选择器
文本颜色color: #2a2aff;color: green;color: rgb(34, 12, 64, 0.6);color: hsla(30 100% 50% / 0.6);

查看: Colors
背景background-color: blue;background-image: url(&quot;nyan-cat.gif&quot;);background-image: url(&quot;../image.png&quot;);

查看: Backgrounds
字体.page-title &#123;  font-weight: bold;  font-size: 30px;  font-family: &quot;Courier New&quot;;&#125;

查看: Fonts
定位.box &#123;  position: relative;  top: 20px;  left: 20px;&#125;

另见: Position
动画animation: 300ms linear 0s infinite;animation: bounce 300ms linear infinite;

查看: Animation
注释/* 这是一行注释 *//* 这是   多行注释 */

Flex 布局div &#123;  display: flex;  justify-content: center;&#125;div &#123;  display: flex;  justify-content: flex-start;&#125;

查看: Flexbox | Flex Tricks
Grid 布局#container &#123;  display: grid;  grid: repeat(2, 60px) / auto-flow 80px;&#125;#container &gt; div &#123;  background-color: #8ca0ff;  width: 50px;  height: 50px;&#125;

查看: Grid Layout
变量和计数器counter-set: subsection;counter-increment: subsection;counter-reset: subsection 0;:root &#123;  --bg-color: brown;&#125;element &#123;  background-color: var(--bg-color);&#125;

查看: 动态内容
CSS 选择器示例

组选择器h1, h2 &#123;    color: red;&#125;

链选择器h3.section-heading &#123;    color: blue;&#125;

属性选择器div[attribute=&quot;SomeValue&quot;] &#123;    background-color: red;&#125;

第一个子选择器p:first-child &#123;    font-weight: bold;&#125;

无子选择器.box:empty &#123;  background: lime;  height: 80px;  width: 80px;&#125;

基础


选择器
说明



*
所有元素


div
所有 div 标签


.classname
具有类的所有元素


#idname
带 ID 的元素


div,p
所有 div 和段落


#idname *
#idname 中的所有元素


另见: 元素 &#x2F; 类 &#x2F; ID &#x2F; 通配 选择器
组合器


选择器
说明



div.classname
具有特定类名的 div


div#idname
具有特定 ID 的 div


div p
div 中的所有段落


div &gt; p
父元素是 div 的 P 标签


div + p
div 之后的第一个同级 P 标签


div ~ p
div 之后所有的同级 P 标签


另见: 相邻兄弟 &#x2F; 通用兄弟 &#x2F; 子 选择器
属性选择器


选择器
说明



a[target]
带有 target 属性 #


a[target=&quot;_blank&quot;]
在新标签中打开 #


a[href^=&quot;/index&quot;]
以 &#x2F;index 开头 #


[class|=&quot;chair&quot;]
以chair开头 #


[class*=&quot;chair&quot;]
包含chair #


[title~=&quot;chair&quot;]
包含单词 chair #


a[href$=&quot;.doc&quot;]
以 .doc 结尾 #


[type=&quot;button&quot;]
指定类型 #


另见: 属性选择器
用户操作伪类


选择器
说明



a:link
链接正常 #


a:active
链接处于点击状态 #


a:hover
鼠标悬停链接 #


a:visited
访问链接 #



/* 未访问链接 */a:link &#123; color: blue; &#125;        /* 已访问链接 */a:visited &#123; color: purple; &#125;   /* 用户鼠标悬停 */a:hover &#123; background: yellow; &#125;/* 激活链接 */a:active &#123; color: red; &#125;       

伪类


选择器
说明



p::after
在 p 之后添加内容 #


p::before
在 p 之前添加内容 #


p::first-letter
p中的第一个字母 #


p::first-line
p 中的第一行 #


::selection
由用户选择 #


::placeholder
占位符 属性 #


:root
文档根元素 #


:target
突出显示活动锚点 #


div:empty
没有子元素的元素 #


p:lang(en)
带有 en 语言属性的 P #


:not(span)
不是跨度的元素 #


:host
shadowDOM 中选择自定义元素 #


::backdrop
处于全屏模式的元素样式 #


::marker
li 项目符号或者数字 #


::file-selector-button
type&#x3D;”file” input 按钮 #


输入伪类


选择器
说明



input:checked
检查 input #


input:disabled
禁用 input #


input:enabled
启用的 input #


input:default
有默认值的元素 #


input:blank
空的输入框 #


input:focus
input 有焦点 #


input:in-range
范围内的值 #


input:out-of-range
input 值超出范围 #


input:valid
input 有效值 #


input:invalid
input 无效值 #


input:optional
没有必需的属性 #


input:required
带有必需属性的 input #


input:read-only
具有只读属性 #


input:read-write
没有只读属性 #


input:indeterminate
带有 indeterminate 状态 #


结构伪类


选择器
说明



p:first-child
第一个孩子 #


p:last-child
最后一个孩子 #


p:first-of-type
第一个 p 类型的元素 #


p:last-of-type
某种类型的最后一个 #


p:nth-child(2)
其父母的第二个孩子 #


p:nth-child(3n42)
Nth-child(an + b) 公式 #


p:nth-last-child(2)
后面的二孩 #


p:nth-of-type(2)
其父级的第二个 p #


p:nth-last-of-type(2)
…从后面 #


p:only-of-type
其父级的唯一性 #


p:only-child
其父母的唯一孩子 #


:is(header, div) p
可以选择的元素 #


:where(header, div) p
与 :is 相同 #


a:has(&gt; img)
包含 img 元素的 a 元素 #


::first-letter
第一行的第一个字母 #


::first-line
第一行应用样式 #


CSS 字体属性




属性
说明



font-family:
字体族名或通用字体族名 #


font-size:
字体的大小 #


letter-spacing:
文本字符的间距 #


line-height:
多行文本间距 #


font-weight:
粗细程度 #


font-style:
字体样式 #


text-decoration:
文本的修饰线外观 #


text-align:
相对它的块父元素对齐 #


text-transform:
指定文本大小写 #


另见: Font
速记

font: italic    400     14px    /     1.5        sans-serif      ┈┈┬┈┈┈    ┈┬┈     ┈┬┈┈          ┈┬┈        ┈┬┈┈┈┈┈┈┈┈       样式      粗细    大小(必需的)    行高        字体(必需的)

示例font-family: Arial, sans-serif;font-size: 12pt;letter-spacing: 0.02em;

大小写

div &#123;  /* 首字母大写 Hello */  text-transform: capitalize;  /* 字母大写 HELLO */  text-transform: uppercase;  /* 字母小写 hello */  text-transform: lowercase;&#125;

@font-face@font-face &#123;  font-family: &#x27;Glegoo&#x27;;  src: url(&#x27;../Glegoo.woff&#x27;);&#125;

CSS 颜色命名颜色color: red;color: orange;color: tan;color: rebeccapurple;

更多标准颜色名称
十六进制颜色color: #090;color: #009900;color: #090a;color: #009900aa;

rgb() 颜色color: rgb(34, 12, 64, 0.6);color: rgba(34, 12, 64, 0.6);color: rgb(34 12 64 / 0.6);color: rgba(34 12 64 / 0.3);color: rgb(34.0 12 64 / 60%);color: rgba(34.6 12 64 / 30%);

HSL 颜色color: hsl(30, 100%, 50%, 0.6);color: hsla(30, 100%, 50%, 0.6);color: hsl(30 100% 50% / 0.6);color: hsla(30 100% 50% / 0.6);color: hsl(30.0 100% 50% / 60%);color: hsla(30.2 100% 50% / 60%);

其它color: inherit;color: initial;color: unset;color: transparent;color: currentcolor; /* 关键字 */

全局值/* 全局值 */color: inherit;color: initial;color: unset;

CSS 背景属性




属性
说明



background:
(速记)


background-color:
查看: Colors


background-image:
一个或者多个背景图像


background-position:
背景图片设置初始位置


background-size:
背景图片大小


background-clip:
背景(图片或颜色)是否延伸到边框、内边距盒子、内容盒子下面


background-repeat:
图像重复方式


background-attachment:
scroll&#x2F;fixed&#x2F;local


速记

background: #ff0   url(a.jpg)   left     top    /  100px auto   no-repeat   fixed;            #abc   url(b.png)   center   center /  cover        repeat-x    local;            ┈┬┈┈    ┈┬┈┈┈┈┈┈┈   ┈┬┈┈     ┈┬┈       ┈┈┬┈┈┈┈┈┈┈   ┈┈┬┈┈┈┈┈┈   ┈┈┬┈┈┈            颜色     图片         位置x    位置x       图片大小     图像重复方式  位置是在视口内固定

示例

background: url(img_flwr.gif) right bottom no-repeat, url(paper.gif) left top repeat;background: url(img_man.jpg) no-repeat center;background: rgb(2,0,36);background: linear-gradient(90deg, rgba(2,0,36,1) 0%,  rgba(13,232,230,1) 35%,  rgba(0,212,255,1) 100%);

CSS 盒子模型最大值&#x2F;最小值.column &#123;  max-width: 200px; /* 最大宽度 200 像素 */  width: 500px;     /* 宽度 500 像素 */&#125;

另见: max-width &#x2F; min-width &#x2F;  max-height &#x2F; min-height
边距&#x2F;补白.block-one &#123;  margin: 20px;  /* 边距 20 像素 */  padding: 10px; /* 补白 10 像素 */&#125;

另见: 边距(margin) &#x2F; 补白(padding)
Box-sizing.container &#123;  /* 设置的边框和补白的值是包含在 width 内的 */  box-sizing: border-box;&#125;

另见: box-sizing
能见度.invisible-elements &#123;  visibility: hidden; /* 隐藏元素 */&#125;

另见: Visibility
Auto 关键字div &#123;  /* 览器自己选择一个合适的外边距 */  margin: auto;&#125;

另见: 边距(margin)
溢出(Overflow).small-block &#123;  /* 浏览器总是显示滚动条 */  overflow: scroll;&#125;

另见: 溢出(overflow)
CSS 动画

速记

animation:  bounce   300ms      linear     100ms    infinite   alternate-reverse  both                   reverse              ┈┬┈┈     ┈┬┈┈┈      ┈┬┈┈┈┈     ┈┈┬┈┈    ┈┈┈┬┈┈┈┈   ┈┈┬┈┈┈┈┈┈┈┈┈┈┈┈┈┈  ┈┈┬┈┈┈                 ┈┈┬┈┈┈            动画名    动画时间     缓动函数    延迟     运行的次数   动画是否反向播放      如何将样式应用于其目标    是否运行或者暂停

属性




属性
说明



animation:
(速记)


animation-name:
动画名 #


animation-duration:
动画周期的时长 #


animation-timing-function:
缓动函数 #


animation-delay:
延迟 #


animation-iteration-count:
运行的次数 #


animation-direction:
动画是否反向播放 #


animation-fill-mode:
如何将样式应用于其目标 #


animation-play-state:
是否运行或者暂停 #


另见: 动画(Animation)
示例

/* @keyframes duration | timing-function | delay |   iteration-count | direction | fill-mode | play-state | name */animation: 3s ease-in 1s 2 reverse both paused slidein;/* @keyframes duration | timing-function | delay | name */animation: 3s linear 1s slidein;/* @keyframes duration | name */animation: 3s slidein;animation: 4s linear 0s infinite alternate move_eye;animation: bounce 300ms linear 0s infinite normal;animation: bounce 300ms linear infinite;animation: bounce 300ms linear infinite alternate-reverse;animation: bounce 300ms linear 2s infinite alternate-reverse forwards normal;

Javascript 事件

.one(&#x27;webkitAnimationEnd oanimationend msAnimationEnd animationend&#x27;)

CSS Flexbox

简单实例.container &#123;  display: flex;&#125;

.container &gt; div &#123;  flex: 1 1 auto;&#125;

容器

&#123;2-3,5-8,10-11,13-16,18-23&#125;.container &#123;  display: flex;  display: inline-flex;    flex-direction: row;            /* ltr - 行(左向右) ▶ */  flex-direction: row-reverse;    /* rtl - 行(右向左) ◀ */  flex-direction: column;         /* top-bottom ▼ */  flex-direction: column-reverse; /* bottom-top ▲ */    flex-wrap: nowrap;       /* 摆放到一行 */  flex-wrap: wrap;         /* 被打断到多个行中 */    align-items: flex-start; /* 垂直对齐 - 顶部 */  align-items: flex-end;   /* 垂直对齐 - 底部 */  align-items: center;     /* 垂直对齐 - 中间 */  align-items: stretch;    /* 所有人都一样的高度 (默认) */    justify-content: flex-start;    /* [◀◀◀        ] */  justify-content: center;        /* [    ■■■    ] */  justify-content: flex-end;      /* [        ▶▶▶] */  justify-content: space-between; /* [◀    ■    ▶] */  justify-content: space-around;  /* [ ■   ■   ■ ] */  justify-content: space-evenly;  /* [  ■  ■  ■  ] */&#125;

子元素.container &gt; div &#123;  /* 这个: */  flex: 1 0 auto;  /* 相当于这个： */  flex-grow: 1;  flex-shrink: 0;  flex-basis: auto;  order: 1;  align-self: flex-start;  /* left */  margin-left: auto;       /* right */&#125;

justify-content

justify-content: flex-start | flex-end | center | space-between

flex-start：左对齐(默认值)
╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆╭┈┈╮╭┈╮╭┈┈┈╮                     ┆┆╰┈┈╯╰┈╯╰┈┈┈╯                     ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯

flex-end：右对齐
╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆                     ╭┈┈╮╭┈╮╭┈┈┈╮┆┆                     ╰┈┈╯╰┈╯╰┈┈┈╯┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯

center： 居中
╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆          ╭┈┈╮╭┈╮╭┈┈┈╮           ┆┆          ╰┈┈╯╰┈╯╰┈┈┈╯           ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯

space-between：两端对齐，项目之间的间隔都相等
╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆╭┈┈╮           ╭┈╮          ╭┈┈┈╮┆┆╰┈┈╯           ╰┈╯          ╰┈┈┈╯┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯

space-around：每个项目两侧的间隔相等，项目之间的间隔比项目与边框的间隔大一倍
╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆   ╭┈┈╮        ╭┈╮       ╭┈┈┈╮   ┆┆   ╰┈┈╯        ╰┈╯       ╰┈┈┈╯   ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯

上面示例，假设主轴为从左到右
flex-wrapflex-wrap: nowrap | wrap | wrap-reverse;

nowrap：不换行(默认)
╭1╮╭2╮╭3╮╭4╮╭5╮╭6╮╭7╮╭8╮╭9╮╭10╮╰┈╯╰┈╯╰┈╯╰┈╯╰┈╯╰┈╯╰┈╯╰┈╯╰┈╯╰┈┈╯

wrap：换行，第一行在 上方
╭1┈╮ ╭2┈╮ ╭3┈╮ ╭4┈╮ ╭5┈╮ ╭6┈╮ ╭7┈╮╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯╭8┈╮ ╭9┈╮ ╭10╮╰┈┈╯ ╰┈┈╯ ╰┈┈╯

wrap-reverse：换行，第一行在 下方
╭8┈╮ ╭9┈╮ ╭10╮╰┈┈╯ ╰┈┈╯ ╰┈┈╯╭1┈╮ ╭2┈╮ ╭3┈╮ ╭4┈╮ ╭5┈╮ ╭6┈╮ ╭7┈╮╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯

项目都排在一条线（又称”轴线”）上
flex-directionflex-direction: row | row-reverse | column | column-reverse;


╭┈┈╮  ▲         ╭┈┈╮  ┆╰┈┈╯  ┆         ╰┈┈╯  ┆╭┈┈╮  ┆         ╭┈┈╮  ┆╰┈┈╯  ┆         ╰┈┈╯  ┆     ┈┈┈┈┈┈┈┈┈┈┈▶    ◀┈┈┈┈┈┈┈┈┈┈┈╭┈┈╮  ┆         ╭┈┈╮  ┆    ╭┈┈╮ ╭┈┈╮ ╭┈┈╮  ╭┈┈╮ ╭┈┈╮ ╭┈┈╮╰┈┈╯  ┆         ╰┈┈╯  ▼    ╰┈┈╯ ╰┈┈╯ ╰┈┈╯  ╰┈┈╯ ╰┈┈╯ ╰┈┈╯┈┬┈┈┈┈┈┈        ┈┬┈┈┈┈┈┈    ┈┬┈┈┈┈┈┈┈┈┈┈┈   ┈┬┈┈┈┈┈┈┈┈┈┈┈ column-reverse  column       row             row-reverse

属性决定主轴的方向（即项目的排列方向）
align-itemsalign-items: flex-start | flex-end | center | baseline | stretch;


  ▶ flex-start(起点对齐)    ▶ flex-end(终点对齐)╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮  ╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆ ╭┈┈╮ ╭┈┈╮ ╭┈┈╮ ╭┈┈╮ ┆  ┆                     ┆┆ ┆  ┆ ┆  ┆ ╰┈┈╯ ┆  ┆ ┆  ┆      ╭┈┈╮           ┆┆ ╰┈┈╯ ┆  ┆      ╰┈┈╯ ┆  ┆ ╭┈┈╮ ┆  ┆      ╭┈┈╮ ┆┆      ╰┈┈╯           ┆  ┆ ┆  ┆ ┆  ┆ ╭┈┈╮ ┆  ┆ ┆┆                     ┆  ┆ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯  ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯  ▶ center(中点对齐)        ▶ stretch(占满整个容器的高度)╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮  ╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆      ╭┈┈╮           ┆  ┆ ╭┈┈╮ ╭┈┈╮ ╭┈┈╮ ╭┈┈╮ ┆┆ ╭┈┈╮ ┆  ┆      ╭┈┈╮ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆┆ ┆  ┆ ┆  ┆ ╭┈┈╮ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆┆ ┆  ┆ ┆  ┆ ╰┈┈╯ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆┆ ╰┈┈╯ ┆  ┆      ╰┈┈╯ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆  ┆ ┆┆      ╰┈┈╯           ┆  ┆ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈╯ ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯  ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯  ▶ baseline(第一行文字的基线对齐)╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆  ╭┈┈┈┈┈┈╮               ╭┈┈┈┈┈┈╮             ┆┆  ┆      ┆ ╭┈┈┈┈╮ ╭┈┈┈┈╮ ┆      ┆ ╭┈┈┈┈╮╭┈┈┈┈╮┆┆  ┆ text ┆ ┆text┆ ┆text┆ ┆ text ┆ ┆text┆┆text┆┆┆  ┆      ┆ ╰┈┈┈┈╯ ┆    ┆ ┆      ┆ ╰┈┈┈┈╯┆    ┆┆┆  ╰┈┈┈┈┈┈╯        ╰┈┈┈┈╯ ╰┈┈┈┈┈┈╯       ╰┈┈┈┈╯┆┆                                              ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯

align-contentalign-content: flex-start | flex-end | center | space-between | space-around | stretch;



 ▶ flex-start(起点对齐)     ▶ flex-end(终点对齐)╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮  ╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆ ╭┈┈╮╭┈╮╭┈┈┈╮╭╮╭┈┈┈┈╮ ┆  ┆                      ┆┆ ╰┈┈╯╰┈╯╰┈┈┈╯╰╯╰┈┈┈┈╯ ┆  ┆ ╭┈┈╮╭┈╮╭┈┈┈╮╭╮╭┈┈┈┈╮ ┆┆ ╭┈┈┈╮╭╮              ┆  ┆ ╰┈┈╯╰┈╯╰┈┈┈╯╰╯╰┈┈┈┈╯ ┆┆ ╰┈┈┈╯╰╯              ┆  ┆ ╭┈┈┈╮╭╮              ┆┆                      ┆  ┆ ╰┈┈┈╯╰╯              ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯  ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯ ▶ center(中点对齐)         ▶ stretch(满整个交叉轴)╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮  ╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆                      ┆  ┆ ╭┈┈╮╭┈╮╭┈┈┈╮╭╮╭┈┈┈┈╮ ┆┆ ╭┈┈╮╭┈╮╭┈┈┈╮╭╮╭┈┈┈┈╮ ┆  ┆ ┆  ┆┆ ┆┆   ┆┆┆┆    ┆ ┆┆ ╰┈┈╯╰┈╯╰┈┈┈╯╰╯╰┈┈┈┈╯ ┆  ┆ ╰┈┈╯╰┈╯╰┈┈┈╯╰╯╰┈┈┈┈╯ ┆┆ ╭┈┈┈╮╭╮              ┆  ┆ ╭┈┈┈╮╭╮╭┈╮           ┆┆ ╰┈┈┈╯╰╯              ┆  ┆ ┆   ┆┆┆┆ ┆           ┆┆                      ┆  ┆ ╰┈┈┈╯╰╯╰┈╯           ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯  ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯ ▶ space-between(两端对齐)  ▶ space-around(均匀分布项目)╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮  ╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮ ┆ ╭┈┈╮╭┈┈╮╭┈┈╮╭┈┈╮╭┈┈╮ ┆  ┆                      ┆ ┆ ╰┈┈╯╰┈┈╯╰┈┈╯╰┈┈╯╰┈┈╯ ┆  ┆ ╭┈┈╮╭┈┈╮╭┈┈╮╭┈┈╮╭┈┈╮ ┆ ┆                      ┆  ┆ ╰┈┈╯╰┈┈╯╰┈┈╯╰┈┈╯╰┈┈╯ ┆ ┆                      ┆  ┆                      ┆ ┆                      ┆  ┆ ╭┈┈╮                 ┆ ┆ ╭┈┈╮                 ┆  ┆ ╰┈┈╯                 ┆ ┆ ╰┈┈╯                 ┆  ┆                      ┆ ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯  ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯ 

order.item &#123;  order: &lt;integer&gt;;&#125;


╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮ ╭┈┈┈┈┈┈┈┈┈╮┆ ╭1┈╮ ╭1┈┈╮ ╭1┈╮ ╭2┈╮ ╭3┈┈┈┈┈┈╮ ┆ ┆ ╭2┈┈┈┈╮ ┆┆ ╰┈┈╯ ╰┈┈┈╯ ╰┈┈╯ ╰┈┈╯ ╰┈┈┈┈┈┈┈╯ ┆ ┆ ╰┈┈┈┈┈╯ ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯ ┆ ╭2┈┈┈┈╮ ┆╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮ ┆ ╰┈┈┈┈┈╯ ┆┆ ╭-┈┈╮ ╭┈┈┈╮ ╭┈┈┈┈┈┈┈┈╮ ╭┈┈┈╮   ┆ ┆ ╭99┈┈┈╮ ┆┆ ┆-1 ┆ ┆ 1 ┆ ┆ 2      ┆ ┆ 5 ┆   ┆ ┆ ┆     ┆ ┆┆ ╰┈┈┈╯ ╰┈┈┈╯ ╰┈┈┈┈┈┈┈┈╯ ╰┈┈┈╯   ┆ ┆ ╰┈┈┈┈┈╯ ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯ ╰┈┈┈┈┈┈┈┈┈╯

属性 order 定义项目的排列顺序。数值越小，排列越靠前，默认为 0
flex-grow.item &#123;  flex-grow: &lt;number&gt;; /* default 0 */&#125;


╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆ ╭┈┈1┈┈╮╭┈┈2┈┈╮╭┈┈1┈┈╮ ┆┆ ╰┈┈┈┈┈╯╰┈┈┈┈┈╯╰┈┈┈┈┈╯ ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮┆ ╭┈1┈╮╭┈┈┈┈2┈┈┈┈╮╭┈1┈╮ ┆┆ ╰┈┈┈╯╰┈┈┈┈┈┈┈┈┈╯╰┈┈┈╯ ┆╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯

属性 flex-grow 定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
CSS Flexbox 技巧垂直中心.container &#123;  display: flex;&#125;.container &gt; div &#123;  width: 100px;  height: 100px;  margin: auto;&#125;

垂直中心 (2).container &#123;  display: flex;  /* 垂直的 */  align-items: center;   /* 水平的 */  justify-content: center;&#125;

重新排序.container &gt; .top &#123; order: 1;&#125;.container &gt; .bottom &#123; order: 2;&#125;

移动布局.container &#123;  display: flex;  flex-direction: column;&#125;.container &gt; .top &#123;  flex: 0 0 100px;&#125;.container &gt; .content &#123;  flex: 1 0 auto;&#125;

一个固定高度的顶部栏和一个动态高度的内容区域
Table-like 像表格

.container &#123;  display: flex;&#125;/* 这里的“px”值只是建议的百分比 */.container &gt; .checkbox &#123; flex: 1 0 20px; &#125;.container &gt; .subject  &#123; flex: 1 0 400px; &#125;.container &gt; .date     &#123; flex: 1 0 120px; &#125;

这会创建具有不同宽度的列，但会根据情况相应地调整大小
Vertical 垂直的.container &#123;  align-items: center;&#125;

垂直居中所有项目
左和右

.menu &gt; .left  &#123; align-self: flex-start; &#125;.menu &gt; .right &#123; align-self: flex-end; &#125;

CSS Grid 网格布局网格模板列#grid-container &#123;  display: grid;  width: 100px;  grid-template-columns: 20px 20% 60%;&#125;

fr 相对单位.grid &#123;  display: grid;  width: 100px;  grid-template-columns: 1fr 60px 1fr;&#125;

Grid Gap 网格间隙/* 行间距为 20px *//* 列之间的距离是 10px */#grid-container &#123;  display: grid;  grid-gap: 20px 10px;&#125;

CSS 网格行

CSS 语法:

grid-row: grid-row-start &#x2F; grid-row-end;

实例.item &#123;  grid-row: 1 / span 2;&#125;

CSS 块级网格#grid-container &#123;    display: block;&#125;

CSS 内联级别网格#grid-container &#123;  display: inline-grid;&#125;

CSS 网格行间隙grid-row-gap: length;

任何合法的长度值，例如 px 或 %。0 是默认值
CSS 网格区域.item1 &#123;  grid-area: 2 / 1 / span 2 / span 3;&#125;

minmax() 函数

.grid &#123;  display: grid;  grid-template-columns: 100px minmax(100px, 500px) 100px; &#125;


定义了一个长宽范围的闭区间
grid-row-start &amp; grid-row-endCSS 语法:

grid-row-start: auto|row-line;
grid-row-end: auto|row-line|span n;

实例grid-row-start: 2;grid-row-end: span 2;

对齐项目#container &#123;  display: grid;  justify-items: center;  grid-template-columns: 1fr;  grid-template-rows: 1fr 1fr 1fr;  grid-gap: 10px;&#125;

CSS 网格模板区域.item &#123;  grid-area: nav;&#125;.grid-container &#123;  display: grid;  grid-template-areas:  &#x27;nav nav . .&#x27;  &#x27;nav nav . .&#x27;;&#125;

Justify Self#grid-container &#123;  display: grid;  justify-items: start;&#125;.grid-items &#123;  justify-self: end;&#125;

网格项目位于行的右侧（末尾）
对齐项目#container &#123;  display: grid;  align-items: start;  grid-template-columns: 1fr;  grid-template-rows: 1fr 1fr 1fr;  grid-gap: 10px;&#125;

CSS 动态内容变量定义 CSS 变量
:root &#123;  --first-color: #16f;  --second-color: #ff7;&#125;

变量用法
#firstParagraph &#123;  background-color: var(--first-color);  color: var(--second-color);&#125;

另见: CSS Variable
计数器/* Set &quot;my-counter&quot; to 0 */counter-set: my-counter;

/* Increment &quot;my-counter&quot; by 1 */counter-increment: my-counter;

/* Decrement &quot;my-counter&quot; by 1 */counter-increment: my-counter -1;

/* Reset &quot;my-counter&quot; to 0 */counter-reset: my-counter;

另见: Counter set
使用计数器body &#123; counter-reset: section; &#125;h3::before &#123;  counter-increment: section;   content: &quot;Section.&quot; counter(section);&#125;

ol &#123;  counter-reset: section;     list-style-type: none;&#125;li::before &#123;  counter-increment: section;  content: counters(section, &quot;.&quot;) &quot; &quot;; &#125;

CSS 函数calc()div &#123;  width: calc(100% - 30px);  height: calc(100% - 30px);&#125;

calc() CSS 函数允许您在指定 CSS 属性值时执行计算
clamp()font-size: clamp(1rem, 10vw, 2rem);

设置随窗口大小改变的字体大小
attr()p:before &#123;  content: attr(data-foo) &quot; &quot;;&#125;

获取选择到的元素的某一 HTML 属性值
counter()

返回一个代表计数器的当前值的字符串
&lt;ol&gt;  &lt;li&gt;&lt;/li&gt;  &lt;li&gt;&lt;/li&gt;  &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;

ol &#123;  counter-reset: listCounter;&#125;li &#123;  counter-increment: listCounter;&#125;li::after &#123;  content: &quot;[&quot; counter(listCounter) &quot;] == [&quot;    counter(listCounter, upper-roman) &quot;]&quot;;&#125;

显示
1. [1]==[I]2. [2]==[II]3. [3]==[III]

counters()ol &#123;  counter-reset: count;&#125;li &#123;  counter-increment: count;&#125;li::marker &#123;   content: counters(count, &#x27;.&#x27;, upper-alpha) &#x27;) &#x27;;&#125;li::before &#123;  content: counters(count, &quot;.&quot;, decimal-leading-zero) &quot; == &quot; counters(count, &quot;.&quot;, lower-alpha);&#125;

嵌套计数器，返回表示指定计数器当前值的连接字符串
env()&lt;meta name=&quot;viewport&quot; content=&quot;... viewport-fit=cover&quot;&gt;



body &#123;  padding:    env(safe-area-inset-top, 20px)    env(safe-area-inset-right, 20px)    env(safe-area-inset-bottom, 20px)    env(safe-area-inset-left, 20px);&#125;

用户代理定义的环境变量值插入你的 CSS 中
fit-content()fit-content(200px)fit-content(5cm)fit-content(30vw)fit-content(100ch)

将给定大小夹紧为可用大小
max()从一个逗号分隔的表达式列表中选择最大（正方向）的值作为属性的值
width: max(10vw, 4em, 80px);

例子中，宽度最小会是 80px，除非视图宽度大于 800px 或者是一个 em 比 20px 宽
min()width: min(1vw, 4em, 80px);

从逗号分隔符表达式中选择一个最小值作为 CSS 的属性值
minmax()minmax(200px, 1fr)minmax(400px, 50%)minmax(30%, 300px)minmax(100px, max-content)minmax(min-content, 400px)minmax(max-content, auto)minmax(auto, 300px)minmax(min-content, auto)

repeat() 轨道列表的重复片段repeat(auto-fill, 250px)repeat(auto-fit, 250px)repeat(4, 1fr)repeat(4, [col-start] 250px [col-end])repeat(4, [col-start] 60% [col-end])

定义了一个长宽范围的闭区间
url()background: url(&quot;topbanner.png&quot;) #00D no-repeat fixed;list-style: square url(http://www.example.com/redball.png)


var():root &#123;  --main-bg-color: pink;&#125;body &#123;  background-color: var(--main-bg-color);&#125;


代替元素中任何属性中的值的任何部分
CSS 技巧强制不换行p &#123;  white-space:nowrap;&#125;

强制换行p &#123;  word-break:break-all; /* 英文 */  white-space:pre-wrap; /* 中文 */&#125;

滚动条平滑html &#123;  scroll-behavior: smooth;&#125;

点击我页面会平滑滚动到入门
修改浏览器自动填充 input 样式input[type=&quot;text&quot;]:autofill &#123;  box-shadow: 0 0 0 1000px #000 inset;  -webkit-text-fill-color: white;&#125;

另见: :autofill
修改 input type&#x3D;”color” 样式

input[type=&quot;color&quot;] &#123;  -webkit-appearance: none;  border: none;  width: 32px;  height: 32px;&#125;input[type=&quot;color&quot;]::-webkit-color-swatch-wrapper &#123;  padding: 0;&#125;input[type=&quot;color&quot;]::-webkit-color-swatch &#123;  border: none;&#125;

忽略用作间距的换行符 &lt;br &#x2F;&gt;br + br &#123;  display: none;&#125;

使用 :empty 隐藏空 HTML 元素:empty &#123;  display: none;&#125;

CSS 重置

html &#123;  box-sizing: border-box;&#125;*, *::before, *::after &#123;  box-sizing: border-box;  margin: 0;  padding: 0;&#125;

有助于在不同的浏览器之间强制样式一致性，并为样式元素提供干净的盒子
设置光标样式body &#123;  caret-color: red;&#125;

设置整个页面灰色

html &#123;  -webkit-filter: grayscale(.95);&#125;

上面示例设置了当前卡片灰色
&lt;textarea&gt;自动增加其高度textarea &#123;  form-sizing: normal&#125;

定义容器的长宽比div &#123;  aspect-ratio: 1/1 &#125;

属性 aspect-ratio 可以非常容易的定义一个容器的长宽比
使用 unset 而不是重置所有属性使用 all 速记来指定元素的所有属性。将值设置为 unset 会将元素的属性更改为其初始值：
button &#123;  all: unset;&#125;

注意：IE11 不支持 all 和 unset 速记
超出显示省略号p &#123;  overflow: hidden;/*超出部分隐藏*/  /* 超出部分显示省略号 */  text-overflow:ellipsis;  /* 规定段落中的文本不进行换行 */  white-space: nowrap;  width: 250px;/*需要配合宽度来使用*/&#125;

给正文添加行高您不需要为每个 &lt;p&gt;、&lt;h*&gt; 等添加行高。相反，将其添加到正文：
body &#123;  line-height: 1.5;&#125;

这样文本元素可以很容易地从 body 继承
使用图像作为光标

div &#123;  cursor: url(&#x27;path-to-image.png&#x27;), url(&#x27;path-to-fallback-image.png&#x27;), auto;  /* 表情符号作为光标 */  cursor: url(&quot;data:image/svg+xml;utf8,&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27;  width=&#x27;40&#x27; height=&#x27;48&#x27; viewport=&#x27;0 0 100 100&#x27; style=&#x27;fill:black;font-size:24px;&#x27;&gt;&lt;text y=&#x27;50%&#x27;&gt;🚀&lt;/text&gt;&lt;/svg&gt;&quot;), auto;&#125;


文本溢出显示省略号.overflow-ellipsis &#123;  width: 200px;  white-space: nowrap;  overflow: hidden;  text-overflow: ellipsis;&#125;

一行文本截断显示省略号 (…)
将文本截断到特定的行数.overflow-truncate &#123;  display: -webkit-box;  -webkit-box-orient: vertical;  -webkit-line-clamp: 3;  overflow: hidden;&#125;

多行文本截断到特定的行数，末尾显示省略号 (…)
粘性定位元素.sticky &#123;  position: sticky;  top: 0;&#125;

属性 sticky 能在滚动到顶部的位置固定住元素
使用带有空链接的属性选择器a[href^=&quot;http&quot;]:empty::before &#123;  content: attr(href);&#125;

如果 &lt;a&gt; 标签里面没有内容，将 href 的值作为内容展示
使用 :root 表示灵活类型

响应式布局中的字体大小应该能够根据每个视口进行调整，您可以使用 :root 根据视口高度和宽度计算字体大小
:root &#123;  font-size: calc(1vw + 1vh + .5vmin);&#125;

您可以根据 :root 计算的值使用根 em 单位：
body &#123;  font: 1rem/1.6 sans-serif;&#125;

吸附滚动

&#123;5,12&#125;.container &#123;  height: 250px;  overflow-x: scroll;  display: flex;  scroll-snap-type: x mandatory;  column-gap: 10px;&#125;.child &#123;  flex: 0 0 66%;  width: 250px;  background-color: #663399;  scroll-snap-align: center;&#125;

可用于 轮播图 效果，效果预览
类似 contenteditable 的样式div &#123;  -webkit-user-modify:     read-write-plaintext-only;&#125;


通过样式来控制一个元素 div 是否可以编辑
等宽表格单元格尝试使用 table-layout: fixed 以保持单元格宽度相等：
table &#123;  table-layout: fixed;&#125;

利用属性选择器来选择空链接当 &lt;a&gt; 元素没有文本内容，但有 href 属性的时候，显示它的 href 属性：
a[href^=&quot;http&quot;]:empty::before &#123;  content: attr(href);&#125;

给 “默认” 链接定义样式给 “默认” 链接定义样式：
a[href]:not([class]) &#123;  color: #008000;  text-decoration: underline;&#125;

通常没有 class 属性，以上样式可以甄别它们，而且不会影响其它样式
用 rem 调整全局大小；用 em 调整局部大小

在根元素设置基本字体大小后 (html &#123; font-size: 100%; &#125;), 使用 em 设置文本元素的字体大小:
h2 &#123;   font-size: 2em;&#125;p &#123;  font-size: 1em;&#125;

然后设置模块的字体大小为 rem:
article &#123;  font-size: 1.25rem;&#125;aside .module &#123;  font-size: .9rem;&#125;

现在，每个模块变得独立，更容易、灵活的样式便于维护
隐藏没有静音、自动播放的影片这是一个自定义用户样式表的不错的技巧。避免在加载页面时自动播放。如果没有静音，则不显示视频：
video[autoplay]:not([muted]) &#123;  display: none;&#125;

再次，我们利用了 :not() 的优点
为更好的移动体验，为表单元素设置字体大小当触发 &lt;select&gt; 的下拉列表时，为了避免表单元素在移动浏览器（iOS Safari 和其它）上的缩放，加上font-size：
input[type=&quot;text&quot;],input[type=&quot;number&quot;],select,textarea &#123;  font-size: 16px;&#125;

使用指针事件来控制鼠标事件指针事件允许您指定鼠标如何与其触摸的元素进行交互。要禁用按钮上的默认指针事件，例如：
button:disabled &#123;  opacity: .5;  pointer-events: none;&#125;

就这么简单
子元素选中父元素div:has(img) &#123;  background: black;&#125;

设置包含子元素 img 的 div 元素样式，还可以嵌套：
div:has(h2):has(ul) &#123;  background: black;&#125;

在用作间距的换行符上设置 display: none用户使用额外的换行符
br + br &#123;  display: none;&#125;

给 body 添加行高body &#123;  line-height: 1.5;&#125;

您不需要为每个 &lt;p&gt;、&lt;h*&gt; 等分别添加行高。相反，将其添加到正文
检查本地是否安装了字体

@font-face &#123;  font-family: &quot;Dank Mono&quot;;  src:    /* Full name */    local(&quot;Dank Mono&quot;),    /* Postscript name */    local(&quot;Dank-Mono&quot;),    /* 否则，请下载它！ */    url(&quot;//...a.server/DankMono.woff&quot;);&#125;code &#123;  font-family: &quot;Dank Mono&quot;,        system-ui-monospace;&#125;

您可以在远程获取字体之前检查是否在本地安装了字体，这也是一个很好的性能提示
获取 HTML 元素的属性&lt;a href=&quot;https://example.com&quot;&gt;超链接&lt;/a&gt;

attr HTML 元素的属性名。
a:after &#123;  content: &quot; (&quot; attr(href) &quot;)&quot;;&#125;

为表单元素设置 :focusa:focus, button:focus, input:focus,select:focus, textarea:focus &#123;  box-shadow: none;  outline: #000 dotted 2px;  outline-offset: .05em;&#125;

有视力的键盘用户依靠焦点来确定键盘事件在页面中的位置。使表单元素的焦点比浏览器的默认实现更加突出和一致
垂直居中任何东西

html, body &#123;  height: 100%;  margin: 0;&#125;body &#123;  -webkit-align-items: center;  -ms-flex-align: center;  align-items: center;  display: -webkit-flex;  display: flex;&#125;

…还有 CSS 网格：
body &#123;  display: grid;  height: 100vh;  margin: 0;  place-items: center center;&#125;

图片对齐不变形img &#123;  width: 200px;  height: 200px;  /** 确保图片按原始宽高比例进行缩放 */  object-fit: cover;  object-position: left top;  transition: 1s;&#125;img:hover &#123;  /** 指定图片显示的位置，结合鼠标移动+过渡动画 */  object-position: right bottom;&#125;

多行截断，展示省略号.clamp &#123;  overflow: hidden;  display: -webkit-box;  -webkit-line-clamp: 3;  -webkit-box-orient: vertical;&#125;

html 文本超过 3 行将被截断，显示省略号…
&lt;p class=&quot;clamp&quot;&gt;  展示多行文本，超过 3 行将被截断，显示省略号...&lt;/p&gt;

逗号分隔列表ul &gt; li:not(:last-child)::after &#123;  content: &quot;,&quot;;&#125;

使列表项看起来像一个真实的逗号分隔列表，使用 :not() 伪类，最后一项不会添加逗号
表格中数字使用制表数字.revenue &#123;    font-variant-numeric: tabular-nums;&#125;

表格中一列数字列对其
另见
CSS selectors cheatsheet (frontend30.com)
MDN: Using CSS flexbox
Ultimate flexbox cheatsheet
GRID: A simple visual cheatsheet
CSS Tricks: A Complete Guide to Grid
Browser support
Flex 布局教程：语法篇
CSS 专业技巧

]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端技术</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 备忘录</title>
    <url>/2025/01/08/html/</url>
    <content><![CDATA[HTML 备忘清单此 HTML 快速参考备忘单以可读布局列出了常见的 HTML 和 HTML5 标记。
入门hello.html

&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;HTML5 Boilerplate&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Hello world, hello 备忘清单!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;

或者在 jsfiddle
注释 Comment&lt;!-- 这是代码注释 --&gt;&lt;!--  或者你可以注释掉一个  大量的行。--&gt;

段落 Paragraph&lt;p&gt;我来自快速参考&lt;/p&gt;&lt;p&gt;分享快速参考备忘单。&lt;/p&gt;

请参阅：段落元素
HTML 链接&lt;a href=&quot;https://github.com/jaywcjlove/reference&quot;&gt;  Github&lt;/a&gt;&lt;a href=&quot;mailto:jack@abc.com&quot;&gt;邮箱&lt;/a&gt;&lt;a href=&quot;tel:+123456789&quot;&gt;电话&lt;/a&gt;&lt;a href=&quot;sms:+123456789&amp;body=ha%20ha&quot;&gt;  短信&lt;/a&gt;





:-
:-



href
超链接指向的 URL


rel
链接 URL 的关系


target
链接目标位置：_self&#x2F;_blank&#x2F;_top&#x2F;_parent


请参阅：&lt;a&gt; 属性
Image 标签&lt;img loading=&quot;lazy&quot;  src=&quot;https://xxx.png&quot;  alt=&quot;在此处描述图像&quot;  width=&quot;400&quot; height=&quot;400&quot;&gt;













src (URL&#x2F;路径)
必填，图片位置



alt
描述图像



width
图像宽度



height
图像高度



loading
浏览器应该如何加载


请参阅：图像嵌入元素
文本格式标签&lt;b&gt;粗体文字&lt;/b&gt;&lt;strong&gt;这段文字很重要&lt;/strong&gt;&lt;i&gt;斜体文本&lt;/i&gt;&lt;em&gt;这段文字被强调&lt;/em&gt;&lt;u&gt;下划线文本&lt;/u&gt;&lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;code&gt;源代码&lt;/code&gt;&lt;del&gt;删除的文字&lt;/del&gt;&lt;mark&gt;突出显示的文本 (HTML5)&lt;/mark&gt;&lt;ins&gt;插入的文本&lt;/ins&gt;&lt;sup&gt;使文本上标&lt;/sup&gt;&lt;sub&gt;使文本下标&lt;/sub&gt;&lt;small&gt;使文本变小&lt;/small&gt;&lt;pre&gt;预格式化文本&lt;/pre&gt;&lt;kbd&gt;Ctrl&lt;/kbd&gt;&lt;blockquote&gt;文本块引用&lt;/blockquote&gt;

标题&lt;h1&gt; 这是标题 1 &lt;/h1&gt;&lt;h2&gt; 这是标题 2 &lt;/h2&gt;&lt;h3&gt; 这是标题 3 &lt;/h3&gt;&lt;h4&gt; 这是标题 4 &lt;/h4&gt;&lt;h5&gt; 这是标题 5 &lt;/h5&gt;&lt;h6&gt; 这是标题 6 &lt;/h6&gt;

您的页面上应该只有一个 h1
Section Divisions


:-
:-



&lt;div&gt;&lt;/div&gt;
页面内容的划分或部分


&lt;span&gt;&lt;/span&gt;
其他内容中的文本部分


&lt;p&gt;&lt;/p&gt;
文本段落


&lt;br&gt;
换行


&lt;hr&gt;
水平分割线


这些标签用于将页面划分为多个部分
内部框架

&lt;iframe  id=&quot;inlineFrameExample&quot;  title=&quot;Inline Frame Example&quot;  width=&quot;100%&quot;  height=&quot;200&quot;  frameborder=&quot;0&quot;  src=&quot;https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606&amp;layer=mapnik&quot;&gt;&lt;/iframe&gt;


↓ 预览


请参阅：内联框架元素
HTML 中的 JavaScript&lt;script type=&quot;text/javascript&quot;&gt;  let text = &quot;Hello 快速参考&quot;;  alert(text);&lt;/script&gt;

外部 JavaScript&lt;body&gt;  ...  &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;

HTML 中的 CSS&lt;style type=&quot;text/css&quot;&gt;    h1 &#123;        color: purple;    &#125;&lt;/style&gt;

外部样式表&lt;head&gt;  ...  &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;/&gt;&lt;/head&gt;

HTML5 标签页面&lt;body&gt;  &lt;header&gt;    &lt;nav&gt;...&lt;/nav&gt;  &lt;/header&gt;  &lt;main&gt;    &lt;h1&gt;快速参考&lt;/h1&gt;  &lt;/main&gt;  &lt;footer&gt;    &lt;p&gt;©2023 快速参考&lt;/p&gt;  &lt;/footer&gt;&lt;/body&gt;

标题导航&lt;header&gt;  &lt;nav&gt;    &lt;ul&gt;      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;编辑页面&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Twitter&lt;/a&gt;&lt;/li&gt;      &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Facebook&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;  &lt;/nav&gt;&lt;/header&gt;

HTML5 Tags




:-
:-



article
独立的内容


aside
次要内容


audio
嵌入声音或音频流


bdi
双向隔离元件


canvas
通过JavaScript绘制图形


data
机器可读内容


datalist
一组预定义选项


details
其他信息


dialog
对话框或子窗口


embed
嵌入外部应用程序


figcaption
图形的标题或图例


figure
插图


footer
页脚或最不重要的


header
刊头或重要信息


main
文件的主要内容


mark
突出显示的文本


meter
已知范围内的标量值


nav
导航链接的一部分


output
计算的结果


picture
用于多个图像源的容器


progress
任务的完成进度


rp
提供回退括号


rt
定义字符的发音


ruby
表示ruby注释


section
一系列相关内容中的组


source
媒体元素的资源


summary
元素的摘要


template
定义HTML片段


time
时间或日期


track
媒体元素的字幕信息


video
嵌入视频


wbr
换行机会


HTML5 Video&lt;video controls=&quot;&quot; width=&quot;100%&quot;&gt;    &lt;source src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4&quot; type=&quot;video/mp4&quot;&gt;    很抱歉，您的浏览器不支持嵌入式视频。&lt;/video&gt;


↓ 预览
    
    很抱歉，您的浏览器不支持嵌入式视频。


HTML5 Audio&lt;audio  controls  src=&quot;https://interactive-examples.mdn.mozilla.net/media/cc0-audio/t-rex-roar.mp3&quot;&gt;    您的浏览器不支持音频元素。&lt;/audio&gt;


↓ 预览    您的浏览器不支持音频元素。
HTML5 Ruby&lt;ruby&gt;  汉 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;hàn&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;  字 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zì&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;  拼 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;pīn&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;  音 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;yīn&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt;&lt;/ruby&gt;


↓ 预览


  汉 (hàn)
  字 (zì)
  拼 (pīn)
  音 (yīn)


HTML5 kdi&lt;ul&gt; &lt;li&gt;User &lt;bdi&gt;hrefs&lt;/bdi&gt;: 60 points&lt;/li&gt; &lt;li&gt;User &lt;bdi&gt;jdoe&lt;/bdi&gt;: 80 points&lt;/li&gt; &lt;li&gt;User &lt;bdi&gt;إيان&lt;/bdi&gt;: 90 points&lt;/li&gt;&lt;/ul&gt;

↓ 预览
 User hrefs: 60 points
 User jdoe: 80 points
 User إيان: 90 points


HTML5 progress&lt;progress value=&quot;50&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;


HTML5 mark&lt;p&gt;我爱&lt;mark&gt;备忘清单&lt;/mark&gt;&lt;/p&gt;

我爱备忘清单

HTML 表格Table 示例

&lt;table&gt;  &lt;thead&gt;      &lt;tr&gt;        &lt;td&gt;name&lt;/td&gt;        &lt;td&gt;age&lt;/td&gt;      &lt;/tr&gt;  &lt;/thead&gt;  &lt;tbody&gt;      &lt;tr&gt;        &lt;td&gt;Roberta&lt;/td&gt;        &lt;td&gt;39&lt;/td&gt;      &lt;/tr&gt;      &lt;tr&gt;        &lt;td&gt;Oliver&lt;/td&gt;        &lt;td&gt;25&lt;/td&gt;      &lt;/tr&gt;  &lt;/tbody&gt;&lt;/table&gt;

HTML表格标签




标签
说明



&lt;table&gt;
定义表格


&lt;th&gt;
定义表格中的标题单元格


&lt;tr&gt;
定义表中的行


&lt;td&gt;
定义表格中的单元格


&lt;caption&gt;
定义表格标题


&lt;colgroup&gt;
定义一组列


&lt;col&gt;
定义表中的列


&lt;thead&gt;
对标题内容进行分组


&lt;tbody&gt;
将正文内容分组


&lt;tfoot&gt;
对页脚内容进行分组


&lt;td&gt; 属性


属性
说明



colspan
单元格应跨越的列数


headers
单元格与一个或多个标题单元格相关


rowspan
单元格应跨越的行数


请参阅：td#属性
&lt;th&gt; 属性


属性
说明



colspan
单元格应跨越的列数


headers
单元格与一个或多个标题单元格相关


rowspan
单元格应跨越的行数


abbr
单元格内容的描述


scope
表头元素(在&lt;th&gt;中定义)关联的单元格


请参阅：th#属性
HTML 列表无序列表&lt;ul&gt;  &lt;li&gt;I&#x27;m an item&lt;/li&gt;  &lt;li&gt;I&#x27;m another item&lt;/li&gt;  &lt;li&gt;I&#x27;m another item&lt;/li&gt;&lt;/ul&gt;

请参阅：无序列表元素
有序列表&lt;ol&gt;  &lt;li&gt;I&#x27;m the first item&lt;/li&gt;  &lt;li&gt;I&#x27;m the second item&lt;/li&gt;  &lt;li&gt;I&#x27;m the third item&lt;/li&gt;&lt;/ol&gt;

请参阅：有序列表元素
定义列表&lt;dl&gt;  &lt;dt&gt;A Term&lt;/dt&gt;  &lt;dd&gt;Definition of a term&lt;/dd&gt;  &lt;dt&gt;Another Term&lt;/dt&gt;  &lt;dd&gt;Definition of another term&lt;/dd&gt;&lt;/dl&gt;

请参阅：描述列表元素
HTML 表单Form 标签

&lt;form method=&quot;POST&quot; action=&quot;api/login&quot;&gt;  &lt;label for=&quot;mail&quot;&gt;邮箱: &lt;/label&gt;  &lt;input type=&quot;email&quot; id=&quot;mail&quot; name=&quot;mail&quot;&gt;  &lt;br/&gt;  &lt;label for=&quot;pw&quot;&gt;密码:&lt;/label&gt;  &lt;input type=&quot;password&quot; id=&quot;pw&quot; name=&quot;pw&quot;&gt;  &lt;br/&gt;  &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;  &lt;br/&gt;  &lt;input type=&quot;checkbox&quot; id=&quot;ck&quot; name=&quot;ck&quot;&gt;  &lt;label for=&quot;ck&quot;&gt;记住我&lt;/label&gt;&lt;/form&gt;

↓ 预览
  邮箱: 
  
  
  密码:
  
  
  
  
  
  记住我


HTML &lt;form&gt; 元素用于收集信息并将其发送到外部源。
Form 属性


属性
说明



name
脚本形式的名称


action
表单脚本的URL


method
HTTP方法，POST&#x2F;GET (默认)


enctype
介质类型，请参见enctype


onsubmit
提交表单时运行


onreset
在窗体重置时运行


Label 标签&lt;!-- 嵌套标签 --&gt;&lt;label&gt;Click me &lt;input type=&quot;text&quot; id=&quot;user&quot; name=&quot;name&quot;/&gt;&lt;/label&gt;


&lt;!-- &#x27;for&#x27; 属性 --&gt;&lt;label for=&quot;user&quot;&gt;Click me&lt;/label&gt;&lt;input id=&quot;user&quot; type=&quot;text&quot; name=&quot;name&quot;/&gt;

for在标签中引用输入的id属性
Input 标签&lt;label for=&quot;Name&quot;&gt;Name:&lt;/label&gt;&lt;input type=&quot;text&quot; name=&quot;Name&quot; id=&quot;&quot;&gt;

↓ 预览
  Username:
  


请参阅：HTML输入标记
Textarea 标签&lt;textarea rows=&quot;2&quot; cols=&quot;30&quot; name=&quot;address&quot; id=&quot;address&quot;&gt;&lt;/textarea&gt;


↓ 预览
    


Textarea 是一个多行文本输入控件
Radio Buttons&lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;m&quot;&gt;&lt;label for=&quot;m&quot;&gt;Male&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;gender&quot; id=&quot;f&quot;&gt;&lt;label for=&quot;f&quot;&gt;Female&lt;/label&gt;

↓ 预览
    
    Male
    
    Female


单选按钮用于让用户只选择一个
Checkboxes&lt;input type=&quot;checkbox&quot; name=&quot;s&quot; id=&quot;soc&quot;&gt;&lt;label for=&quot;soc&quot;&gt;Soccer&lt;/label&gt;&lt;input type=&quot;checkbox&quot; name=&quot;s&quot; id=&quot;bas&quot;&gt;&lt;label for=&quot;bas&quot;&gt;Baseball&lt;/label&gt;

↓ 预览
    
    Soccer
    
    Baseball


复选框允许用户选择一个或多个
Select 标签&lt;label for=&quot;city&quot;&gt;City:&lt;/label&gt;&lt;select name=&quot;city&quot; id=&quot;city&quot;&gt;  &lt;option value=&quot;1&quot;&gt;Sydney&lt;/option&gt;  &lt;option value=&quot;2&quot;&gt;Melbourne&lt;/option&gt;  &lt;option value=&quot;3&quot;&gt;Cromwell&lt;/option&gt;&lt;/select&gt;

↓ 预览
  City:
  
      Sydney
      Melbourne
      Cromwell
  


选择框是选项的下拉列表
Fieldset 标签&lt;fieldset&gt;  &lt;legend&gt;Your favorite monster&lt;/legend&gt;  &lt;input type=&quot;radio&quot; id=&quot;kra&quot; name=&quot;m&quot;&gt;  &lt;label for=&quot;kraken&quot;&gt;Kraken&lt;/label&gt;&lt;br/&gt;  &lt;input type=&quot;radio&quot; id=&quot;sas&quot; name=&quot;m&quot;&gt;  &lt;label for=&quot;sas&quot;&gt;Sasquatch&lt;/label&gt;&lt;/fieldset&gt;

↓ 预览

  Your favorite monster
  
  Kraken
  
  Sasquatch



数据列表标签（HTML5）&lt;label for=&quot;b&quot;&gt;Choose a browser: &lt;/label&gt;&lt;input list=&quot;list&quot; id=&quot;b&quot; name=&quot;browser&quot;/&gt;&lt;datalist id=&quot;list&quot;&gt;  &lt;option value=&quot;Chrome&quot;&gt;  &lt;option value=&quot;Firefox&quot;&gt;  &lt;option value=&quot;Internet Explorer&quot;&gt;  &lt;option value=&quot;Opera&quot;&gt;  &lt;option value=&quot;Safari&quot;&gt;  &lt;option value=&quot;Microsoft Edge&quot;&gt;&lt;/datalist&gt;

↓ 预览
  Choose a browser:
  
  
    
    
    
    
    
    
  


提交和重置按钮&lt;form action=&quot;register.php&quot; method=&quot;post&quot;&gt;  &lt;label for=&quot;foo&quot;&gt;Name:&lt;/label&gt;  &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;foo&quot;&gt;  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;  &lt;input type=&quot;reset&quot; value=&quot;重置&quot;&gt;&lt;/form&gt;

↓ 预览
  Name:
  ]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 备忘录</title>
    <url>/2025/01/08/javascript/</url>
    <content><![CDATA[JavaScript 备忘清单包含最重要概念、函数、方法等的 JavaScript 备忘单。 初学者的完整快速参考。
入门介绍JavaScript 是一种轻量级的解释型编程语言。

JSON 备忘清单
JavaScript 中的正则表达式
TypeScript 备忘清单

打印调试// =&gt; Hello world!console.log(&#x27;Hello world!&#x27;);// =&gt; Hello QuickReferenceconsole.warn(&#x27;hello %s&#x27;, &#x27;QuickReference&#x27;);// 将错误消息打印到 stderrconsole.error(new Error(&#x27;Oops!&#x27;));

断点调试function potentiallyBuggyCode() &#123;  debugger;  // 做可能有问题的东西来检查，逐步通过等。&#125;

debugger 语句调用任何可用的调试功能。
数字let amount = 6;let price = 4.99;let home = 1e2;let num = 1_000_000; // 位数过多可以用 _ 分割let m = 0644;   // 八进制数字 420

let 关键字let count; console.log(count); // =&gt; undefinedcount = 10;console.log(count); // =&gt; 10

const 关键字const numberOfColumns = 4;// TypeError: Assignment to constant...numberOfColumns = 8;

变量let x = null;let name = &quot;Tammy&quot;;const found = false;// =&gt; Tammy, false, nullconsole.log(name, found, x);var a;console.log(a); // =&gt; undefined

字符串let single = &#x27;Wheres my bandit hat?&#x27;;let double = &quot;Wheres my bandit hat?&quot;;// =&gt; 21console.log(single.length);

算术运算符5 + 5 = 10     // 加法 Addition10 - 5 = 5     // 减法 Subtraction5 * 10 = 50    // 乘法 Multiplication10 / 5 = 2     // 除法 Division10 % 5 = 0     // 取模 Modulo

注释// 此行将表示注释/* 多行配置部署前必须更改以下配置。*/

赋值运算符let number = 100;// 两个语句都会加 10number = number + 10;number += 10;console.log(number); // =&gt; 120

字符串插值let age = 7;// 字符串拼接&#x27;Tommy is &#x27; + age + &#x27; years old.&#x27;;// 字符串插值`Tommy is $&#123;age&#125; years old.`;

字符串

var abc = &quot;abcdefghijklmnopqrstuvwxyz&quot;;var esc = &#x27;I don\&#x27;t \n know&#x27;;    // \n 换行var len = abc.length;            // 字符串长度abc.indexOf(&quot;lmno&quot;);             // 查找子字符串，如果不包含则 -1abc.lastIndexOf(&quot;lmno&quot;);         // 最后一次出现abc.slice(3, 6);                 // 去掉“def”，负值从后面计算abc.replace(&quot;abc&quot;,&quot;123&quot;);        // 查找和替换，接受正则表达式abc.toUpperCase();               // 转换为大写abc.toLowerCase();               // 转换为小写abc.concat(&quot; &quot;, str2);           // abc + &quot; &quot; + str2abc.charAt(2);                   // 索引处的字符：“c”abc[2];                          // 不安全，abc[2] = &quot;C&quot; 不起作用// 索引处的字符代码：“c”-&gt; 99abc.charCodeAt(2);// 用逗号分割字符串给出一个数组abc.split(&quot;,&quot;);// 分割字符abc.split(&quot;&quot;);// 匹配开头字符串,如果忽略第二个参数，则从索引 0 开始匹配abc.startsWith(&quot;bc&quot;, 1);// 匹配结尾的字符串,如果忽略第二个参数，则默认是原字符串长度abc.endsWith(&quot;wxy&quot;, abc.length - 1);// padEnd 和 padStart 都用于填充长度，默认填充对象是空格&quot;200&quot;.padEnd(5); // &quot;200  &quot;&quot;200&quot;.padEnd(5, &quot;.&quot;); // &quot;200..&quot;// 重复字符&quot;abc&quot;.repeat(2); // &quot;abcabc&quot;// trim、trimEnd 和 trimStart 用于去除首尾空格&quot; ab c &quot;.trim(); // &quot;ab c&quot;// 数字转为十六进制 (16)、八进制 (8) 或二进制 (2)(128).toString(16);

数字

var pi = 3.141;pi.toFixed(0);    // 返回 3             pi.toFixed(2);    // 返回 3.14 - 使用金钱pi.toPrecision(2) // 返回 3.1pi.valueOf();     // 返回号码Number(true);     // 转换为数字// 自 1970 年以来的毫秒数Number(new Date())          // 返回第一个数字：3parseInt(&quot;3 months&quot;);       // 返回 3.5parseFloat(&quot;3.5 days&quot;);     // 最大可能的 JS 数Number.MAX_VALUE            // 最小可能的 JS 编号Number.MIN_VALUE            // -无穷Number.NEGATIVE_INFINITY    // 无穷Number.POSITIVE_INFINITY    

Mathconst pi = Math.PI; // 3.141592653589793Math.round(4.4); // = 4 - 数字四舍五入Math.round(4.5); // = 5Math.pow(2,8);   // = 256 - 2 的 8 次方    Math.sqrt(49);   // = 7 - 平方根Math.abs(-3.14); // = 3.14 - 绝对，正值Math.ceil(3.14); // = 4 - 返回 &gt;= 最小整数// = 3 - 返回 &lt;= 最大整数Math.floor(3.99);       // = 0 - 正弦Math.sin(0);            // OTHERS: tan,atan,asin,acos,余弦值Math.cos(Math.PI);      // = -2 - 最低值Math.min(0, 3, -2, 2);  // = 3 - 最高值Math.max(0, 3, -2, 2);  // = 0 自然对数Math.log(1);            // = 2.7182pow(E,x) 自然对数的底数Math.exp(1);            // 0 到 1 之间的随机数Math.random();          // 随机整数，从 1Math.floor(Math.random() * 5) + 1;  

全局函数

// 像脚本代码一样执行字符串eval();                     // 从数字返回字符串String(23);                 // 从数字返回字符串(23).toString();            // 从字符串返回数字Number(&quot;23&quot;);               // 解码 URI。 结果：“my page.asp”decodeURI(enc);             // 编码 URI。 结果：“my%20page.asp”encodeURI(uri);             // 解码 URI 组件decodeURIComponent(enc);    // 对 URI 组件进行编码encodeURIComponent(uri);    // 是一个有限的合法数isFinite();                 // 是一个非法数字isNaN();                    // 返回字符串的浮点数parseFloat();               // 解析一个字符串并返回一个整数parseInt();                 

JavaScript 条件操作符

true || false;       // true10 &gt; 5 || 10 &gt; 20;   // truefalse || false;      // false10 &gt; 100 || 10 &gt; 20; // false

逻辑运算符 &amp;&amp;true &amp;&amp; true;        // true1 &gt; 2 &amp;&amp; 2 &gt; 1;      // falsetrue &amp;&amp; false;       // false4 === 4 &amp;&amp; 3 &gt; 1;    // true

比较运算符1 &gt; 3                 // false3 &gt; 1                 // true250 &gt;= 250            // true1 === 1               // true1 === 2               // false1 === &#x27;1&#x27;             // false

逻辑运算符let lateToWork = true;let oppositeValue = !lateToWork;// =&gt; falseconsole.log(oppositeValue); 

空值合并运算符 ??null ?? &#x27;I win&#x27;;         //  &#x27;I win&#x27;undefined ?? &#x27;Me too&#x27;;   //  &#x27;Me too&#x27;false ?? &#x27;I lose&#x27;        //  false0 ?? &#x27;I lose again&#x27;      //  0&#x27;&#x27; ?? &#x27;Damn it&#x27;          //  &#x27;&#x27;

if Statement (if 语句)const isMailSent = true;if (isMailSent) &#123;  console.log(&#x27;Mail sent to recipient&#x27;);&#125;

Ternary Operator (三元运算符)var age = 1;// =&gt; truevar status = (age &gt;= 18) ? true : false;

else ifconst size = 10;if (size &gt; 20) &#123;  console.log(&#x27;Medium&#x27;);&#125; else if (size &gt; 4) &#123;  console.log(&#x27;Small&#x27;);&#125; else &#123;  console.log(&#x27;Tiny&#x27;);&#125;// Print: Small

&#x3D;&#x3D; vs &#x3D;&#x3D;&#x3D;0 == false     // true0 === false    // false, 不同类型1 == &quot;1&quot;       // true,  自动类型转换1 === &quot;1&quot;      // false, 不同类型null == undefined  // truenull === undefined // false&#x27;0&#x27; == false       // true&#x27;0&#x27; === false      // false

== 只检查值，=== 检查值和类型。
switch 语句const food = &#x27;salad&#x27;;switch (food) &#123;  case &#x27;oyster&#x27;: console.log(&#x27;海的味道&#x27;);    break;  case &#x27;pizza&#x27;: console.log(&#x27;美味的馅饼&#x27;);    break;  default:    console.log(&#x27;请您用餐&#x27;);&#125;

switch 多 case - 单一操作const food = &#x27;salad&#x27;;switch (food) &#123;  case &#x27;oyster&#x27;:  case &#x27;pizza&#x27;:    console.log(&#x27;美味的馅饼&#x27;);    break;  default:    console.log(&#x27;请您用餐&#x27;);&#125;

JavaScript Functions 函数函数// 定义函数：function sum(num1, num2) &#123;  return num1 + num2;&#125;// 调用函数：sum(3, 6); // 9

匿名函数// 命名函数function rocketToMars() &#123;  return &#x27;BOOM!&#x27;;&#125;// 匿名函数const rocketToMars = function() &#123;  return &#x27;BOOM!&#x27;;&#125;

箭头函数 (ES6)

有两个参数const sum = (param1, param2) =&gt; &#123;   return param1 + param2; &#125;; console.log(sum(2,5)); // =&gt; 7 

没有参数const printHello = () =&gt; &#123;   console.log(&#x27;hello&#x27;); &#125;; printHello(); // =&gt; hello

只有一个参数const checkWeight = weight =&gt; &#123;   console.log(`Weight : $&#123;weight&#125;`); &#125;; checkWeight(25); // =&gt; Weight : 25 

简洁箭头函数const multiply = (a, b) =&gt; a * b; // =&gt; 60 console.log(multiply(2, 30)); 

从 ES2015 开始提供箭头函数
返回关键字// 有 returnfunction sum(num1, num2) &#123;  return num1 + num2;&#125;// 该函数不输出总和function sum(num1, num2) &#123;  num1 + num2;&#125;

调用函数// 定义函数function sum(num1, num2) &#123;  return num1 + num2;&#125;// 调用函数sum(2, 4); // 6

立即执行函数//命名函数并立即执行一次(function sum(num1, num2) &#123;  return num1 + num2;&#125;)(2,4)//6

函数表达式const dog = function() &#123;  return &#x27;Woof!&#x27;;&#125;

函数参数// 参数是 namefunction sayHello(name) &#123;  return `Hello, $&#123;name&#125;!`;&#125;

函数声明function add(num1, num2) &#123;  return num1 + num2;&#125;

JavaScript 范围范围

function myFunction() &#123;  var pizzaName = &quot;Margarita&quot;;  // 这里的代码可以使用 PizzaName  &#125;// ❌ PizzaName 不能在这里使用

&#123; &#125; 块内声明的变量
&#123;  let x = 2;&#125;// ❌ x 不能在这里使用&#123;  var x = 2;&#125;// ✅ x 能在这里使用

var x = 2;       // Global scopelet x = 2;       // Global scopeconst x = 2;       // Global scope

ES6 引入了两个重要的新 JavaScript 关键字：let 和 const。这两个关键字在 JavaScript 中提供了块作用域。
块作用域变量const isLoggedIn = true;if (isLoggedIn == true) &#123;  const statusMessage = &#x27;Logged in.&#x27;;&#125;// Uncaught ReferenceError...// 未捕获的引用错误...console.log(statusMessage);

全局变量// 全局声明的变量const color = &#x27;blue&#x27;;function printColor() &#123;  console.log(color);&#125;printColor(); // =&gt; blue

let vs varfor (let i = 0; i &lt; 3; i++) &#123;  // 这是“let”的最大范围  // i 可以访问 ✔️&#125;// i 不能访问 ❌


for (var i = 0; i &lt; 3; i++) &#123;  // i 可以访问 ✔️&#125;// i 可以访问 ✔️

var 的范围是最近的函数块，而 let 的范围是最近的封闭块。
带闭包的循环// 打印三次，不是我们的意思。for (var i = 0; i &lt; 3; i++) &#123;  setTimeout(_ =&gt; console.log(i), 10);&#125;


// 按预期打印 0、1 和 2。for (let j = 0; j &lt; 3; j++) &#123;   setTimeout(_ =&gt; console.log(j), 10);&#125;

变量使用 let 有自己的副本，变量有使用 var 的共享副本。
JavaScript Arrays方法




:-
:-



Array.from()
类似数组对象创建一个新的 #


Array.isArray()
值是否是一个 Array #


Array.of()
创建一个新数组示例 #


.at()
返回值索引对应的元素 #


.concat()
合并两个或多个数组 #


.copyWithin()
浅复制替换某个位置 #


.entries()
新的 Array Iterator 对象 #


.every()
是否能通过回调函数的测试 #


.fill()
固定值填充一个数组中 #


.filter()
返回过滤后的数组 #


.find()
第一个元素的值 #


.findIndex()
第一个元素的索引 #


.findLast()
最后一个元素的值 #


.findLastIndex()
最后一个元素的索引 #


.flat()
扁平化嵌套数组 #


.flatMap()
与 flat 相同 #


.forEach()
升序循环执行 #


.includes()
是否包含一个指定的值 #


.indexOf()
找到给定元素的第一个索引 #


.join()
数组链接成一个字符串 #


.keys()
每个索引键 #


.lastIndexOf()
给定元素的最后一个索引 #


.map()
循环返回一个新数组 #


.pop()
删除最后一个元素 #


.push()
元素添加到数组的末尾 #


.reduce()
循环函数传递当前和上一个值 #


.reduceRight()
类似 reduce 从右往左循环 #


.reverse()
数组元素的位置颠倒 #


.shift()
删除第一个元素 #


.slice()
提取元素 #


.some()
至少有一个通过测试函数 #


.sort()
元素进行排序 #


.splice()
删除或替换或添加元素 #


.toLocaleString()
字符串表示数组中的元素 #


.toString()
返回字符串 #


.unshift()
元素添加到数组的开头 #


.values()
返回新的 ArrayIterator 对象 #


数组const fruits = [&quot;apple&quot;, &quot;dew&quot;, &quot;banana&quot;];// 不同的数据类型const data = [1, &#x27;chicken&#x27;, false];

属性 .lengthconst numbers = [1, 2, 3, 4];numbers.length // 4

索引// 访问数组元素const myArray = [100, 200, 300];console.log(myArray[0]); // 100console.log(myArray[1]); // 200

可变图表



添加
删除
开始
结束



push
✅


✅


pop

✅

✅


unshift
✅

✅



shift

✅
✅





方法 .push()// 添加单个元素：const cart = [&#x27;apple&#x27;, &#x27;orange&#x27;];cart.push(&#x27;pear&#x27;); // 添加多个元素：const numbers = [1, 2];numbers.push(3, 4, 5);

将项目添加到末尾并返回新的数组长度。
方法 .pop()const fruits = [&quot;apple&quot;, &quot;dew&quot;, &quot;banana&quot;];const fruit = fruits.pop(); // &#x27;banana&#x27;console.log(fruits); // [&quot;apple&quot;, &quot;dew&quot;]

从末尾删除一个项目并返回已删除的项目。
方法 .shift()const array1 = [1, 2, 3];const firstElement = array1.shift();console.log(array1); // 输出: Array [2, 3]console.log(firstElement); // 输出: 1

从头删除一个项目并返回已删除的项目。
方法 .some()const array = [1, 2, 3, 4, 5];// 检查元素是否为偶数const even = (element) =&gt; element % 2 === 0;console.log(array.some(even));// 预期输出: true

方法 .concat()const numbers = [3, 2, 1]const newFirstNumber = 4    // =&gt; [ 4, 3, 2, 1 ][newFirstNumber].concat(numbers)    // =&gt; [ 3, 2, 1, 4 ]numbers.concat(newFirstNumber)

如果你想避免改变你的原始数组，你可以使用 concat。
方法 .splice()const months = [&#x27;Jan&#x27;, &#x27;March&#x27;];months.splice(1, 0, &#x27;Feb&#x27;);// 在索引 1 处插入console.log(months);// 预期输出: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;]months.splice(2, 1, &#x27;May&#x27;);// 替换索引 2 处的 1 个元素console.log(months);// 预期输出: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;May&quot;]

方法 .unshift()let cats = [&#x27;Bob&#x27;];// =&gt; [&#x27;Willy&#x27;, &#x27;Bob&#x27;]cats.unshift(&#x27;Willy&#x27;);// =&gt; [&#x27;Puff&#x27;, &#x27;George&#x27;, &#x27;Willy&#x27;, &#x27;Bob&#x27;]cats.unshift(&#x27;Puff&#x27;, &#x27;George&#x27;);

将项目添加到开头并返回新的数组长度。
方法 .filter()const words = [&#x27;js&#x27;, &#x27;java&#x27;, &#x27;golang&#x27;];const result = words.filter(word =&gt; &#123;  return  word.length &gt; 3&#125;);console.log(result);// 预期输出: Array [&quot;java&quot;, &quot;golang&quot;]

JavaScript 循环While 循环while (condition) &#123;  // 要执行的代码块&#125;let i = 0;while (i &lt; 5) &#123;          console.log(i);  i++;&#125;

反向循环const fruits = [&quot;apple&quot;, &quot;dew&quot;, &quot;berry&quot;];for (let i = fruits.length - 1; i &gt;= 0; i--) &#123;  console.log(`$&#123;i&#125;. $&#123;fruits[i]&#125;`);&#125;// =&gt; 2. berry// =&gt; 1. dew// =&gt; 0. apple

Do…While 语句x = 0i = 0do &#123;  x = x + i;  console.log(x)  i++;&#125; while (i &lt; 5);// =&gt; 0 1 3 6 10

For 循环for (let i = 0; i &lt; 4; i += 1) &#123;  console.log(i);&#125;;// =&gt; 0, 1, 2, 3

遍历数组for (let i = 0; i &lt; array.length; i++)&#123;  console.log(array[i]);&#125;// =&gt; 数组中的每一项

Breakfor (let i = 0; i &lt; 99; i += 1) &#123;  if (i &gt; 5) break;  console.log(i)&#125;// =&gt; 0 1 2 3 4 5

Continuefor (i = 0; i &lt; 10; i++) &#123;  if (i === 3) &#123;    continue;  &#125;  text += &quot;The number is &quot; + i + &quot;&lt;br&gt;&quot;;&#125;

嵌套循环for (let i = 0; i &lt; 2; i += 1) &#123;  for (let j = 0; j &lt; 3; j += 1) &#123;    console.log(`$&#123;i&#125;-$&#123;j&#125;`);  &#125;&#125;

for…in 循环const fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;];for (let index in fruits) &#123;  console.log(index);&#125;// =&gt; 0// =&gt; 1// =&gt; 2

label 语句

var num = 0;outPoint:for(var i = 0; i &lt; 10; i++) &#123;  for(var j = 0; j &lt; 10; j++) &#123;    if(i == 5 &amp;&amp; j == 5) &#123;      continue outPoint;    &#125;    num++;  &#125;&#125;alert(num);  // 95

从 alert(num) 的值可以看出，continue outPoint; 语句的作用是跳出当前循环，并跳转到 outPoint（标签）下的 for 循环继续执行。
for…of 循环const fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;];for (let fruit of fruits) &#123;  console.log(fruit);&#125;// =&gt; apple// =&gt; orange// =&gt; banana

for await…of

async function* asyncGenerator() &#123;  var i = 0;  while (i &lt; 3) &#123;    yield i++;  &#125;&#125;(async function() &#123;  for await (num of asyncGenerator()) &#123;    console.log(num);  &#125;&#125;)();// 0// 1// 2

可选的 for 表达式var i = 0;for (;;) &#123;  if (i &gt; 3) break;  console.log(i);  i++;&#125;

JavaScript 迭代器(Iterators)

分配给变量的函数let plusFive = (number) =&gt; &#123;  return number + 5;  &#125;;// f 被赋值为 plusFivelet f = plusFive;plusFive(3); // 8// 由于 f 具有函数值，因此可以调用它。f(9); // 14

回调函数const isEven = (n) =&gt; &#123;  return n % 2 == 0;&#125;let printMsg = (evenFunc, num) =&gt; &#123;  const isNumEven = evenFunc(num);  console.log(`$&#123;num&#125; is an even number: $&#123;isNumEven&#125;.`)&#125;// Pass in isEven as the callback functionprintMsg(isEven, 4); // =&gt; The number 4 is an even number: True.

数组方法 .reduce()const numbers = [1, 2, 3, 4];const sum = numbers.reduce((accumulator, curVal) =&gt; &#123;    return accumulator + curVal;&#125;);console.log(sum); // 10

数组方法 .map()const members = [&quot;Taylor&quot;, &quot;Donald&quot;, &quot;Don&quot;, &quot;Natasha&quot;, &quot;Bobby&quot;];const announcements = members.map((member) =&gt; &#123;  return member + &quot; joined the contest.&quot;;&#125;);console.log(announcements);

数组方法 .forEach()const numbers = [28, 77, 45, 99, 27];numbers.forEach(number =&gt; &#123;    console.log(number);&#125;); 

数组方法 .filter()const randomNumbers = [4, 11, 42, 14, 39];const filteredArray = randomNumbers.filter(n =&gt; &#123;    return n &gt; 5;&#125;);

JavaScript 对象(Objects)

访问属性const apple = &#123;   color: &#x27;Green&#x27;,  price: &#123; bulk: &#x27;$3/kg&#x27;, smallQty: &#x27;$4/kg&#x27; &#125;&#125;;console.log(apple.color);      // =&gt; Greenconsole.log(apple.price.bulk); // =&gt; $3/kg

命名属性// 无效键名示例const trainSchedule = &#123;  // 由于单词之间的空格而无效。  platform num: 10,   // 表达式不能是键。  40 - 10 + 2: 30,  // 除非用引号括起来，否则 + 号无效。  +compartment: &#x27;C&#x27;&#125;

不存在的属性const classElection = &#123;  date: &#x27;January 12&#x27;&#125;;console.log(classElection.place); // undefined

可变的

const student = &#123;  name: &#x27;Sheldon&#x27;,  score: 100,  grade: &#x27;A&#x27;,&#125;console.log(student)// &#123; name: &#x27;Sheldon&#x27;, score: 100, grade: &#x27;A&#x27; &#125;delete student.scorestudent.grade = &#x27;F&#x27;console.log(student)// &#123; name: &#x27;Sheldon&#x27;, grade: &#x27;F&#x27; &#125;student = &#123;&#125;// TypeError: TypeError：分配给常量变量。

赋值简写语法const person = &#123;  name: &#x27;Tom&#x27;,  age: &#x27;22&#x27;,&#125;;const &#123;name, age&#125; = person;console.log(name); // &#x27;Tom&#x27;console.log(age);  // &#x27;22&#x27;

删除运算符const person = &#123;  firstName: &quot;Matilda&quot;,  hobby: &quot;knitting&quot;,  goal: &quot;learning JavaScript&quot;&#125;;delete person.hobby; // 或 delete person[&#x27;hobby&#x27;];console.log(person);/*&#123;  firstName: &quot;Matilda&quot;  goal: &quot;learning JavaScript&quot;&#125; */

对象作为参数const origNum = 8;const origObj = &#123;color: &#x27;blue&#x27;&#125;;const changeItUp = (num, obj) =&gt; &#123;  num = 7;  obj.color = &#x27;red&#x27;;&#125;;changeItUp(origNum, origObj);// 将输出 8，因为整数是按值传递的。console.log(origNum);// 由于传递了对象，将输出“red”// 通过引用，因此是可变的。console.log(origObj.color);

工厂函数

// 一个接受 &#x27;name&#x27;，&#x27;age&#x27; 和 &#x27;breed&#x27; 的工厂函数，//  参数返回一个自定义的 dog 对象。const dogFactory = (name, age, breed) =&gt; &#123;  return &#123;    name: name,    age: age,    breed: breed,    bark() &#123;      console.log(&#x27;Woof!&#x27;);      &#125;  &#125;;&#125;;

速记对象创建const activity = &#x27;Surfing&#x27;;const beach = &#123; activity &#125;;console.log(beach); // &#123; activity: &#x27;Surfing&#x27; &#125;

this 关键字const cat = &#123;  name: &#x27;Pipey&#x27;,  age: 8,  whatName() &#123;    return this.name    &#125;&#125;;console.log(cat.whatName()); // =&gt; Pipey

方法const engine = &#123;  // 方法简写，有一个参数  start(adverb) &#123;    console.log(`The engine starts up $&#123;adverb&#125;...`);  &#125;,    // 不带参数的匿名箭头函数表达式  sputter: () =&gt; &#123;    console.log(&#x27;The engine sputters...&#x27;);  &#125;,&#125;;engine.start(&#x27;noisily&#x27;);engine.sputter();

Getters 和 settersconst myCat = &#123;  _name: &#x27;Dottie&#x27;,  get name() &#123;    return this._name;    &#125;,  set name(newName) &#123;    this._name = newName;    &#125;&#125;;// 引用调用 getterconsole.log(myCat.name);// 赋值调用 settermyCat.name = &#x27;Yankee&#x27;;

ProxyProxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。
// 用于拦截对象的读取属性操作。const handler = &#123;    get: function(obj, prop) &#123;        return prop in obj ? obj[prop] : 37;    &#125;&#125;;const p = new Proxy(&#123;&#125;, handler);p.a = 1;p.b = undefined;console.log(p.a, p.b);      // 1, undefinedconsole.log(&#x27;c&#x27; in p, p.c); // false, 37

语法const p = new Proxy(target, handler)


target 要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。
handler 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。

方法


:-
:-



Proxy.revocable()
创建一个可撤销的Proxy对象 #


handler 对象的方法


:-
:-



handler.getPrototypeOf()
Object.getPrototypeOf 方法的捕捉器 #


handler.setPrototypeOf()
Object.setPrototypeOf 方法的捕捉器 #


handler.isExtensible()
Object.isExtensible 方法的捕捉器 #


handler.preventExtensions()
Object.preventExtensions 方法的捕捉器 #


handler.getOwnPropertyDescriptor()
Object.getOwnPropertyDescriptor 方法的捕捉器 #


handler.defineProperty()
Object.defineProperty 方法的捕捉器 #


handler.has()
in 操作符的捕捉器 #


handler.get()
属性读取操作的捕捉器 #


handler.set()
属性设置操作的捕捉器 #


handler.deleteProperty()
delete 操作符的捕捉器 #


handler.ownKeys()
Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器 #


handler.apply()
函数调用操作的捕捉器 #


handler.construct()
new 操作符的捕捉器 #




ReflectReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与proxy handlers (en-US)的方法相同。Reflect不是一个函数对象，因此它是不可构造的。
// 检测一个对象是否存在特定属性const duck = &#123;  name: &#x27;Maurice&#x27;,  color: &#x27;white&#x27;,  greeting: function() &#123;    console.log(`Quaaaack! My name is $&#123;this.name&#125;`);  &#125;&#125;Reflect.has(duck, &#x27;color&#x27;);// trueReflect.has(duck, &#x27;haircut&#x27;);// false

静态方法


:-
:-



Reflect.apply(target, thisArgument, argumentsList)
对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似 #


Reflect.construct(target, argumentsList[, newTarget])
对构造函数进行 new 操作，相当于执行 new target(…args) #


Reflect.defineProperty(target, propertyKey, attributes)
和 Object.defineProperty() 类似。如果设置成功就会返回 true #


Reflect.deleteProperty(target, propertyKey)
作为函数的delete操作符，相当于执行 delete target[name] #


Reflect.get(target, propertyKey[, receiver])
获取对象身上某个属性的值，类似于 target[name] #


Reflect.getOwnPropertyDescriptor(target, propertyKey)
类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符，否则返回 undefined #


Reflect.getPrototypeOf(target)
类似于 Object.getPrototypeOf() #


Reflect.has(target, propertyKey)
判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同 #


Reflect.isExtensible(target)
类似于 Object.isExtensible() #


Reflect.ownKeys(target)
返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable 影响) #


Reflect.preventExtensions(target)
类似于 Object.preventExtensions()。返回一个Boolean #


Reflect.set(target, propertyKey, value[, receiver])
将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true #


Reflect.setPrototypeOf(target, prototype)
设置对象原型的函数。返回一个 Boolean，如果更新成功，则返回 true #




JavaScript this 绑定隐式绑定function foo() &#123;  console.log(this)&#125;let obj1 = &#123;  name: &quot;obj1&quot;,  foo: foo&#125;let obj2 = &#123;  name: &quot;obj2&quot;,  obj1: obj1&#125;obj2.obj1.foo() // [Object obj1]

隐式丢失let a = obj2.obj1.foo()a() // Window


指定隐式绑定：必须在调用的对象内部有一个对函数的引用（比如一个属性）
将以上调用赋值给一个变量，结果最终会是 Window
在 a 被调用的位置没有进行过任何显示绑定，最终全局对象 window 会调用它（Window.a）



显示绑定function getName(a1, a2) &#123;  console.log(&quot;此人&quot; + this.name, &quot;岁数&quot; + (a1 + a2))&#125;let person = &#123;  name: &quot;zhangsan&quot;&#125;

callcall 第一个参数接受 this 作用域，剩余参数传递给其调用的函数
getName.call(person, 18, 12)

applyapply 第一个参数与 call 相同，第二个参数是其调用函数的参数数组
getName.apply(person, [18, 12])

bindbind 函数会返回一个新函数
getName.bind(person,18,12)()//或者可以这样getName.bind(person)(18, 12)//或者这样getName.bind(person).bind(null, 18)(12)

内置函数中的 this数组中的一些方法，类似于 map、forEach 等，可以自己设置绑定 this
const obj = &#123;  name: &quot;zhangsan&quot;&#125;const array = [1, 2, 3];array.map(function(value)&#123;  console.log(this.name)&#125;, obj)// zhangsan x3 

其中一些全局对象，如 setTimeout 等，它们和未显示绑定 this 的部分数组方法一样，都会指向全局对象（Window）
setTimeout(function()&#123;   console.log(this)&#125;, 1000) // Window

JavaScript Classes静态方法&#x2F;字段

class Dog &#123;  constructor(name) &#123;    this._name = name;    &#125;    introduce() &#123;     console.log(&#x27;This is &#x27; + this._name + &#x27; !&#x27;);    &#125;    // 静态方法  static bark() &#123;    console.log(&#x27;Woof!&#x27;);    &#125;  static &#123;    console.log(&#x27;类静态初始化块调用&#x27;);  &#125;&#125;const myDog = new Dog(&#x27;Buster&#x27;);myDog.introduce();// 调用静态方法Dog.bark();

公有静态字段class ClassStaticField &#123;  static staticField = &#x27;static field&#x27;&#125;console.log(ClassStaticField.staticField)// 预期输出值：&quot;static field&quot;​ 

Classclass Song &#123;  constructor() &#123;    this.title;    this.author;  &#125;    play() &#123;    console.log(&#x27;Song playing!&#x27;);  &#125;&#125;const mySong = new Song();mySong.play();

extends// Parent classclass Media &#123;  constructor(info) &#123;    this.publishDate = info.publishDate;    this.name = info.name;  &#125;&#125;// Child classclass Song extends Media &#123;  constructor(songData) &#123;    super(songData);    this.artist = songData.artist;  &#125;&#125;const mySong = new Song(&#123;   artist: &#x27;Queen&#x27;,   name: &#x27;Bohemian Rhapsody&#x27;,   publishDate: 1975&#125;);

Class Constructorclass Song &#123;  constructor(title, artist) &#123;    this.title = title;    this.artist = artist;  &#125;&#125;const mySong = new Song(&#x27;Bohemian Rhapsody&#x27;, &#x27;Queen&#x27;);console.log(mySong.title);

Class Methodsclass Song &#123;  play() &#123;    console.log(&#x27;Playing!&#x27;);  &#125;    stop() &#123;    console.log(&#x27;Stopping!&#x27;);  &#125;&#125;

JavaScript Modules

Export &#x2F; Import// myMath.js// 默认导出 Default exportexport default function add(x,y)&#123;  return x + y&#125;// 正常导出 Normal exportexport function subtract(x,y)&#123;  return x - y&#125;// 多重导出 Multiple exportsfunction multiply(x,y)&#123;  return x * y&#125;function duplicate(x)&#123;  return x * 2&#125;export &#123;  multiply, duplicate&#125;

import 加载模块// main.jsimport add, &#123; subtract, multiply, duplicate &#125; from &#x27;./myMath.js&#x27;;console.log(add(6, 2));      // 8 console.log(subtract(6, 2))  // 4console.log(multiply(6, 2)); // 12console.log(duplicate(5))    // 10// index.html&lt;script type=&quot;module&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;

Export Module// myMath.jsfunction add(x,y)&#123;  return x + y&#125;function subtract(x,y)&#123;  return x - y&#125;function multiply(x,y)&#123;  return x * y&#125;function duplicate(x)&#123;  return x * 2&#125;// node.js 中的多个导出module.exports = &#123;  add,  subtract,  multiply,  duplicate&#125;

require 加载模块// main.jsconst myMath = require(&#x27;./myMath.js&#x27;)console.log(myMath.add(6, 2));      // 8 console.log(myMath.subtract(6, 2))  // 4console.log(myMath.multiply(6, 2)); // 12console.log(myMath.duplicate(5))    // 10

JavaScript PromisesPromise

创建 promises
new Promise((resolve, reject) =&gt; &#123;  if (ok) &#123;    resolve(result)  &#125; else &#123;    reject(error)  &#125;&#125;)

使用 promisespromise  .then((result) =&gt; &#123; ··· &#125;)  .catch((error) =&gt; &#123; ··· &#125;)

Promise 方法Promise.all(···)Promise.race(···)Promise.reject(···)Promise.resolve(···)

执行器函数const executorFn = (resolve, reject) =&gt; &#123;  resolve(&#x27;Resolved!&#x27;);&#125;;const promise = new Promise(executorFn);

setTimeout()const loginAlert = () =&gt; &#123;  console.log(&#x27;Login&#x27;);&#125;;setTimeout(loginAlert, 6000);

Promise 状态const promise = new Promise((resolve, reject) =&gt; &#123;  const res = true;  // 一个异步操作。  if (res) &#123;    resolve(&#x27;Resolved!&#x27;);  &#125;  else &#123;    reject(Error(&#x27;Error&#x27;));  &#125;&#125;);promise.then(  (res) =&gt; console.log(res),  (err) =&gt; console.error(err));

.then() 方法const promise = new Promise((resolve, reject) =&gt; &#123;      setTimeout(() =&gt; &#123;    resolve(&#x27;Result&#x27;);  &#125;, 200);&#125;);promise.then((res) =&gt; &#123;  console.log(res);&#125;, (err) =&gt; &#123;  console.error(err);&#125;);

.catch() 方法const promise = new Promise(  (resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;    reject(Error(&#x27;Promise 无条件拒绝。&#x27;));  &#125;, 1000);&#125;);promise.then((res) =&gt; &#123;  console.log(value);&#125;);promise.catch((err) =&gt; &#123;  console.error(err);&#125;);

Promise.all()

const promise1 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(3);  &#125;, 300);&#125;);const promise2 = new Promise((resolve, reject) =&gt; &#123;  setTimeout(() =&gt; &#123;    resolve(2);  &#125;, 200);&#125;);Promise.all([promise1, promise2]).then((res) =&gt; &#123;  console.log(res[0]);  console.log(res[1]);&#125;);

链接多个 .then()const promise = new Promise(  resolve =&gt;     setTimeout(() =&gt; resolve(&#x27;dAlan&#x27;),100));promise.then(res =&gt; &#123;  return res === &#x27;Alan&#x27;     ? Promise.resolve(&#x27;Hey Alan!&#x27;)    : Promise.reject(&#x27;Who are you?&#x27;)&#125;).then((res) =&gt; &#123;  console.log(res)&#125;, (err) =&gt; &#123;  console.error(err)&#125;);

避免嵌套的 Promise 和 .then()

const promise = new Promise((resolve, reject) =&gt; &#123;    setTimeout(() =&gt; &#123;    resolve(&#x27;*&#x27;);  &#125;, 1000);&#125;);const twoStars = (star) =&gt; &#123;    return (star + star);&#125;;const oneDot = (star) =&gt; &#123;    return (star + &#x27;.&#x27;);&#125;;const print = (val) =&gt; &#123;  console.log(val);&#125;;// 将它们链接在一起promise.then(twoStars).then(oneDot).then(print);

JavaScript Async-Await

异步

function helloWorld() &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(&#x27;Hello World!&#x27;);    &#125;, 2000);  &#125;);&#125;// 异步函数表达式const msg = async function() &#123;  const msg = await helloWorld();  console.log(&#x27;Message:&#x27;, msg);&#125;// 异步箭头函数const msg1 = async () =&gt; &#123;  const msg = await helloWorld();  console.log(&#x27;Message:&#x27;, msg);&#125;msg(); // Message: Hello World! &lt;-- 2 秒后msg1(); // Message: Hello World! &lt;-- 2 秒后

解决 Promiseslet pro1 = Promise.resolve(5);let pro2 = 44;let pro3 = new Promise(function(resolve, reject) &#123;  setTimeout(resolve, 100, &#x27;foo&#x27;);&#125;);Promise.all([pro1, pro2, pro3]).then(function(values) &#123;  console.log(values);&#125;);// expected =&gt; Array [5, 44, &quot;foo&quot;]

异步等待 Promisesfunction helloWorld() &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(&#x27;Hello World!&#x27;);    &#125;, 2000);  &#125;);&#125;async function msg() &#123;  const msg = await helloWorld();  console.log(&#x27;Message:&#x27;, msg);&#125;msg(); // Message: Hello World! &lt;-- 2 秒后

错误处理// 数据不完整let json = &#x27;&#123; &quot;age&quot;: 30 &#125;&#x27;;try &#123;  let user = JSON.parse(json); // &lt;-- 没有错误  console.log( user.name );    // no name!&#125; catch (e) &#123;  console.error( &quot;Invalid JSON data!&quot; );&#125;

异步等待运算符function helloWorld() &#123;  return new Promise(resolve =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve(&#x27;Hello World!&#x27;);    &#125;, 2000);  &#125;);&#125;async function msg() &#123;  const msg = await helloWorld();  console.log(&#x27;Message:&#x27;, msg);&#125;msg(); // Message: Hello World! &lt;-- 2 秒后

JavaScript 请求JSONconst jsonObj = &#123;  &quot;name&quot;: &quot;Rick&quot;,  &quot;id&quot;: &quot;11A&quot;,  &quot;level&quot;: 4  &#125;;

另见：JSON 备忘单
XMLHttpRequestconst xhr = new XMLHttpRequest();xhr.open(&#x27;GET&#x27;, &#x27;mysite.com/getjson&#x27;);

XMLHttpRequest 是一个浏览器级别的 API，它使客户端能够通过 JavaScript 编写数据传输脚本，而不是 JavaScript 语言的一部分。
GETconst req = new XMLHttpRequest();req.responseType = &#x27;json&#x27;;req.open(&#x27;GET&#x27;, &#x27;/getdata?id=65&#x27;);req.onload = () =&gt; &#123;  console.log(xhr.response);&#125;;req.send();

POST

const data = &#123; weight: &#x27;1.5 KG&#x27; &#125;;const xhr = new XMLHttpRequest();// 初始化一个请求。xhr.open(&#x27;POST&#x27;, &#x27;/inventory/add&#x27;);// 一个用于定义响应类型的枚举值xhr.responseType = &#x27;json&#x27;;// 发送请求以及数据。xhr.send(JSON.stringify(data));// 请求成功完成时触发。xhr.onload = () =&gt; &#123;  console.log(xhr.response);&#125;// 当 request 遭遇错误时触发。xhr.onerror = () =&gt; &#123;  console.log(xhr.response);&#125;

fetch api

fetch(url, &#123;    method: &#x27;POST&#x27;,    headers: &#123;      &#x27;Content-type&#x27;: &#x27;application/json&#x27;,      &#x27;apikey&#x27;: apiKey    &#125;,    body: data&#125;).then(response =&gt; &#123;  if (response.ok) &#123;    return response.json();  &#125;  throw new Error(&#x27;Request failed!&#x27;);&#125;, networkError =&gt; &#123;  console.log(networkError.message)&#125;)

JSON 格式fetch(&#x27;url-that-returns-JSON&#x27;)  .then(response =&gt; response.json())  .then(jsonResponse =&gt; &#123;    console.log(jsonResponse);  &#125;);

promise url 参数获取 APIfetch(&#x27;url&#x27;)  .then(response  =&gt; &#123;    console.log(response);  &#125;, rejection =&gt; &#123;    console.error(rejection.message);  &#125;);

Fetch API 函数fetch(&#x27;https://api-xxx.com/endpoint&#x27;, &#123;  method: &#x27;POST&#x27;,  body: JSON.stringify(&#123;id: &quot;200&quot;&#125;)&#125;).then(response =&gt; &#123;  if(response.ok)&#123;    return response.json();    &#125;  throw new Error(&#x27;Request failed!&#x27;);&#125;, networkError =&gt; &#123;  console.log(networkError.message);&#125;).then(jsonResponse =&gt; &#123;  console.log(jsonResponse);&#125;)

async await 语法

const getSuggestions = async () =&gt; &#123;  const wordQuery = inputField.value;  const endpoint = `$&#123;url&#125;$&#123;queryParams&#125;$&#123;wordQuery&#125;`;  try&#123;    const response = await fetch(endpoint, &#123;cache: &#x27;no-cache&#x27;&#125;);    if(response.ok)&#123;      const jsonResponse = await response.json()    &#125;  &#125;  catch(error)&#123;    console.log(error)  &#125;&#125;
]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>后端编程</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 备忘录</title>
    <url>/2025/01/08/docker/</url>
    <content><![CDATA[Docker 备忘清单这是 Docker 的快速参考备忘单。 你可以在这里找到最常见的 Docker 命令。
入门

入门安装curl -sSL https://get.docker.com/ | shsudo chmod 777 /var/run/docker.sock

在后台创建和运行容器
$ docker run -d -p 80:80 docker/getting-started



-d - 以分离（后台）模式运行容器
-p 80:80 -  将端口 80 映射到容器中的端口 80，格式：宿主机端口:容器端口
docker/getting-started - 要使用的镜像

在前台创建并运行容器（之后如果要退出容器但是不关闭容器，按Ctrl+P+Q即可）
$ docker run -it --rm -p  8001:8080 --name my-nginx nginx



-it - 交互式 bash 模式
--rm - 容器终止运行后自动删除容器文件
-p 8001:8080 - 将 8001 端口映射到容器中的 8080 端口
--name my-nginx - 指定名称
nginx - 要使用的镜像

一般命令


Example
Description



docker ps
列出正在运行的容器


docker ps -a
列出所有容器


docker ps -s
列出正在运行的容器 (带 CPU &#x2F; 内存)


docker images
列出所有镜像


docker exec -it &lt;container&gt;  bash
连接到容器


docker logs &lt;container&gt;
显示容器的控制台日志


docker stop &lt;container&gt;
停止容器


docker restart &lt;container&gt;
重启一个容器


docker rm &lt;container&gt;
移除一个容器


docker port &lt;container&gt;
显示容器的端口映射


docker top &lt;container&gt;
列出进程


docker kill &lt;container&gt;
杀死一个容器


参数 &lt;container&gt; 可以是容器 id 或名称
Docker 容器

启动和停止


Description
Example



docker start nginx-server
开始


docker stop nginx-server
停止


docker restart nginx-server
重启


docker pause nginx-server
暂停


docker unpause nginx-server
取消暂停


docker wait nginx-server
阻塞容器


docker kill nginx-server
发送 SIGKILL


docker attach nginx-server
连接到现有容器


说明


Example
Description



docker ps
列出正在运行的容器


docker ps -a
列出所有容器


docker logs nginx-server
容器日志


docker inspect nginx-server
检查容器


docker events nginx-server
容器事件


docker port nginx-server
公共端口


docker top nginx-server
运行进程


docker stats nginx-server
容器资源使用


docker diff nginx-server
列出对容器所做的更改


创建容器docker create [options] IMAGE  -a, --attach               # 附加标准输出/错误  -i, --interactive          # 附加标准输入（交互式）  -t, --tty                  # 伪终端 pseudo-tty      --name NAME            # 命名你的镜像  -p, --publish 5000:5000    # 端口映射（主机:容器）      --expose 5432          # 向容器公开端口   -P, --publish-all          # 发布所有端口      --link container:alias # 链接 linking  -v, --volume `pwd`:/app    # mount（需要绝对路径）  -e, --env NAME=hello       # 环境变量 env vars

实例$ docker create --name my_redis --expose 6379 redis:3.0.2

操控重命名容器
docker rename my-nginx nginx-server

移除容器
docker rm nginx-server

更新容器
docker update --cpu-shares 512 -m 300M nginx-server

Docker 镜像

操控




Example
Description



docker images
列出镜像


docker rmi nginx
删除镜像


docker load &lt; ubuntu.tar.gz
加载一个 tarred 存储库


docker load --input ubuntu.tar
加载一个 tarred 存储库


docker save busybox &gt; ubuntu.tar
将镜像保存到 tar 存档


docker history
显示镜像的历史


docker commit nginx my_nginx
将容器另存为镜像


docker tag nginx eon01/nginx
标记镜像


docker push eon01/nginx
推送镜像


构建镜像# 注意有的最后面是英文 .$ docker build .$ docker build github.com/creack/docker-firefox$ docker build - &lt; Dockerfile$ docker build - &lt; context.tar.gz$ docker build -t eon/nginx-server .$ docker build -f myOtherDockerfile .$ docker build --build-arg https_proxy=127.0.0.1:8088 # 使用http代理构建$ curl example.com/remote/Dockerfile | docker build -f - .$ docker save -o &lt;保存路径&gt;/myimage.tar myimage:latest # 导出$ docker load -i &lt;路径&gt;/myimage.tar # 导入

删除 &lt;none&gt; 镜像$ docker rmi -f $(docker images | grep &quot;none&quot; | awk &#x27;&#123;print $3&#125;&#x27;)

Docker 网络

创建网络docker network create -d overlay MyOverlayNetworkdocker network create -d bridge MyBridgeNetwork

自定义网络子网和网关
docker network create -d overlay \  --subnet=192.168.0.0/16 \  --subnet=192.170.0.0/16 \  --gateway=192.168.0.100 \  --gateway=192.170.0.100 \  --ip-range=192.168.1.0/24 \  --aux-address=&quot;my-router=192.168.1.5&quot; \  --aux-address=&quot;my-switch=192.168.1.6&quot; \  --aux-address=&quot;my-printer=192.170.1.5&quot; \  --aux-address=&quot;my-nas=192.170.1.6&quot; \  MyOverlayNetwork

操作

获取容器连接的网络
docker inspect MyContainer | grep Network

获取有关网络的信息
docker network inspect &lt;network_name&gt;

将正在运行的容器连接到网络
docker network connect &lt;network_name&gt; &lt;container_name&gt;

启动时将容器连接到网络
docker run -it -d --network=&lt;network_name&gt; &lt;container_name&gt;

断开容器与网络的连接
docker network disconnect &lt;network_name&gt; &lt;container_name&gt;

删除网络docker network rm &lt;network_name&gt;

列出网络docker network ls

Docker 快捷键需要特别注意的是，退出快捷键中的删除容器实例，只对于使用 docker attach 进入的容器生效，使用 docker exec 进入容器后，使用上面的快捷键后将隔离容器，且不会删除容器实例。
退出 - 关闭容器


Docker 快捷键
说明



ctrl c
将关闭容器




将关闭容器, 并删除当前的容器实例
退出 - 保留容器


Docker 快捷键
说明



ctrl d
保留容器




将保留容器，并退出到Docker主机的命令行界面
退出 - 容器分离


Docker 快捷键
说明



ctrl p q
容器分离




将容器分离，保留容器，但是不退出
各种各样的

Docker Hub$ docker search search_word  # 在 docker hub 中搜索镜像$ docker pull user/image     # 从 docker hub 下载镜像$ docker login               # 向 docker hub 进行身份验证$ docker push user/image     # 将镜像上传到 docker hub

镜像仓库命令

登录到镜像仓库
$ docker login$ docker login localhost:8080

从镜像仓库注销
$ docker logout$ docker logout localhost:8080

搜索镜像
$ docker search nginx$ docker search nginx --stars=3 --no-trunc busybox

拉取镜像
$ docker pull nginx$ docker pull eon01/nginx localhost:5000/myadmin/nginx

推送镜像
$ docker push eon01/nginx$ docker push eon01/nginx localhost:5000/myadmin/nginx

批量清除


实例
说明



docker stop -f $(docker ps -a -q)
停止所有容器


docker rm -f $(docker ps -a -q)
删除所有容器


docker rmi -f $(docker images -q)
删除所有镜像


docker volume prune
删除所有未使用的Docker Volume


docker network prune
删除所有未使用的Docker网络


docker system prune
清理所有空闲或与任何Docker容器无关的资源


docker image prune
删除悬空的Docker镜像


docker container prune
删除所有未使用的Docker 容器




卷 volume$ docker volume ls    # 检查卷$ docker volume prune # 清理未使用的卷

Docker Compose




:-
:-



docker-compose up
创建和启动容器


docker-compose up -d
以分离模式创建和启动容器


docker-compose down
停止和删除容器、网络、映像和卷


docker-compose logs
查看容器的输出


docker-compose restart
重启所有服务


docker-compose pull
拉取所有服务的镜像


docker-compose build
构建所有服务的镜像


docker-compose config
验证并查看 Compose 文件


docker-compose scale &lt;service_name&gt;=&lt;replica&gt;
为服务指定容器个数


docker-compose top
显示正在运行的进程


docker-compose run -rm -p 2022:22 web bash
启动 Web 服务并运行 bash 作为其命令，删除旧容器




Docker Services


:-
:-



docker service create &lt;options&gt; &lt;image&gt; &lt;command&gt;
创建新服务


docker service inspect --pretty &lt;service_name&gt;
显示详细信息服务


docker service ls
列出服务


docker service ps
列出服务的任务


docker service scale &lt;service_name&gt;=&lt;replica&gt;
规模特殊服务


docker service update &lt;options&gt; &lt;service_name&gt;
更新服务选项




Docker Stack




:-
:-



docker stack ls
列出此 Docker 主机上所有正在运行的应用程序


docker stack deploy -c &lt;composefile&gt; &lt;appname&gt;
运行指定的 Compose 文件


docker stack services &lt;appname&gt;
列出与应用关联的服务


docker stack ps &lt;appname&gt;
列出与应用关联的正在运行的容器


docker stack rm &lt;appname&gt;
拆掉一个应用程序




Docker Machine




:-
:-



docker-machine create --driver virtualbox myvm1
创建虚拟机（Mac、Win7、Linux）


docker-machine create -d hyperv --hyperv-virtual-switch &quot;myswitch&quot; myvm1
Win10


docker-machine env myvm1
查看有关您的节点的基本信息


docker-machine ssh myvm1 &quot;docker node ls&quot;
列出集群中的节点


docker-machine ssh myvm1 &quot;docker node inspect &lt;node ID&gt;&quot;
检查节点


docker-machine ssh myvm1 &quot;docker swarm join-token -q worker&quot;
查看加入令牌


docker-machine ssh myvm1
打开与 VM 的 SSH 会话； 输入“exit”结束


docker-machine ssh myvm2 &quot;docker swarm leave&quot;
让工人离开群体


docker-machine ssh myvm1 &quot;docker swarm leave -f&quot;
让主人离开，杀群


docker-machine start myvm1
启动当前未运行的 VM


docker-machine stop $(docker-machine ls -q)
停止所有正在运行的虚拟机


docker-machine rm $(docker-machine ls -q)
删除所有虚拟机及其磁盘映像


docker-machine scp docker-compose.yml myvm1:~
将文件复制到节点的主目录


docker-machine ssh myvm1 &quot;docker stack deploy -c &lt;file&gt; &lt;app&gt;&quot;
部署应用




docker 主要命令




:-
:-



attach
将本地标准输入、输出和错误流附加到正在运行的容器


build
从 Dockerfile 构建镜像


commit
从容器的更改创建新镜像


cp
在容器和本地文件系统之间复制文件&#x2F;文件夹


create
创建一个新容器


diff
检查容器文件系统上文件或目录的更改


events
从服务器获取实时事件


exec
在正在运行的容器中运行命令


export
将容器的文件系统导出为 tar 存档


history
显示镜像的历史


images
列出镜像


import
从 tarball 导入内容以创建文件系统映像


info
显示系统范围的信息


inspect
返回有关 Docker 对象的低级信息


kill
杀死一个或多个正在运行的容器


load
从 tar 存档或 STDIN 加载镜像


login
登录到 Docker 注册表


logout
从 Docker 注册表中注销


logs
获取容器的日志


pause
暂停一个或多个容器内的所有进程


port
列出容器的端口映射或特定映射


ps
列出容器


pull
从注册表中提取镜像或存储库


push
将镜像或存储库推送到注册表


rename
重命名容器


restart
重启一个或多个容器


rm
移除一个或多个容器


rmi
移除一张或多张镜像


run
在新容器中运行命令


save
将一个或多个镜像保存到 tar 存档（默认流式传输到 STDOUT）


search
在 Docker Hub 中搜索镜像


start
启动一个或多个停止的容器


stats
显示容器资源使用统计的实时流


stop
停止一个或多个正在运行的容器


tag
创建一个引用 SOURCE_IMAGE 的标记 TARGET_IMAGE


top
显示容器的运行进程


unpause
取消暂停一个或多个容器中的所有进程


update
更新一个或多个容器的配置


version
显示 Docker 版本信息


wait
阻塞直到一个或多个容器停止，然后打印它们的退出代码




docker 管理命令


:-
:-



docker builder
管理构建


docker buildx*
Docker Buildx（Docker Inc.，v0.7.1）


docker compose*
Docker Compose（Docker Inc.，v2.2.3）


docker config
管理 Docker 配置


docker container
管理容器


docker context
管理上下文


docker image
管理镜像


docker manifest
管理 Docker 镜像清单和清单列表


docker network
管理网络


docker node
管理 Swarm 节点


docker plugin
管理插件


docker scan*
Docker 扫描（Docker Inc.，v0.16.0）


docker secret
管理 Docker 机密


docker service
管理服务


docker stack
管理 Docker 堆栈


docker swarm
管理群


docker system
管理 Docker


docker trust
管理对 Docker 映像的信任


docker volume
管理卷




docker 全局参数    --config string     # 客户端配置文件的位置（默认“~/.docker”）-c, --context string    # 用于连接到守护程序的上下文的名称（                        # 覆盖 DOCKER_HOST 环境变量和使用                        # “docker context use” 设置的默认上下文）-D, --debug             # 启用调试模式-H, --host list         # 要连接的守护进程套接字-l, --log-level string  # 设置日志级别        # （默认“info”） (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;)     --tls               # 使用 TLS； 由 --tlsverify 暗示    --tlscacert string  # 仅由该 CA 签署的信任证书        #（默认为“~/.docker/ca.pem”）    --tlscert string    # TLS证书文件路径        #（默认“~/.docker/cert.pem”）    --tlskey string     # TLS 密钥文件的路径        #（默认为“~/.docker/key.pem”）    --tlsverify         # 使用 TLS 并验证远程-v, --version           # 打印版本信息并退出

docker images-a, --all             显示所有镜像（默认隐藏中间镜像）    --digests         显示摘要-f, --filter filter   根据提供的条件过滤输出    --format string   使用 Go 模板打印漂亮的镜像    --no-trunc        不要截断输出-q, --quiet           仅显示镜像 ID

docker run&#x2F;create

    --add-host list            # 添加自定义主机到 IP 映射 (host:ip)-a, --attach list              # 连接到 STDIN、STDOUT 或 STDERR    --blkio-weight uint16      # 块 IO（相对权重），介于 10 和 1000 之间，或 0 禁用（默认 0）    --blkio-weight-device list # 块 IO 权重（相对设备权重）（默认 []）    --cap-add list             # 添加 Linux 功能    --cap-drop list            # 放弃 Linux 功能    --cgroup-parent string     # 容器的可选父 cgroup    --cgroupns string          # 要使用的 Cgroup 命名空间（主机|私有）                               #  &#x27;host&#x27;:    在 Docker 主机的 cgroup 命名空间中运行容器                               #  &#x27;private&#x27;: 在自己的私有 cgroup 命名空间中运行容器                               #  &#x27;&#x27;:        使用由守护进程上的                                #        default-cgroupns-mode 选项配置的 cgroup 命名空间（默认）    --cidfile string           # 将容器 ID 写入文件    --cpu-period int           # 限制 CPU CFS（完全公平调度器）周期    --cpu-quota int            # 限制 CPU CFS（完全公平调度器）配额    --cpu-rt-period int        # 以微秒为单位限制 CPU 实时周期    --cpu-rt-runtime int       # 以微秒为单位限制 CPU 实时运行时间-c, --cpu-shares int           # CPU 份额（相对权重）    --cpus decimal             # CPU 数量    --cpuset-cpus string       # 允许执行的 CPU (0-3, 0,1)    --cpuset-mems string       # 允许执行的 MEM (0-3, 0,1)    --device list              # 将主机设备添加到容器    --device-cgroup-rule list  # 将规则添加到 cgroup 允许的设备列表    --device-read-bps list     # 限制设备的读取速率（每秒字节数）（默认 []）    --device-read-iops list    # 限制设备的读取速率（每秒 IO）（默认 []）    --device-write-bps list    # 限制设备的写入速率（每秒字节数）（默认 []）    --device-write-iops list   # 限制设备的写入速率（每秒 IO）（默认 []）    --disable-content-trust    # 跳过镜像验证（默认为 true）    --dns list                 # 设置自定义 DNS 服务器    --dns-option list          # 设置 DNS 选项    --dns-search list          # 设置自定义 DNS 搜索域    --domainname string        # 容器 NIS 域名    --entrypoint string        # 覆盖镜像的默认入口点-e, --env list                 # 设置环境变量    --env-file list            # 读入环境变量文件    --expose list              # 公开一个端口或一系列端口    --gpus gpu-request         # 要添加到容器中的 GPU 设备（“全部”以传递所有 GPU）    --group-add list           # 添加其他组以加入    --health-cmd string        # 运行以检查运行状况的命令    --health-interval duration # 运行检查之间的时间 (ms|s|m|h) (默认 0s)    --health-retries int           # 需要报告不健康的连续失败    --health-start-period duration # 开始健康重试倒计时之前容器初始化的开始时间（ms|s|m|h）（默认 0s）    --health-timeout duration      # 允许运行一项检查的最长时间 (ms|s|m|h) (默认 0s)    --help                     # 打印使用-h, --hostname string          # 容器主机名    --init                     # 在容器内运行一个 init 来转发信号并收获进程-i, --interactive              # 即使没有连接，也保持 STDIN 打开    --ip string                # IPv4 地址（例如 172.30.100.104）    --ip6 string               # IPv6 地址（例如，2001:db8::33）    --ipc string               # 要使用的 IPC 模式    --isolation string         # 容器隔离技术    --kernel-memory bytes      # 内核内存限制-l, --label list               # 在容器上设置元数据    --label-file list          # 读入以行分隔的标签文件    --link list                # 添加到另一个容器的链接    --link-local-ip list       # 容器 IPv4/IPv6 链路本地地址    --log-driver string        # 容器的日志记录驱动程序    --log-opt list             # 日志驱动程序选项    --mac-address string       # 容器 MAC 地址（例如 92:d0:c6:0a:29:33）-m, --memory bytes             # 内存限制    --memory-reservation bytes # 内存软限制    --memory-swap bytes        # 交换限制等于内存加上交换：&#x27;-1&#x27; 启用无限交换    --memory-swappiness int    # 调整容器内存交换（0 到 100）（默认 -1）    --mount mount              # 将文件系统挂载附加到容器    --name string              # 为容器分配名称    --network network          # 将容器连接到网络    --network-alias list       # 为容器添加网络范围的别名    --no-healthcheck           # 禁用任何容器指定的 HEALTHCHECK    --oom-kill-disable         # 禁用 OOM 杀手    --oom-score-adj int        # 调整主机的 OOM 首选项（-1000 到 1000）    --pid string               # 要使用的 PID 命名空间    --pids-limit int           # 调整容器 pids 限制（设置 -1 表示无限制）    --platform string          # 如果服务器支持多平台，则设置平台    --privileged               # 授予此容器扩展权限-p, --publish list             # 将容器的端口发布到主机-P, --publish-all              # 将所有暴露的端口发布到随机端口    --pull string              # 创建前拉取镜像(&quot;always&quot;|&quot;missing&quot;|&quot;never&quot;)(默认&quot;missing&quot;)    --read-only                # 将容器的根文件系统挂载为只读    --restart string           # 容器退出时应用的重启策略（默认“否”）    --rm                       # 容器退出时自动移除    --runtime string           # 用于此容器的运行时    --security-opt list        # 安全选项    --shm-size bytes           # /dev/shm 的大小    --stop-signal string       # 停止容器的信号（默认“SIGTERM”）    --stop-timeout int         # 停止容器的超时（以秒为单位）    --storage-opt list         # 容器的存储驱动程序选项    --sysctl map               # Sysctl 选项（默认 map[]）    --tmpfs list               # 挂载 tmpfs 目录-t, --tty                      # 分配一个伪 TTY    --ulimit ulimit            # ulimit 选项（默认 []）-u, --user string              # 用户名或 UID（格式：&lt;name|uid&gt;[:&lt;group|gid&gt;]）    --userns string            # 要使用的用户命名空间    --uts string               # 要使用的 UTS 命名空间-v, --volume list              # 绑定挂载卷    --volume-driver string     # 容器的可选卷驱动程序    --volumes-from list        # 从指定容器挂载卷-w, --workdir string           # 容器内的工作目录

run&#x2F;create 大部分参数一致
修改Docker镜像拉取地址您可以通过修改daemon配置文件&#x2F;etc&#x2F;docker&#x2F;daemon.json来使用加速器
sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://1ojaslt1.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker

修改 Docker 数据存储路径


停止 Docker 服务：
  sudo systemctl stop docker

将现有的 Docker 数据移动到新的目录：
  sudo mv /var/lib/docker /new/path/docker

更新 Docker 的配置文件 /etc/docker/daemon.json，添加或修改 data-root 选项：
  &#123; &quot;data-root&quot;: &quot;/new/path/docker&quot; &#125;

重新启动 Docker 服务：
  sudo systemctl start docker



⚠️注意：当你执行此操作时，旧的容器和镜像可能无法正常工作，因为它们的路径已更改。建议在部署 Docker 时执行此操作，以避免这些问题。如有必要，重新启动容器或重新创建它们，以确保它们的配置指向新的路径。
Docker降级版本的方法yum downgrade --setopt=obsoletes=0 \    -y docker-ce-$&#123;version&#125; docker-ce-selinux-$&#123;version&#125;

$&#123;version&#125; 指定要降级的版本
Docker 常用示例

Docker Web 管理工具 portainer$ docker run -d --name portainer \  -p 8000:8000 \  -p 9443:9443 \  --restart=always \  -v /var/run/docker.sock:/var/run/docker.sock \  -v $HOME/portainer:/data \    portainer/portainer-ee:latest

Nginx

docker run -itd -p 80:80 --restart=always --name Nginx \-v $HOME/nginx_data/html:/usr/share/nginx/html \-v $HOME/nginx_data/conf:/etc/nginx/conf.d \-v $HOME/nginx_data/nginx.conf:/etc/nginx/nginx.conf \nginx

参数解释
-itd: 启动容器并保持后台运行
-p 80:80: 将主机的 80 端口映射到容器的 80 端口，用于访问 Nginx 站点页面
--name Nginx: 给容器指定一个名称为 “Nginx”
--restart=always: 在容器退出时，总是重新启动容器

持久化解释


–
–



-v $HOME/nginx_data/html:/usr/share/nginx/html
将容器中的 Nginx 站点页面路径映射到本地


-v $HOME/nginx_data/conf:/etc/nginx/conf.d
将容器中的 Nginx 虚拟主机配置文件路径映射到本地 (需要提前准备好文件)


-v $HOME/nginx_data/nginx.conf:/etc/nginx/nginx.conf
将容器中的 Nginx 主配置文件路径映射到本地 (需要提前准备好文件)




Tomcatdocker run -itd -p 8080:8080 --restart=always \--name Tomcat \-v $HOME/Tomcat_data/webapps:/usr/local/tomcat/webapps/ROOT \tomcat

参数解释
-itd: 以后台运行的方式启动容器，并分配一个伪终端（pseudo-TTY）和保持 STDIN 打开
-p 8080:8080: 将主机的端口 8080 映射到容器的 8080 端口，用于访问 Tomcat 站点页面
--name Tomcat: 为容器指定名称为 “Tomcat”
--restart=always: 当容器退出时，总是重新启动容器

持久化解释将容器中的 /usr/local/tomcat/webapps/ROOT 路径挂载到宿主机中的 $HOME/Tomcat_data/webapps 目录下。
Weblogic

docker run -itd \-p 7001:7001 \-p 7002:7002 \-p 5556:5556 \--restart=always --name Weblogic ismaleiva90/weblogic12

注意：ismaleiva90/weblogic12 是非官方或认证的 Docker 镜像！
参数解释
-itd: 后台运行容器，保持 STDIN 打开
-p 7001:7001: 映射主机 7001 端口到容器 7001 端口，访问 Weblogic 控制台页面
-p 7002:7002: 映射主机 7002 端口到容器 7002 端口，访问 Weblogic 站点页面
-p 5556:5556: 映射主机 5556 端口到容器 5556 端口，访问 Weblogic 站点页面
--name Weblogic: 容器名称为 “Weblogic”
--restart=always: 容器退出时，总是重新启动容器

MySQL

docker run -d -it -p 3306:3306 --name MySQL --restart=always \-v $HOME/MySQL_Data/data:/var/lib/mysql \-v $HOME/MySQL_Data/conf:/etc/mysql/conf.d \--privileged=true \-e MYSQL_DATABASE=&#x27;test_db&#x27; \-e MYSQL_ROOT_PASSWORD=&#x27;abc$123&#x27; \-e MYSQL_USER=&#x27;testuser&#x27; -e MYSQL_PASSWORD=&#x27;abc$123&#x27; \mysql:8.0.31 \    --character-set-server=utf8mb4 \    --collation-server=utf8mb4_unicode_ci

参数解释


–
–



-d
表示以后台运行的方式启动容器


-it
分别表示分配一个伪终端（pseudo-TTY）并保持 STDIN 打开


-p 3306:3306
将主机的端口映射到容器的端口，这里是将主机的 3306 端口映射到容器的 3306 端口，用于访问 MySQL 数据库


--name MySQL
为容器指定一个名称，这里是 “MySQL”


--restart=always
表示当容器退出时，总是重新启动容器


--privileged=true
若不加字段–privileged&#x3D;true可能会报权限错误


--character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
这两个选项参数是改变所有表的默认编码和排序规则以使用 UTF-8 (utf8mb4)




持久化解释


–
–



-v $HOME/MySQL_Data/data:/var/lib/mysql
将容器中的 MySQL 数据库数据存储到本地，以确保在容器重启时数据得以保留。


-v $HOME/MySQL_Data/conf:/etc/mysql/conf.d
将容器中的 MySQL 自定义配置文件路径映射到本地，以方便自定义配置。请确保提前准备好文件，否则可能会启动失败。




环境变量解释


–
–



MYSQL_ROOT_PASSWORD 【必填】
必需的变量，用于指定 MySQL 的 root 超级用户帐户的密码。如果设置了 MYSQL_RANDOM_ROOT_PASSWORD=yes ，则会随机生成一个密码，并打印到 stdout。


MYSQL_USER 【可选】
可选变量，用于创建新用户。此用户将被授予指定数据库的超级用户权限。需要同时设置 MYSQL_PASSWORD 变量。


MYSQL_PASSWORD 【可选】
可选变量，用于创建新用户并设置密码。此用户将被授予指定数据库的超级用户权限。需要同时设置 MYSQL_USER 变量。


MYSQL_DATABASE 【可选】
可选变量，允许在容器启动时指定要创建的数据库的名称。如果设置了 MYSQL_USER 和 MYSQL_PASSWORD，则该用户将被授予对此数据库的超级用户访问权限。




Oracledocker run -d -it -p 1521:1521 --name Oracle_11g --restart=always \--mount source=oracle_vol,target=/home/oracle/app/oracle/oradata \registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g

注意：registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g 是非官方或认证的Docker镜像！
参数解释


–
–



-d
表示以后台运行的方式启动容器


-it
分别表示分配一个伪终端（pseudo-TTY）并保持 STDIN 打开


-p 1521:1521
将主机的端口映射到容器的端口，这里是将主机的 1521 端口映射到容器的 1521 端口，用于访问 Oracle 数据库


--name Oracle_11g
为容器指定一个名称，这里是 “Oracle_11g”


--restart=always
表示当容器退出时，总是重新启动容器




持久化解释


–
–



--mount source=oracle_vol,target=/home/oracle/app/oracle/oradata
将名为 “oracle_vol” 的 Docker 卷挂载到容器中的 “&#x2F;home&#x2F;oracle&#x2F;app&#x2F;oracle&#x2F;oradata” 路径。这样做的目的是将 Oracle 数据库的数据存储在持久化的卷中，以便数据在容器重启时得以保留




PostgreSQLdocker run -d -p 5432:5432 --restart=always --name PostgreSQL \-e POSTGRES_USER=&#x27;postgres&#x27; \-e POSTGRES_PASSWORD=&#x27;abc$123&#x27; \-e POSTGRES_DB=&#x27;test&#x27; \-e PGDATA=/var/lib/postgresql/data/pgdata \-v $HOME/Postgres_Data:/var/lib/postgresql/data \-d postgres

参数解释


–
–



-d
表示以后台运行的方式启动容器


-it
分别表示分配一个伪终端（pseudo-TTY）并保持 STDIN 打开


-p 5432:5432
将主机的端口映射到容器的端口，这里是将主机的 5432 端口映射到容器的 5432 端口，用于访问 Postgre 数据库


--name PostgreSQL
为容器指定一个名称，这里是 “PostgreSQL”


--restart=always
表示当容器退出时，总是重新启动容器




持久化解释


–
–



-v $HOME/Postgres_Data:/var/lib/postgresql/data
将到容器中的 “&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data” 路径映射挂载到 宿主机中的 ”$HOME&#x2F;Postgres_Data“目录下,这样做的目的是将 Postgre 数据库的数据存储在本地中，以便数据在容器重启时得以保留




环境变量解释


–
–



POSTGRES_PASSWORD 【必填】
PostgreSQL 映像所需的环境变量。设置 PostgreSQL 超级用户的密码。不能为空或未定义。


POSTGRES_USER 【可选】
可选环境变量，用于创建用户及其密码。创建具有超级用户权限的指定用户和同名的数据库。默认用户是 “postgres”。


POSTGRES_DB 【可选】
可选环境变量，用于定义首次启动映像时创建的默认数据库的名称。默认值是 POSTGRES_USER 的值，如果未设置，则默认为 “postgres”。


PGDATA 【可选】
默认为 /var/lib/postgresql/data。如果使用的数据卷是文件系统挂载点或无法被用户 chowned 的远程文件夹，则需要设置此环境变量以包含数据。




达梦docker run -d -p 5236:5236 --restart=always --name DaMengDB \--privileged=true \-e PAGE_SIZE=16 \-e LD_LIBRARY_PATH=/opt/dmdbms/bin \-e EXTENT_SIZE=32 \-e BLANK_PAD_MODE=1 \-e LOG_SIZE=1024 \-e UNICODE_FLAG=1 \-e LENGTH_IN_CHAR=1 \-e INSTANCE_NAME=dm8_test \-v $HOME/DaMeng_Data:/opt/dmdbms/data \if010/dameng

注意：if010&#x2F;dameng 是从官网下载上传至 Docker Hub 的镜像！
参数解释


–
–



-d
表示以后台运行的方式启动容器


-it
分别表示分配一个伪终端（pseudo-TTY）并保持 STDIN 打开


-p 5236:5236
将主机的端口映射到容器的端口，这里是将主机的 5236 端口映射到容器的 5236 端口，用于访问达梦数据库


--name DaMengDB
为容器指定一个名称，这里是 “DaMengDB”


--restart=always
表示当容器退出时，总是重新启动容器




持久化解释


–
–



-v $HOME/DaMeng_Data:/opt/dmdbms/data
将容器中的达梦数据库数据存储路径 “&#x2F;opt&#x2F;dmdbms&#x2F;data” 映射到本地主机的 “$HOME&#x2F;DaMeng_Data” 目录，以确保在容器重启时数据得以保留




人大金仓docker run -idt -p 54321:54321 --restart=always \--name Kingbase --privileged=true \-e DB_MODE=oracle \-e NEED_START=yes \-e DB_USER=kingbase \-e DB_PASSWORD=abc123 \-e ENABLE_CI=yes \-v $HOME/Kingbase_Data:/home/kingbase/userdata \if010/kingbase:v009r001c001b0025 /usr/sbin/init

注意：if010/kingbase:v009r001c001b0025 是从官网下载上传至 Docker Hub 的镜像，官网提供了两个下载版本，一个是 v008r006c008b0014，另一个是 v009r001c001b0025，可以拉取对应的 tag 镜像进行测试使用！
参数解释


–
–



-itd
以后台方式启动容器，保持 STDIN 打开


-p 54321:54321
将主机的 54321 端口映射到容器的 54321 端口，访问数据库


--name Kingbase
给容器指定名称为 “Kingbase”


--restart=always
容器退出时，总是重新启动容器




持久化解释


–
–



-v $HOME/Kingbase_Data:/home/kingbase/userdata
将容器中的人大金仓数据库数据存储路径 “&#x2F;home&#x2F;kingbase&#x2F;userdata” 映射到本地主机的 “$HOME&#x2F;Kingbase_Data” 目录，以确保在容器重启时数据得以保留




环境变量解释


–
–



DB_USER 【可选】
设置用户及其密码，默认为 “system”


DB_PASSWORD 【可选】
设置用户密码，默认为 “123456”


DB_MODE 【可选】
设置数据库模式，支持的模式有 oracle、pg、mysql


NEED_START 【可选】
设置进入容器后是否启动数据库，默认为 “yes”


ENABLE_CI 【可选】
设置是否需要配置大小写敏感，默认为 “yes”




Redisdocker run -d -p 6379:6379 --restart=always --name Redis \-v $HOME/Redis_Data/conf:/usr/local/etc/redis \-v $HOME/Redis_Data/data:/data \redis redis-server /usr/local/etc/redis/redis.conf

参数解释


–
–



-d
表示以后台运行的方式启动容器


-it
分别表示分配一个伪终端（pseudo-TTY）并保持 STDIN 打开


-p 6379:6379
将主机的端口映射到容器的端口，这里是将主机的 6379 端口映射到容器的 6379 端口，用于访问 Redis 数据库


--name Redis
为容器指定一个名称，这里是 “Redis”


--restart=always
表示当容器退出时，总是重新启动容器




持久化解释


–
–



-v $HOME/Redis_Data/conf:/usr/local/etc/redis
(需提前准备好文件，否则可能会启动失败) 将到容器中的 “&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis” 路径映射挂载到 宿主机中的”$HOME&#x2F;Redis_Data&#x2F;conf”目录下,这样子做的目的是可以自定义Redis的配置文件


-v $HOME/Redis_Data/data:/data
将到容器中的 “&#x2F;data” 路径映射挂载到 宿主机中的”$HOME&#x2F;Redis_Data&#x2F;data”目录下,这样做的目的是将 Redis 数据库的数据存储在本地中，以便数据在容器重启时得以保留




关于启动命令


–
–



redis-server /usr/local/etc/redis/redis.conf
容器内部执行该命令是为了按照我们自定义的配置文件启动，这个不是必须的！！！




Memcachedocker run -d -p 11211:11211 --name Memcached \    --restart=always memcached memcached -m 64

参数解释
-d: 以后台方式启动容器。
-it: 分配一个伪终端（pseudo-TTY）并保持 STDIN 打开。
-p 11211:11211: 将主机的 11211 端口映射到容器的 11211 端口，用于访问 Memcached 消息队列的 web 管理界面。
--name Memcached: 容器的名称为 “Memcached”。
--restart=always: 容器退出时，总是重新启动容器。

命令执行解释
memcached -m 64 这会将 Memcached 服务器设置为使用 64 MB 进行存储

MongoDB

docker run -d -p 27017:27017 --restart=always --name MongoDB \-e MONGO_INITDB_ROOT_USERNAME=mongoadmin \-e MONGO_INITDB_ROOT_PASSWORD=abc123 \-v $HOME/MongoDB_Data/data:/data/db \-v $HOME/MongoDB_Data/conf:/etc/mongo \mongo --config /etc/mongo/mongod.conf --wiredTigerCacheSizeGB 1.5

参数解释


–
–



-d
表示以后台运行的方式启动容器


-it
分别表示分配一个伪终端（pseudo-TTY）并保持 STDIN 打开


-p 27017:27017
将主机的端口映射到容器的端口，这里是将主机的 27017 端口映射到容器的 27017 端口，用于访问 MongoDB 数据库


--name MongoDB
为容器指定一个名称，这里是 “MongoDB”


--restart=always
表示当容器退出时，总是重新启动容器


--config /etc/mongo/mongod.conf
指定配置文件路径 (这个不是必须的，设置此选项之前需准备好mongod.conf文件映射到Docker内部)


--wiredTigerCacheSizeGB 1.5
设置WiredTiger缓存大小限制为1.5G




持久化解释


–
–



-v $HOME/MongoDB_Data/conf:/etc/mongo
将到容器中的 “&#x2F;etc&#x2F;mongo” 路径映射挂载到 宿主机中的”$HOME&#x2F;MongoDB_Data&#x2F;conf”目录下,这样子做的目的是可以自定义MongoDB的配置文件 (需提前准备好文件，否则可能会启动失败)


-v $HOME/Redis_Data/data:/data
将到容器中的 “&#x2F;data&#x2F;db” 路径映射挂载到 宿主机中的”$HOME&#x2F;MongoDB_Data&#x2F;data”目录下,这样做的目的是将 MongoDB 数据库的数据存储在本地中，以便数据在容器重启时得以保留




环境变量解释


–
–



MONGO_INITDB_ROOT_USERNAME 【可选】
该变量是创建管理员用户，该用户是在 admin 身份验证数据库中创建的，并被赋予角色 root，这是一个”超级用户”角色。


MONGO_INITDB_ROOT_PASSWORD 【可选】
该变量是为创建管理员用户设置密码，需配合 MONGO_INITDB_ROOT_USERNAME 变量参数使用




RabbitMQdocker run -itd -p 15672:15672 --name RabbitMQ \--hostname rmq-test \-e RABBITMQ_DEFAULT_VHOST=rmq-test \-e RABBITMQ_DEFAULT_USER=admin \-e RABBITMQ_DEFAULT_PASS=abc123 \rabbitmq:3-management 

参数解释


–
–



-itd
表示以后台运行的方式启动容器,并分配一个伪终端（pseudo-TTY）和保持 STDIN 打开


-p 15672:15672
将主机的端口映射到容器的端口，这里是将主机的 15672 端口映射到容器的 15672 端口，用于访问 RabbitMQ 控制台页面，内部除了该端口外，还开了4369&#x2F;tcp、5671-5672&#x2F;tcp、15671&#x2F;tcp、15691-15692&#x2F;tcp、25672&#x2F;tcp


--name RabbitMQ
为容器指定一个名称，这里是 “RabbitMQ”


--restart=always
表示当容器退出时，总是重新启动容器


--hostname
设置容器主机名称




环境变量解释


–
–



RABBITMQ_DEFAULT_VHOST 【可选】
该变量是可选的，是设置 RabbitMQ 的主机名称


RABBITMQ_DEFAULT_USER 【可选】
该变量是可选的，是设置 RabbitMQ 的账户


RABBITMQ_DEFAULT_PASS 【可选】
该变量是可选的，是设置 RabbitMQ 的密码




远程协助工具 Guacd

docker run -d -p 4822:4822 --privileged=true \    --restart=always --name Guacd \    -e LANG=zh_CN.UTF-8 \    -v /docker_data/Guacd/rdp-rec:/rdp-rec \    -v /docker_data/Guacd/rdp-file:/rdp-file \    guacamole/guacd

参数解释


–
–



-d
表示以后台运行的方式启动容器


-it
分别表示分配一个伪终端（pseudo-TTY）并保持 STDIN 打开


-p 4822:4822
将主机的端口映射到容器的端口，这里是将主机的 4822 端口映射到容器的 4822 端口，用于访问 Guacd远程的API接口


--name Guacd
为容器指定一个名称，这里是 “Guacd”


--restart=always
表示当容器退出时，总是重新启动容器


--privileged=true
若不加字段–privileged&#x3D;true可能会报权限错误




持久化解释


–
–



-v /docker_data/Guacd/rdp-rec:/rdp-rec
代码内固定配置，guacd服务rdp录屏文件存放路径


-v /docker_data/Guacd/rdp-file:/rdp-file
代码内固定配置，guacd服务rdp远程磁盘文件存放路




环境变量解释
LANG 设置字符编码格式

在线代码编辑器 Code Server$ mkdir -p ~/.config$ docker run -it --name code-server  \  -p 127.0.0.1:8080:8080 \  -v &quot;$HOME/.config/code-server:/home/coder/.config&quot; \  -v &quot;$PWD:/home/coder/project&quot; \  -u &quot;$(id -u):$(id -g)&quot; \  -e &quot;DOCKER_USER=$USER&quot; \    codercom/code-server:latest

媒体管理工具 Dim$ docker run --name my-dim \   -p 8000:8000/tcp \   -v $HOME/.config/dim:/opt/dim/config \   -v $HOME/dim/media:/media:ro \   -d ghcr.io/dusk-labs/dim:dev

Github
Gitlab$ docker run -d --name gitlab \  --hostname gitlab.example.com \  --publish 8443:443 --publish 8081:80 -p 2222:22 \  --restart always \  --volume $HOME/gitlab/config:/etc/gitlab \  --volume $HOME/gitlab/logs:/var/log/gitlab \  --volume $HOME/gitlab/data:/var/opt/gitlab \  -v /etc/localtime:/etc/localtime \  --shm-size 256m \    gitlab/gitlab-ce:latest

另见
Dockerfile 备忘清单 (github.io)
Docker 官方入门教程 (docker.com)
Docker入门学习笔记 (github.io)
快速安装Docker及配置及Docker配置、Docker常用命令

]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>后端编程</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON 备忘录</title>
    <url>/2025/01/08/json/</url>
    <content><![CDATA[JSON 备忘清单这是理解和编写 JSON 格式配置文件的快速参考备忘单。
入门介绍JSON 是一种基于文本的轻量级开放标准，专为人类可读的数据交换而设计。

JSON 代表 JavaScript 对象表示法
JSON 易于读写。
JSON 是与语言无关的数据交换格式
JSON 文件扩展名为 .json
JSON Internet 媒体类型为 application/json

示例&#123;  &quot;name&quot;: &quot;Jason&quot;,  &quot;age&quot;: 39,  &quot;height&quot;: 1.92,  &quot;gender&quot;: &quot;M&quot;,  &quot;salary&quot;: 70000,  &quot;married&quot;: true,  &quot;children&quot;: [    &#123;&quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 9&#125;,    &#123;&quot;name&quot;: &quot;Ava&quot;, &quot;age&quot;: 7&#125;  ]&#125;

类型


类型
描述



Number
双精度浮点


String
字符系列


Boolean
“true”或“false”


Array
有序的值序列


Value
字符串、数字、布尔值、空值等


Object
键&#x2F;值对的无序集合


null
Null 或 Empty


字符串









\&quot;
双引号 Double quote


\\
反斜杠 Backslash


\/
正斜杠 Forward slash


\b
退格 Backspace


\f
换页 Form feed


\n
换行 Newline


\r
回车 Carriage return


\t
标签 Tab


\u
后跟四个十六进制数字


示例&#123;  &quot;url&quot;: &quot;https://jaywcjlove.github.io&quot;,  &quot;msg&quot; : &quot;Hi,\n\&quot;Quick Reference\&quot;&quot;,  &quot;intro&quot;: &quot;为开发人员分享快速参考和备忘单&quot;&#125;

无效字符串&#123; &quot;foo&quot;: &#x27;bar&#x27; &#125;

Have to be delimited by double quotes
数字




类型
说明



Integer
数字 1-9、0 和正数或负数


Fraction
0.3、3.9 等分数


Exponent
指数，如 e、e+、e-、E、E+、E




示例&#123;  &quot;positive&quot; : 12,  &quot;negative&quot; : -1,  &quot;fraction&quot; : 10.25,  &quot;exponent&quot; : 1.0E+2,  &quot;zero&quot; : 0&#125;

无效的数字&#123; &quot;foo&quot;: 0xFF &#125;

在JSON中，只能使用十进制文字
对象 Objects&#123;  &quot;color&quot;: &quot;Purple&quot;,  &quot;id&quot;: &quot;210&quot;,  &quot;composition&quot;: &#123;    &quot;R&quot;: 70,    &quot;G&quot;: 39,    &quot;B&quot;: 89  &#125;,  &quot;empty_object&quot;: &#123;&#125;&#125;

用逗号分隔的多个键&#x2F;值对
数组 Arrays[1, 2, 3, 4, 5]

以 [ 开始并以 ] 结束
对象数组&#123;  &quot;children&quot;: [    &#123; &quot;name&quot;: &quot;Jimmy Smith&quot;, &quot;age&quot;: 15 &#125;,    &#123; &quot;name&quot;: &quot;Sammy Sosa&quot;, &quot;age&quot;: 12 &#125;  ]&#125;

数组对象&#123;  &quot;attributes&quot;: [&quot;a1&quot;, &quot;a2&quot;],  &quot;methods&quot;: [&quot;getter&quot;, &quot;setter&quot;],  &quot;empty_array&quot;: []&#125;

二维阵列&#123;  &quot;my_sequences&quot;: [    [1, 2, 3],    [4, 5, 6],    [7, 8, 9, 0],    [10, 11]  ]&#125;

对象的对象&#123;  &quot;Mark McGwire&quot;: &#123;    &quot;hr&quot;: 65,    &quot;avg&quot;: 0.278  &#125;,  &quot;Sammy Sosa&quot;: &#123;    &quot;hr&quot;: 63,    &quot;avg&quot;: 0.288  &#125;&#125;

嵌套&#123;  &quot;Jack&quot;: &#123;    &quot;id&quot;: 1,    &quot;name&quot;: &quot;Franc&quot;,    &quot;salary&quot;: 25000,    &quot;hobby&quot;: [&quot;a&quot;, &quot;b&quot;],    &quot;location&quot;: &#123;        &quot;country&quot;: &quot;A&quot;, &quot;city&quot;: &quot;A-A&quot;    &#125;  &#125;&#125;

JSON 5Objects对象键可以是 ECMAScript 5.1 IdentifierName
&#123;    width: 1920,    height: 1080,&#125;

数组可以有一个尾随逗号
[    1,    true,    &#x27;three&#x27;,]

允许单行和多行注释&#123;  // 一行注释  &quot;name&quot;: &quot;Kenny&quot;&#125;

多行注释
&#123;/* 这是一个   多行注释 */  &quot;name&quot;: &quot;Kenny&quot;&#125;

允许附加空白字符


代码点
描述



U+0009
水平制表符


U+000A
换行符


U+000B
垂直制表符


U+000C
换页符


U+000D
回车符


U+0020
空格


U+00A0
不间断空格


U+2028
行分隔符


U+2029
段落分隔符


U+FEFF
字节顺序标记


Unicode Zs 类别
空格分隔符 Unicode 类别中的任何其他字符




数字数字可能有前导或尾随小数点
&#123;    integer: 123,    withFractionPart: 123.456,    onlyFractionPart: .456,    withExponent: 123e-456,&#125;

数字可以是十六进制
&#123;    positiveHex: 0xdecaf,    negativeHex: -0xC0FFEE,&#125;

数字可以是正无穷大、负无穷大和 NaN。
&#123;    positiveInfinity: Infinity,    negativeInfinity: -Infinity,    notANumber: NaN,&#125;

数字可以以明确的加号开头
字符串

&#x27;Lorem ipsum dolor sit amet, \consectetur adipiscing elit.&#x27;

以下是代表相同的意思
&#x27;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&#x27;

&#x27;\A\C\/\D\C&#x27;

以下是代表相同的意思
&#x27;AC/DC&#x27;

在 JavaScript 中访问 JSON访问对象let myObject = &#123;  &quot;name&quot;: &quot;Jason&quot;,  &quot;last&quot;: &quot;Doe&quot;,  &quot;age&quot;: 39,  &quot;gender&quot;: &quot;M&quot;,  &quot;salary&quot;: 70000,  &quot;married&quot;: true&#125;;










myObject.name
“Jason”


myObject[&quot;name&quot;]
“Jason”


myObject.age
39


myObject.other
undefined


myObject[0]
undefined


访问嵌套

let myObject = &#123;    &quot;ref&quot;: &#123;        &quot;name&quot;: 0,        &quot;last&quot;: 1,        &quot;age&quot;: 2,        &quot;gender&quot;: 3,        &quot;salary&quot;: 4,        &quot;married&quot;: 5    &#125;,    &quot;jdoe&quot;: [        &quot;Jason&quot;,        &quot;Doe&quot;,        39,        &quot;M&quot;,        70000,        true    ],    &quot;jsmith&quot;: [        &quot;Tom&quot;,        &quot;Smith&quot;,        42,        &quot;F&quot;,        80000,        true    ]&#125;;










myObject.ref.age
2


myObject[&quot;ref&quot;][&quot;age&quot;]
2


myObject.jdoe
[“Jason”, “Doe”, 39 …]


myObject.jsmith[3]
“F”


myObject[1]
undefined


访问对象数组

let myArray = [  &#123;    &quot;name&quot;: &quot;Jason&quot;,    &quot;last&quot;: &quot;Doe&quot;,    &quot;age&quot;: 39,    &quot;gender&quot;: &quot;M&quot;,    &quot;salary&quot;: 70000,    &quot;married&quot;: true  &#125;,  &#123;    &quot;name&quot;: &quot;Tom&quot;,    &quot;last&quot;: &quot;Smith&quot;,    &quot;age&quot;: 42,    &quot;gender&quot;: &quot;F&quot;,    &quot;salary&quot;: 80000,    &quot;married&quot;: true  &#125;,  &#123;    &quot;name&quot;: &quot;Amy&quot;,    &quot;last&quot;: &quot;Burnquist&quot;,    &quot;age&quot;: 29,    &quot;gender&quot;: &quot;F&quot;,    &quot;salary&quot;: 60000,    &quot;married&quot;: false  &#125;];










myArray[0]
&#123;“name”: “Jason”, …&#125;


myArray[1].name
“Tom”


myArray[1][2]
42


myArray[3]
undefined


myArray[3].gender
TypeError: Cannot read…


访问阵列let myArray = [  &quot;Jason&quot;,  &quot;Doe&quot;,  39,  &quot;M&quot;,  70000,  true];










myArray[1]
“Doe”


myArray[5]
true


myArray[6]
undefined


另见
JSON (json.org)
JSON Editor Online (jsoneditoronline.org)
Convert JSON Array to Markdown Table, CSV and more (tableconvert.com)

]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP 备忘录</title>
    <url>/2025/01/08/php/</url>
    <content><![CDATA[PHP 备忘清单这份 PHP 备忘单为快速查找最常用代码的正确语法提供了参考
入门hello.php&lt;?php // 以 PHP 开放标签开头echo &quot;Hello World\n&quot;;print(&quot;Hello jaywcjlove.github.io&quot;);?&gt;

PHP 运行命令
$ php hello.php

变量 Variables$boolean1 = true;$boolean2 = True;$int = 12;$float = 3.1415926;unset($float);  // 删除变量$str1 = &quot;How are you?&quot;;$str2 = &#x27;Fine, thanks&#x27;;

查看: Types
字符串 Strings$url = &quot;jaywcjlove.github.io&quot;;echo &quot;I&#x27;m learning PHP at $url&quot;;// 连接字符串echo &quot;I&#x27;m learning PHP at &quot; . $url;$hello = &quot;Hello, &quot;;$hello .= &quot;World!&quot;;echo $hello;   # =&gt; Hello, World!

查看: Strings
数组 Arrays$num = [1, 3, 5, 7, 9];$num[5] = 11;unset($num[2]);    // 删除变量print_r($num);     # =&gt; 1 3 7 9 11echo count($num);  # =&gt; 5

查看: Arrays
运算符 Operators$x = 1;$y = 2;$sum = $x + $y;echo $sum;   # =&gt; 3

查看: Operators
Include

vars.php&lt;?php // 以 PHP 开放标签开头。$fruit = &#x27;apple&#x27;;echo &quot;I was imported&quot;;return &#x27;Anything you like.&#x27;;?&gt;

test.php&lt;?phpinclude &#x27;vars.php&#x27;;echo $fruit . &quot;\n&quot;;   # =&gt; apple/* 与 include 相同，如果不能包含则导致错误*/require &#x27;vars.php&#x27;;// 也有效include(&#x27;vars.php&#x27;);require(&#x27;vars.php&#x27;);// 通过 HTTP 包含include &#x27;http://x.com/file.php&#x27;;// 包含和返回语句$result = include &#x27;vars.php&#x27;;echo $result;  # =&gt; Anything you like.?&gt;

功能 Functionsfunction add($num1, $num2 = 1) &#123;    return $num1 + $num2;&#125;echo add(10);    # =&gt; 11echo add(10, 5); # =&gt; 15

查看: Functions
注释 Comments# 这是一个单行 shell 样式的注释// 这是一行 c++ 风格的注释/* 这是一个多行注释    另一行注释 */

常数 Constantsconst MY_CONST = &quot;hello&quot;;echo MY_CONST;   # =&gt; hello# =&gt; MY_CONST is: helloecho &#x27;MY_CONST is: &#x27; . MY_CONST; 

类 Classesclass Student &#123;  public function __construct($name) &#123;      $this-&gt;name = $name;  &#125;&#125;$alex = new Student(&quot;Alex&quot;);

查看: Classes
PHP 类型布尔值 Boolean

$boolean1 = true;$boolean2 = TRUE;$boolean3 = false;$boolean4 = FALSE;$boolean5 = (boolean) 1;   # =&gt; true$boolean6 = (boolean) 0;   # =&gt; false

布尔值不区分大小写
整数 Integer

$int1 = 28;    # =&gt; 28$int2 = -32;   # =&gt; -32$int3 = 012;   # =&gt; 10 (octal)$int4 = 0x0F;  # =&gt; 15 (hex)$int5 = 0b101; # =&gt; 5  (binary)# =&gt; 2000100000 (decimal, PHP 7.4.0)$int6 = 2_000_100_000;

另见: Integers
字符串 Stringsecho &#x27;this is a simple string&#x27;;

查看: Strings
数组 Arrays$arr = array(&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;);

查看: Arrays
浮点数 Float (Double)$float1 = 1.234;$float2 = 1.2e7;$float3 = 7E-10;$float4 = 1_234.567;  // as of PHP 7.4.0var_dump($float4);    // float(1234.567)$float5 = 1 + &quot;10.5&quot;;   # =&gt; 11.5$float6 = 1 + &quot;-1.3e3&quot;; # =&gt; -1299

Null$a = null;$b = &#x27;Hello php!&#x27;;echo $a ?? &#x27;a is unset&#x27;; # =&gt; a is unsetecho $b ?? &#x27;b is unset&#x27;; # =&gt; Hello php$a = array();$a == null    # =&gt; true$a === null   # =&gt; falseis_null($a)   # =&gt; false

可迭代对象 Iterablesfunction bar(): iterable &#123;  return [1, 2, 3];&#125;function gen(): iterable &#123;  yield 1;  yield 2;  yield 3;&#125;foreach (bar() as $value) &#123;  echo $value;   # =&gt; 123&#125; 

PHP 字符串字符串 String# =&gt; &#x27;$String&#x27;$sgl_quotes = &#x27;$String&#x27;;# =&gt; &#x27;This is a $String.&#x27;$dbl_quotes = &quot;This is a $sgl_quotes.&quot;;# =&gt; a    tab character.$escaped   = &quot;a \t tab character.&quot;;# =&gt; a slash and a t: \t$unescaped = &#x27;a slash and a t: \t&#x27;;

多行 Multi-line$str = &quot;foo&quot;;// 未插值的多行$nowdoc = &lt;&lt;&lt;&#x27;END&#x27;Multi line string$strEND;// 将执行字符串插值$heredoc = &lt;&lt;&lt;ENDMulti line$strEND;

操作 Manipulation$s = &quot;Hello Phper&quot;;echo strlen($s);       # =&gt; 11echo substr($s, 0, 3); # =&gt; Helecho substr($s, 1);    # =&gt; ello Phperecho substr($s, -4, 3);# =&gt; hpeecho strtoupper($s);   # =&gt; HELLO PHPERecho strtolower($s);   # =&gt; hello phperecho strpos($s, &quot;l&quot;);      # =&gt; 2var_dump(strpos($s, &quot;L&quot;)); # =&gt; false

另见: 字符串函数
PHP 数组定义

$a1 = [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;]$a2 = array(&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;);$a3 = explode(&quot;,&quot;, &quot;apple,pear,peach&quot;);

混合 int 和 string 键$array = array(    &quot;foo&quot; =&gt; &quot;bar&quot;,    &quot;bar&quot; =&gt; &quot;foo&quot;,    100   =&gt; -100,    -100  =&gt; 100,);var_dump($array);

短数组语法$array = [    &quot;foo&quot; =&gt; &quot;bar&quot;,    &quot;bar&quot; =&gt; &quot;foo&quot;,];

多阵列$multiArray = [     [1, 2, 3],    [4, 5, 6],    [7, 8, 9],];print_r($multiArray[0][0]) # =&gt; 1print_r($multiArray[0][1]) # =&gt; 2print_r($multiArray[0][2]) # =&gt; 3

多类型

$array = array(    &quot;foo&quot; =&gt; &quot;bar&quot;,    42    =&gt; 24,    &quot;multi&quot; =&gt; array(         &quot;dim&quot; =&gt; array(             &quot;a&quot; =&gt; &quot;foo&quot;         )    ));# =&gt; string(3) &quot;bar&quot;var_dump($array[&quot;foo&quot;]);# =&gt; int(24)var_dump($array[42]);    # =&gt;  string(3) &quot;foo&quot;var_dump($array[&quot;multi&quot;][&quot;dim&quot;][&quot;a&quot;]);

操作$arr = array(5 =&gt; 1, 12 =&gt; 2);$arr[] = 56;      // 附加$arr[&quot;x&quot;] = 42;   // 用键添加sort($arr);       // 排序unset($arr[5]);   // 消除unset($arr);      // 移除所有

查看: 数组函数
索引迭代$array = array(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);$count = count($array);for ($i = 0; $i &lt; $count; $i++) &#123;    echo &quot;i:&#123;$i&#125;, v:&#123;$array[$i]&#125;\n&quot;;&#125;

价值迭代$colors = array(&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;);foreach ($colors as $color) &#123;    echo &quot;Do you like $color?\n&quot;;&#125;

关键迭代$arr = [&quot;foo&quot; =&gt; &quot;bar&quot;, &quot;bar&quot; =&gt; &quot;foo&quot;];foreach ( $arr as $key =&gt; $value )&#123;    echo &quot;key: &quot; . $key . &quot;\n&quot;;    echo &quot;val: &#123;$arr[$key]&#125;\n&quot;;&#125;

串联阵列$a = [1, 2];$b = [3, 4];// PHP 7.4 以后# =&gt; [1, 2, 3, 4]$result = [...$a, ...$b];

Into 函数$array = [1, 2];function foo(int $a, int $b) &#123;  echo $a; # =&gt; 1    echo $b; # =&gt; 2&#125;foo(...$array);

Splat运算符function foo($first, ...$other) &#123;  var_dump($first); # =&gt; a    var_dump($other); # =&gt; [&#x27;b&#x27;, &#x27;c&#x27;]&#125;foo(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27; /*, ...*/ );// 或function foo($first, string ...$other)&#123;&#125;

PHP 运算符算术


:-
-



+
添加


-
减法


*
乘法


/
分配


%
取模


**
求幂


分配


:-
-



a += b
如同 a = a + b


a -= b
如同 a = a – b


a *= b
如同 a = a * b


a /= b
如同 a = a / b


a %= b
如同 a = a % b


比较


:-
-



==
平等的


===
完全相同的


!=
不相等


&lt;&gt;
不相等


!==
不相同


&lt;
少于


&gt;
比…更棒


&lt;=
小于或等于


&gt;=
大于或等于


&lt;=&gt;
小于&#x2F;等于&#x2F;大于


逻辑的


:-
-



and
和


or
或者


xor
独家或


!
不是


&amp;&amp;
和


||
或者


算术// 算术$sum        = 1 + 1; // 2$difference = 2 - 1; // 1$product    = 2 * 2; // 4$quotient   = 2 / 1; // 2// 速记算术$num = 0;$num += 1;       // 将 $num 增加 1echo $num++;     // 打印 1（评估后的增量）echo ++$num;     // 打印 3（评估前的增量）$num /= $float;  // 将商除并分配给 $num

按位


:-
-



&amp;
和


&#96;
&#96;


^
异或（异或）


~
不是


&lt;&lt;
左移


&gt;&gt;
右移


PHP 条件If elseif else$a = 10;$b = 20;if ($a &gt; $b) &#123;    echo &quot;a is bigger than b&quot;;&#125; elseif ($a == $b) &#123;    echo &quot;a is equal to b&quot;;&#125; else &#123;    echo &quot;a is smaller than b&quot;;&#125;

Switch$x = 0;switch ($x) &#123;    case &#x27;0&#x27;:        print &quot;it&#x27;s zero&quot;;        break;     case &#x27;two&#x27;:    case &#x27;three&#x27;:        // do something        break;    default:        // do something&#125;

三元运算符# =&gt; Doesprint (false ? &#x27;Not&#x27; : &#x27;Does&#x27;);$x = false;# =&gt; Doesprint($x ?: &#x27;Does&#x27;);$a = null;$b = &#x27;Does print&#x27;;# =&gt; a is unsertecho $a ?? &#x27;a is unset&#x27;;# =&gt; printecho $b ?? &#x27;b is unset&#x27;;

匹配$statusCode = 500;$message = match($statusCode) &#123;  200, 300 =&gt; null,  400 =&gt; &#x27;未找到&#x27;,  500 =&gt; &#x27;服务器错误&#x27;,  default =&gt; &#x27;已知状态码&#x27;,&#125;;echo $message; # =&gt; 服务器错误

查看: Match
匹配表达式$age = 23;$result = match (true) &#123;    $age &gt;= 65 =&gt; &#x27;senior&#x27;,    $age &gt;= 25 =&gt; &#x27;adult&#x27;,    $age &gt;= 18 =&gt; &#x27;young adult&#x27;,    default =&gt; &#x27;kid&#x27;,&#125;;echo $result; # =&gt; young adult

PHP 循环while 循环$i = 1;# =&gt; 12345while ($i &lt;= 5) &#123;    echo $i++;&#125;

do while 循环$i = 1;# =&gt; 12345do &#123;    echo $i++;&#125; while ($i &lt;= 5);

for i 循环# =&gt; 12345for ($i = 1; $i &lt;= 5; $i++) &#123;    echo $i;&#125;

break 跳出循环# =&gt; 123for ($i = 1; $i &lt;= 5; $i++) &#123;    if ($i === 4) &#123;        break;    &#125;    echo $i;&#125;

continue 继续# =&gt; 1235for ($i = 1; $i &lt;= 5; $i++) &#123;    if ($i === 4) &#123;        continue;    &#125;    echo $i;&#125;

foreach 循环$a = [&#x27;foo&#x27; =&gt; 1, &#x27;bar&#x27; =&gt; 2];# =&gt; 12foreach ($a as $k) &#123;    echo $k;&#125;

查看: Array iteration
PHP 函数返回值function square($x)&#123;    return $x * $x;&#125;echo square(4);  # =&gt; 16

返回类型// 基本返回类型声明function sum($a, $b): float &#123;/*...*/&#125;function get_item(): string &#123;/*...*/&#125;class C &#123;&#125;// 返回一个对象function getC(): C &#123; return new C; &#125;

可空返回类型// 在 PHP 7.1 中可用function nullOrString(int $v) : ?string&#123;    return $v % 2 ? &quot;odd&quot; : null;&#125;echo nullOrString(3);       # =&gt; oddvar_dump(nullOrString(4));  # =&gt; NULL

查看: Nullable types
无效函数// 在 PHP 7.1 中可用function voidFunction(): void&#123;  echo &#x27;Hello&#x27;;  return;&#125;voidFunction();  # =&gt; Hello

变量函数function bar($arg = &#x27;&#x27;)&#123;    echo &quot;In bar(); arg: &#x27;$arg&#x27;.\n&quot;;&#125;$func = &#x27;bar&#x27;;$func(&#x27;test&#x27;); # =&gt; In bar(); arg: test

匿名函数$greet = function($name)&#123;    printf(&quot;Hello %s\r\n&quot;, $name);&#125;;$greet(&#x27;World&#x27;); # =&gt; Hello World$greet(&#x27;PHP&#x27;);   # =&gt; Hello PHP

递归函数function recursion($x)&#123;    if ($x &lt; 5) &#123;        echo &quot;$x&quot;;        recursion($x + 1);    &#125;&#125;recursion(1);  # =&gt; 1234

默认参数function coffee($type = &quot;cappuccino&quot;)&#123;    return &quot;Making a cup of $type.\n&quot;;&#125;# =&gt; 制作一杯卡布奇诺echo coffee();# =&gt; 制作一杯echo coffee(null);# =&gt; 制作一杯浓缩咖啡echo coffee(&quot;espresso&quot;);

箭头函数$y = 1; $fn1 = fn($x) =&gt; $x + $y;// 相当于按值使用 $y：$fn2 = function ($x) use ($y) &#123;    return $x + $y;&#125;;echo $fn1(5);   # =&gt; 6echo $fn2(5);   # =&gt; 6

PHP 类构造函数 Constructorclass Student &#123;    public function __construct($name) &#123;        $this-&gt;name = $name;    &#125;    public function print() &#123;        echo &quot;Name: &quot; . $this-&gt;name;    &#125;&#125;$alex = new Student(&quot;Alex&quot;);$alex-&gt;print();    # =&gt; Name: Alex

继承 Inheritanceclass ExtendClass extends SimpleClass&#123;    // 重新定义父方法    function displayVar()    &#123;        echo &quot;Extending class\n&quot;;        parent::displayVar();    &#125;&#125;$extended = new ExtendClass();$extended-&gt;displayVar();

类变量 Classes variables

class MyClass&#123;    const MY_CONST         = &#x27;value&#x27;;    static $staticVar      = &#x27;static&#x27;;    // 可见度    public static $var1    = &#x27;pubs&#x27;;    // 仅限类    private static $var2   = &#x27;pris&#x27;;    // 类和子类    protected static $var3 = &#x27;pros&#x27;;    // 类和子类    protected $var6        = &#x27;pro&#x27;;    // 仅限类    private $var7          = &#x27;pri&#x27;;  &#125;

静态访问
echo MyClass::MY_CONST;   # =&gt; valueecho MyClass::$staticVar; # =&gt; static

魔术方法class MyClass&#123;    // 对象被视为字符串    public function __toString()    &#123;        return $property;    &#125;    // 与 __construct() 相反    public function __destruct()    &#123;        print &quot;Destroying&quot;;    &#125;&#125;

接口interface Foo &#123;    public function doSomething();&#125;interface Bar&#123;    public function doSomethingElse();&#125;class Cls implements Foo, Bar &#123;    public function doSomething() &#123;&#125;    public function doSomethingElse() &#123;&#125;&#125;

各种各样的基本错误处理try &#123;    // 做一点事&#125; catch (Exception $e) &#123;    // 处理异常&#125; finally &#123;    echo &quot;Always print!&quot;;&#125;

PHP 8.0 中的异常
&#123;.wrap&#125;$nullableValue = null;try &#123;  $value = $nullableValue ?? throw new InvalidArgumentException();&#125; catch (InvalidArgumentException) &#123; // 变量是可选的    // 处理我的异常    echo &quot;print me!&quot;;&#125;

自定义异常
class MyException extends Exception &#123;    // 做一点事&#125;

用法
try &#123;    $condition = true;    if ($condition) &#123;        throw new MyException(&#x27;bala&#x27;);    &#125;&#125; catch (MyException $e) &#123;    // 处理我的异常&#125;

Nullsafe 运算符

// 从 PHP 8.0.0 开始，这一行：$result = $repo?-&gt;getUser(5)?-&gt;name;// 相当于下面的代码：if (is_null($repo)) &#123;    $result = null;&#125; else &#123;    $user = $repository-&gt;getUser(5);    if (is_null($user)) &#123;        $result = null;    &#125; else &#123;        $result = $user-&gt;name;    &#125;&#125;

另见: Nullsafe 运算符
常用表达$str = &quot;Visit jaywcjlove.github.io&quot;;echo preg_match(&quot;/qu/i&quot;, $str); # =&gt; 1

查看: PHP中的正则表达式
fopen() 模式


:-
-



r
读


r+
读写，前置


w
写入，截断


w+
读写，截断


a
写，追加


a+
读写，追加


运行时定义的常量define(&quot;CURRENT_DATE&quot;, date(&#x27;Y-m-d&#x27;));// 一种可能的表示echo CURRENT_DATE;   # =&gt; 2021-01-05# =&gt; CURRENT_DATE is: 2021-01-05echo &#x27;CURRENT_DATE is: &#x27; . CURRENT_DATE; 

另见
PHP 官方中文文档 (php.net)
Learn X in Y minutes (learnxinyminutes.com)

]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>后端编程</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>JQuery 备忘录</title>
    <url>/2025/01/08/jquery/</url>
    <content><![CDATA[jQuery 备忘清单jQuery 备忘单对于初学者和有经验的开发人员都是很好的参考
入门引入 jQuery&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js&quot;&gt;&lt;/script&gt;


官方 CDN&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.min.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;


jQuery 语法$(selector).methodOrFunction();

例子$(&#x27;#menu&#x27;).on(&#x27;click&#x27;, () =&gt;&#123;  $(this).hide();  &#125;);$(&quot;body&quot;).css(&quot;background&quot;, &quot;red&quot;);

jQuery 文档准备就绪$(document).ready(function() &#123;  // 在加载 DOM 后运行  alert(&#x27;DOM fully loaded!&#x27;);&#125;);

$(function()&#123;  // 在加载 DOM 后运行  alert(&#x27;DOM fully loaded!&#x27;);&#125;);

jQuery 选择器例子$(&quot;button&quot;).click(() =&gt; &#123;    $(&quot;:button&quot;).css(&quot;color&quot;, &quot;red&quot;);&#125;);

组合选择器$(&quot;selector1, selector2 ...selectorn&quot;)

基本
* 选择所有元素
.class 选择具有给定类的所有元素
element 选择具有给定标签名称的所有元素
#id 选择具有给定 id 属性的单个元素
:hidden 选择所有隐藏的元素
:visible 选择所有可见的元素
:contains() 选择包含指定文本的所有元素
:empty 选择所有没有子元素的元素(包括文本节点)
:has() 选择至少包含一个与指定选择器匹配的元素的元素
:parent 选择具有至少一个子节点(元素或文本)的所有元素
parent &gt; child 选择由父元素指定的子元素指定的所有直接子元素
ancestor descendant 选择作为给定祖先的后代的所有元素
prev + next 选择所有与 next 匹配且紧接在其前面的同级 prev 的下一个元素
prev ~ siblings 选择 prev 元素之后的所有同级元素，具有相同的父元素，并匹配过滤同级选择器



基本过滤器
:animated 在运行选择器时选择动画进度中的所有元素
:eq() 选择匹配集中索引 n 处的元素
:even 选择偶数元素，索引为零。 另见：奇数
:first 选择第一个匹配的 DOM 元素
:gt() 选择匹配集中索引大于索引的所有元素
:header 选择所有标题元素，如 h1、h2、h3 等
:lang() 选择指定语言的所有元素
:last 选择最后一个匹配的元素
:lt() 选择匹配集中索引小于索引的所有元素
:not() 选择与给定选择器不匹配的所有元素
:odd 选择奇数元素，索引为零。 另见：甚至
:root 选择作为文档根的元素
:target 选择由文档的 URI 的片段标识符指示的目标元素



属性
[name|&#x3D;”value”] 选择具有指定属性且值等于给定字符串或以该字符串开头后跟连字符 (-) 的元素
[name*&#x3D;”value”] 选择具有指定属性且值包含给定子字符串的元素
[name~&#x3D;”value”] 选择具有指定属性的元素，其值包含给定单词，由空格分隔
[name$&#x3D;”value”] 选择具有指定属性且值恰好以给定字符串结尾的元素。 比较区分大小写
[name&#x3D;”value”] 选择具有指定属性且值恰好等于特定值的元素
[name!&#x3D;”value”] 选择不具有指定属性或具有指定属性但不具有特定值的元素
[name^&#x3D;”value”] 选择具有指定属性且值恰好以给定字符串开头的元素
[name] 选择具有指定属性和任意值的元素
[name&#x3D;”value”] 匹配匹配所有指定属性过滤器的元素



子过滤器
:first-child 选择作为其父元素的第一个子元素的所有元素
:first-of-type 选择具有相同元素名称的兄弟姐妹中第一个的所有元素
:last-child 选择作为其父元素的最后一个子元素的所有元素
:last-of-type 选择具有相同元素名称的兄弟中最后一个的所有元素
:nth-child() 选择作为其父元素的第 n 个子元素的所有元素
:nth-last-child() 选择作为其父元素的第 n 个子元素的所有元素，从最后一个元素到第一个元素计数
:nth-last-of-type() 选择所有元素，这些元素是其父元素的第 n 个子元素，相对于具有相同元素名称的兄弟元素，从最后一个元素到第一个元素计数
:nth-of-type() 选择所有元素，这些元素是其父元素相对于具有相同元素名称的兄弟元素的第 n 个子元素
:only-child 选择作为其父元素的唯一子元素的所有元素
:only-of-type() 选择所有没有同名元素的元素



Forms
:button 选择所有按钮元素和按钮类型的元素
:checkbox 选择复选框类型的所有元素
:checked 匹配所有选中或选择的元素
:disabled 选择所有禁用的元素
:enabled 选择所有启用的元素
:focus 如果当前获得焦点，则选择元素
:file 选择类型文件的所有元素
:image 选择图像类型的所有元素
:input 选择所有输入、文本区域、选择和按钮元素
:password 选择密码类型的所有元素
:radio 选择无线电类型的所有元素
:reset 选择重置类型的所有元素
:selected 选择所有选中的元素
:submit 选择提交类型的所有元素
:text 选择文本类型的所有输入元素



jQuery 属性例子

$(&#x27;h2&#x27;).css(&#123;  color: &#x27;blue&#x27;,  backgroundColor: &#x27;gray&#x27;,  fontSize: &#x27;24px&#x27;&#125;);

jQuery 添加类$(&#x27;.button&#x27;).addClass(&#x27;active&#x27;); 

jQuery 移除类$(&#x27;.button&#x27;).on(&#x27;mouseleave&#x27;, evt =&gt; &#123;   let e = evt.currentTarget;   $(e).removeClass(&#x27;active&#x27;);&#125;);

jQuery 切换类$(&#x27;.choice&#x27;).toggleClass(&#x27;highlighted&#x27;);

Attributes
.attr() 获取匹配元素集中第一个元素的属性值
.prop() 获取匹配元素集中第一个元素的属性值
.removeAttr() 从匹配元素集中的每个元素中删除一个属性
.removeProp() 删除匹配元素集的属性
.val() 获取匹配元素集中第一个元素的当前值



Data
jQuery.data() 存储与指定元素关联的任意数据。 返回设置的值
.data() 存储与匹配元素关联的任意数据
jQuery.hasData() 确定一个元素是否有任何与之关联的 jQuery 数据
jQuery.removeData() 删除以前存储的数据
.removeData() 删除以前存储的数据



CSS
.addClass() 将指定的类添加到匹配元素集中的每个元素
.hasClass() 确定是否有任何匹配的元素被分配给给定的类
.removeClass() 从匹配元素集中的每个元素中删除单个类、多个类或所有类
.toggleClass() 根据类的存在或状态参数的值，从匹配元素集中的每个元素添加或删除一个或多个类
.css() 获取匹配元素集中第一个元素的计算样式属性
jQuery.cssHooks 直接连接到 jQuery 以覆盖特定 CSS 属性的检索或设置方式、标准化 CSS 属性命名或创建自定义属性
jQuery.cssNumber 包含所有可以在没有单位的情况下使用的 CSS 属性的对象。.css() 方法使用此对象来查看它是否可以将 px 附加到无单位值
jQuery.escapeSelector() 转义任何在 CSS 选择器中具有特殊含义的字符



Dimensions
.height() 获取匹配元素集中第一个元素的当前计算高度
.innerHeight() 获取匹配元素集中第一个元素的当前计算高度，包括填充但不包括边框
.innerWidth() 获取匹配元素集中第一个元素的当前计算内部宽度，包括填充但不包括边框
.outerHeight() 获取匹配元素集中第一个元素的当前计算外部高度(包括填充、边框和可选的边距)
.outerWidth() 获取匹配元素集中第一个元素的当前计算外部宽度(包括填充、边框和可选的边距)
.width() 获取匹配元素集中第一个元素的当前计算宽度



Offset
.offset() 获取匹配元素集中第一个元素相对于文档的当前坐标
.offsetParent() 获取定位的最近的祖先元素
.position() 获取匹配元素集中第一个元素相对于偏移父元素的当前坐标
.scrollLeft() 获取匹配元素集中第一个元素的滚动条的当前水平位置
.scrollTop() 获取匹配元素集中第一个元素的滚动条的当前垂直位置，或为每个匹配元素设置滚动条的垂直位置



jQuery 操控Examples

/*&lt;span&gt;Span.&lt;/span&gt;*/$(&#x27;span&#x27;).after(&#x27;&lt;p&gt;Paragraph.&lt;/p&gt;&#x27;);/*&lt;span&gt;Span.&lt;/span&gt;&lt;p&gt;Paragraph.&lt;/p&gt;*//*&lt;span&gt;Span.&lt;/span&gt;*/$(&#x27;&lt;span&gt;Span.&lt;/span&gt;&#x27;).replaceAll(&#x27;p&#x27;);/*&lt;p&gt;Span.&lt;/p&gt;*//*&lt;span&gt;This is span.&lt;/span&gt;*/$(&#x27;span&#x27;).wrap(&#x27;&lt;p&gt;&lt;/p&gt;&#x27;);/*&lt;p&gt;&lt;span&gt;This is span.&lt;/span&gt;&lt;/p&gt;*/

复刻
.clone() 创建匹配元素集的深层副本



DOM 插入，环绕
.wrap() 在匹配元素集中的每个元素周围包装一个 HTML 结构
.wrapAll() 在匹配元素集中的所有元素周围包装一个 HTML 结构
.wrapInner() 围绕匹配元素集中每个元素的内容包装一个 HTML 结构



DOM 插入，内部
.append() 在匹配的元素集中，插入由参数指定的内容插入每个元素的末尾
.appendTo() 将匹配元素集中的每个元素插入目标末端
.html() 在匹配元素集中获取第一个元素的HTML内容
.prepend() 插入由参数指定的内容插入匹配元素集中每个元素的开始
.prependTo() 将匹配元素集中的每个元素插入目标开始
.text() 在匹配的元素集（包括其后代）中获取每个元素的组合文本内容



DOM 插入，外部
.after() 在匹配元素集中的每个元素之后，插入由参数指定的内容
.before() 在匹配元素集中的每个元素之前，插入由参数指定的内容
.insertAfter() 在目标之后插入匹配元素集中的每个元素
.insertBefore() 在目标之前插入匹配元素集中的每个元素



DOM 移除
.detach() 从DOM上删除一组匹配的元素
.empty() 从DOM中删除一组匹配元素的所有子节点
.remove() 从DOM上删除一组匹配的元素
.unwrap() 从DOM上删除一组匹配元素的父母，将匹配的元素留在其位置



DOM 替换
.replaceAll() 用匹配的元素集替换每个目标元素
.replaceWith() 用提供的新内容替换一组匹配元素中的每个元素，然后返回已删除的元素集



jQuery 遍历过滤
.eq() 将匹配的元素集减少到指定索引处的集合
.filter() 将匹配的元素集减少到匹配选择器或传递函数测试的元素
.first() 将匹配的元素集减少到集合中的第一个
.has() 将匹配的元素集减少到具有与选择器或DOM元素相匹配的后代的元素
.is() 检查当前匹配的元素与选择器，元素或jQuery对象的元素集，如果至少其中一个元素与给定参数匹配，则返回true
.last() 将匹配的元素集减少到集合中的最后一个元素
.map() 将当前匹配的每个元素通过函数传递，从而产生包含返回值的新jQuery对象
.not() 从匹配元素集中删除元素
.slice() 将匹配的元素集减少为由一系列索引指定的子集



杂项遍历
.add() 创建一个新的jQuery对象，其中添加到匹配元素集中的元素
.addBack() 将堆栈上的上一个元素添加到当前集合中，并由选择器进行过滤
.andSelf() 将堆栈上的先前元素添加到当前集合中
.contents() 在一组匹配元素中获取每个元素的孩子，包括文本和评论节点
.each() 在jQuery对象上迭代，为每个匹配的元素执行一个函数
.end() 结束当前链中最新的过滤操作，并将匹配元素集返回其先前状态



树遍历
.children() 在一组匹配元素中获取每个元素的孩子，并被选择器进行过滤
.closest() 对于集合中的每个元素，通过测试元素本身并通过其祖先在DOM树中的祖先进行遍历来获取与选择器匹配的第一个元素
.find() 在当前匹配元素集中获取每个元素的后代，并由选择器，jQuery对象或元素过滤
.next() 在匹配的元素集中，立即获取每个元素的兄弟姐妹。 如果提供了选择器，则仅在匹配该选择器的情况下才能检索下一个兄弟姐妹
.nextAll() 在一组匹配元素中获取每个元素的所有以下兄弟姐妹，并由选择器进行过滤
.nextUntil() 将每个元素的所有以下兄弟姐妹添加到，但不包括通过选择器，DOM节点或jQuery对象匹配的元素
.parent() 在当前匹配元素集中获取每个元素的父，由选择器选择过滤
.parents() 在当前匹配元素集中获取每个元素的祖先，并被选择器进行过滤
.parentsUntil() 在当前匹配元素集中获取每个元素的祖先，直到但不包括由选择器，DOM节点或jQuery对象匹配的元素
.prev() 在匹配元素集中获取每个元素的立即兄弟姐妹。 如果提供了选择器，则仅在匹配该选择器时才检索先前的同胞
.prevAll() 在一组匹配元素中获取每个元素的所有先前兄弟姐妹，并由选择器进行过滤
.prevUntil() 将每个元素的所有先前兄弟姐妹添加到，但不包括由选择器，DOM节点或jQuery对象匹配的元素
.siblings() 在匹配的元素集中获取每个元素的兄弟姐妹，并被选择器进行过滤



jQuery 事件Examples

// 鼠标事件“点击”$(&#x27;#menu-button&#x27;).on(&#x27;click&#x27;, () =&gt; &#123;  $(&#x27;#menu&#x27;).show();&#125;);// 键盘事件“键盘”$(&#x27;#textbox&#x27;).on(&#x27;keyup&#x27;, () =&gt; &#123;  $(&#x27;#menu&#x27;).show();&#125;);// 滚动事件“滚动”$(&#x27;#menu-button&#x27;).on(&#x27;scroll&#x27;, () =&gt; &#123;  $(&#x27;#menu&#x27;).show();&#125;);

事件对象$(&#x27;#menu&#x27;).on(&#x27;click&#x27;, event =&gt; &#123;  $(event.currentTarget).hide();&#125;);

方法链$(&#x27;#menu-btn&#x27;).on(&#x27;mouseenter&#x27;, () =&gt; &#123;  $(&#x27;#menu&#x27;).show();&#125;).on(&#x27;mouseleave&#x27;, () =&gt; &#123;  $(&#x27;#menu&#x27;).hide();&#125;);

防止事件$( &quot;p&quot; ).click(function( event ) &#123;  event.stopPropagation();  // Do something&#125;);

浏览器事件
.error() 将事件处理程序绑定到错误 JavaScript 事件 
.resize() 将事件处理程序绑定到调整大小的 JavaScript 事件，或在元素上触发该事件 
.scroll() 将事件处理程序绑定到滚动 JavaScript 事件，或在元素上触发该事件 



事件对象


event.currentTarget 事件冒泡阶段中的当前 DOM 元素 
event.delegateTarget 附加了当前调用的 jQuery 事件处理程序的元素 
event.data 绑定当前正在执行的处理程序时传递给事件方法的可选数据对象 
event.isDefaultPrevented() 返回是否曾在此事件对象上调用过 event.preventDefault() 
event.isImmediatePropagationStopped() 返回是否曾在此事件对象上调用过 event.stopImmediatePropagation() 
event.isPropagationStopped() 返回是否曾在此事件对象上调用过 event.stopPropagation() 
event.metaKey 指示事件触发时是否按下了 META 键 
event.namespace 触发事件时指定的命名空间 
event.pageX 鼠标相对于文档左边缘的位置 
event.pageY 鼠标位置相对于文档的上边缘 
event.preventDefault() 如果调用该方法，则不会触发事件的默认动作 
event.relatedTarget 事件中涉及的其他 DOM 元素（如果有） 
event.result 由此事件触发的事件处理程序返回的最后一个值，除非该值未定义 
event.stopImmediatePropagation() 保持其余的处理程序不被执行，并防止事件在 DOM 树中向上冒泡 
event.stopPropagation() 防止事件在 DOM 树中向上冒泡，从而防止任何父处理程序收到事件通知 
event.target 发起事件的 DOM 元素 
event.timeStamp 浏览器创建事件的时间与 1970 年 1 月 1 日之间的毫秒差 
event.type 描述事件的性质 
event.which 对于键或鼠标事件，此属性指示按下的特定键或按钮 



文档加载
.load() 将事件处理程序绑定到加载 JavaScript 事件
.ready() 指定在 DOM 完全加载时执行的函数
.unload() 将事件处理程序绑定到卸载 JavaScript 事件



事件处理程序附件
.bind() 将处理程序附加到元素的事件
.delegate() 基于一组特定的根元素，将处理程序附加到现在或将来与选择器匹配的所有元素的一个或多个事件
.die() 从元素中删除先前使用 .live() 附加的事件处理程序
.live() 现在和将来为所有匹配当前选择器的元素附加一个事件处理程序
.off() 删除事件处理程序
.on() 将一个或多个事件的事件处理函数附加到所选元素
.one() 将处理程序附加到元素的事件。 每个事件类型的每个元素最多执行一次处理程序
.trigger() 执行附加到给定事件类型的匹配元素的所有处理程序和行为
.triggerHandler() 执行附加到事件元素的所有处理程序
.unbind() 从元素中删除先前附加的事件处理程序
.undelegate() 根据一组特定的根元素，从与当前选择器匹配的所有元素的事件中删除处理程序



形式事件
.blur() 将事件处理程序绑定到 blur JavaScript 事件，或在元素上触发该事件
.change() 将事件处理程序绑定到更改 JavaScript 事件，或在元素上触发该事件
.focus() 将事件处理程序绑定到焦点 JavaScript 事件，或在元素上触发该事件
.focusin() 将事件处理程序绑定到 focusin 事件
.focusout() 将事件处理程序绑定到 focusout JavaScript 事件
.select() 将事件处理程序绑定到 select JavaScript 事件，或在元素上触发该事件
.submit() 将事件处理程序绑定到提交 JavaScript 事件，或在元素上触发该事件



键盘事件
.keydown() 将事件处理程序绑定到 keydown JavaScript 事件，或在元素上触发该事件
.keypress() 将事件处理程序绑定到按键 JavaScript 事件，或在元素上触发该事件
.keyup() 将事件处理程序绑定到 keyup JavaScript 事件，或在元素上触发该事件



鼠标事件
.click() 将事件处理程序绑定到 click JavaScript 事件，或在元素上触发该事件
.contextMenu() 将事件处理程序绑定到 contextmenu JavaScript 事件，或在元素上触发该事件
.dblclick() 将事件处理程序绑定到 dblclick JavaScript 事件，或在元素上触发该事件
.hover() 将两个处理程序绑定到匹配的元素，当鼠标指针进入和离开元素时执行
.mousedown() 将事件处理程序绑定到 mousedown JavaScript 事件，或在元素上触发该事件
.mouseenter() 绑定要在鼠标进入元素时触发的事件处理程序，或在元素上触发该处理程序
.mouseleave() 绑定要在鼠标离开元素时触发的事件处理程序，或在元素上触发该处理程序
.mousemove() 将事件处理程序绑定到 mousemove JavaScript 事件，或在元素上触发该事件
.mouseout() 将事件处理程序绑定到 mouseout JavaScript 事件，或在元素上触发该事件
.mouseover() 将事件处理程序绑定到 mouseover JavaScript 事件，或在元素上触发该事件
.mouseup() 将事件处理程序绑定到 mouseup JavaScript 事件，或在元素上触发该事件
.toggle() 将两个或多个处理程序绑定到匹配的元素，以在交替单击时执行



jQuery Effects例子

$(&#x27;#menu-button&#x27;).on(&#x27;click&#x27;, () =&gt; &#123;  // $(&#x27;#menu&#x27;).fadeIn(400, &#x27;swing&#x27;)  $(&#x27;#menu&#x27;).fadeIn();&#125;);

淡出效果$(&#x27;#menu-button&#x27;).on(&#x27;click&#x27;, () =&gt; &#123;  // $(&#x27;#menu&#x27;).fadeOut(400, &#x27;swing&#x27;)  $(&#x27;#menu&#x27;).fadeOut();&#125;);

基本
.hide() 隐藏匹配的元素
.show() 显示匹配的元素
.toggle() 显示或隐藏匹配的元素



滑动
.slideDown() 以滑动方式显示匹配的元素
.slideToggle() 通过滑动显示或隐藏匹配的元素
.slideUp() 通过滑动隐藏匹配的元素



自定义
.animate() 执行一组 CSS 属性的自定义动画
.clearQueue() 从队列中删除所有尚未运行的项目
.delay() 设置一个计时器来延迟队列中后续项目的执行
.dequeue() 为匹配的元素执行队列上的下一个函数
jQuery.dequeue() 为匹配的元素执行队列上的下一个函数
.finish() 停止当前运行的动画，移除所有排队的动画，并完成匹配元素的所有动画
jQuery.fx.interval 动画触发的速率（以毫秒为单位）
jQuery.fx.off 全局禁用所有动画
jQuery.speed 创建一个对象，其中包含一组准备用于自定义动画定义的属性
.queue() 显示要在匹配元素上执行的函数队列
jQuery.queue() 显示要在匹配元素上执行的函数队列
.stop() 停止匹配元素上当前运行的动画



衰退
.fadeIn() 通过将匹配的元素淡化为不透明来显示它们
.fadeOut() 通过将它们淡化为透明来隐藏匹配的元素
.fadeTo() 调整匹配元素的不透明度
.fadeToggle() 通过设置不透明度动画来显示或隐藏匹配的元素



jQuery AjaxExamples

$.ajax(&#123;  url: this.action,  type: this.method,  data: $(this).serialize()&#125;).done(function(server_data)&#123;  console.log(&quot;success&quot; + server_data);&#125;).fail(function(jqXHR, status, err)&#123;  console.log(&quot;fail&quot; + err);&#125;);

全局 Ajax 事件处理程序
.ajaxComplete() 注册要在 Ajax 请求完成时调用的处理程序。 这是一个 AjaxEvent
.ajaxError() 注册一个处理程序，当 Ajax 请求完成但出现错误时调用。 这是一个 Ajax 事件
.ajaxSend() 附加一个要在发送 Ajax 请求之前执行的函数。 这是一个 Ajax 事件
.ajaxStart() 注册一个处理程序，在第一个 Ajax 请求开始时调用。 这是一个 Ajax 事件
.ajaxStop() 注册一个处理程序，在所有 Ajax 请求完成时调用。 这是一个 Ajax 事件
.ajaxSuccess() 附加一个要在 Ajax 请求成功完成时执行的函数。 这是一个 Ajax 事件



辅助功能
jQuery.param() 创建适合在 URL 查询字符串或 Ajax 请求中使用的数组、普通对象或 jQuery 对象的序列化表示。 如果传递了 jQuery 对象，它应该包含具有名称&#x2F;值属性的输入元素
.serialize() 将一组表单元素编码为字符串以供提交
.serializeArray() 将一组表单元素编码为名称和值的数组



底层接口
jQuery.ajax() 执行异步 HTTP (Ajax) 请求
jQuery.prefilter() 在发送每个请求之前和 $.ajax() 处理它们之前处理自定义 Ajax 选项或修改现有选项
jQuery.ajaxSetup() 为将来的 Ajax 请求设置默认值。 不推荐使用它
jQuery.ajaxTransport() 创建一个对象来处理 Ajax 数据的实际传输



速记方法
jQuery.get() 使用 HTTP GET 请求从服务器加载数据
jQuery.getJSON() 使用 GET HTTP 请求从服务器加载 JSON 编码的数据
jQuery.getScript() 使用 GET HTTP 请求从服务器加载 JavaScript 文件，然后执行它
jQuery.post() 使用 HTTP POST 请求将数据发送到服务器
.load() 从服务器加载数据并将返回的 HTML 放入匹配的元素中



各种各样的jQuery 对象
jQuery() 接受包含 CSS 选择器的字符串，然后用于匹配一组元
jQuery.noConflict() 放弃 jQuery 对 $ 变量的控
jQuery.sub() 创建一个新的 jQuery 副本，可以在不影响原始 jQuery 对象的情况下修改其属性和方
jQuery.holdReady() 持有或释放jQuery的就绪事件的执
jQuery.when() 提供一种基于零个或多个 Thenable 对象执行回调函数的方法，通常是表示异步事件的 Deferred 对



延迟对象


jQuery.Deferred() 返回可链接实用程序对象的工厂函数，该对象具有将多个回调注册到回调队列、调用回调队列以及中继任何同步或异步函数的成功或失败状态的方法
deferred.always() 添加要在延迟对象被解析或拒绝时调用的处理程序
deferred.done() 添加要在解析延迟对象时调用的处理程序
deferred.fail() 添加处理程序以在延迟对象被拒绝时调用
deferred.isRejected() 判断一个 Deferred 对象是否被拒绝
deferred.isResolved() 判断一个 Deferred 对象是否已经解析
deferred.notify() 使用给定的 args 在 Deferred 对象上调用 progressCallbacks
deferred.notifyWith() 使用给定的上下文和参数调用 Deferred 对象的 progressCallbacks
deferred.pipe() 过滤和&#x2F;或链接 Deferreds 的实用方法
deferred.progress() 添加在 Deferred 对象生成进度通知时要调用的处理程序
deferred.promise() 返回一个 Deferred 的 Promise 对象
deferred.reject() 拒绝 Deferred 对象并使用给定的 args 调用任何 failCallbacks
deferred.rejectWith() 拒绝 Deferred 对象并使用给定的上下文和参数调用任何 failCallbacks
deferred.resolve() 解析一个 Deferred 对象并使用给定的 args 调用任何 doneCallbacks
deferred.resolveWith() 解析延迟对象并使用给定的上下文和参数调用任何 doneCallbacks
deferred.state() 确定 Deferred 对象的当前状态
deferred.then() 添加要在延迟对象被解析、拒绝或仍在进行中时调用的处理程序
.promise() 返回一个 Promise 对象以观察绑定到集合的特定类型的所有操作（无论是否排队）何时完成



公用事业


jQuery.boxModel 说明用户浏览器中的当前页面是否正在使用 W3C CSS 盒模型呈现
jQuery.browser 包含用户代理的标志，从 navigator.userAgent 读取。 此属性在 jQuery 1.9 中被删除，只能通过 jQuery.migrate 插件使用。 请尝试改用特征检测
jQuery.contains() 检查一个 DOM 元素是否是另一个 DOM 元素的后代
jQuery.each() 通用迭代器函数，可用于无缝迭代对象和数组。 具有长度属性的数组和类似数组的对象（例如函数的参数对象）按数字索引迭代，从 0 到 length-1。 其他对象通过它们的命名属性迭代
jQuery.extend() 将两个或多个对象的内容合并到第一个对象中
jQuery.globalEval() 全局执行一些 JavaScript 代码
jQuery.grep() 查找满足过滤功能的数组元素。 原数组不受影响
jQuery.inArray() 在数组中搜索指定值并返回其索引（如果未找到，则返回 -1）
jQuery.isArray() 判断参数是否为数组
jQuery.isEmptyObject() 检查对象是否为空（不包含可枚举属性）
jQuery.isFunction() 确定其参数是否可作为函数调用
jQuery.isNumeric() 确定其参数是否表示 JavaScript 数字
jQuery.isPlainObject() 检查对象是否为普通对象
jQuery.isWindow() 判断参数是否为窗口
jQuery.isXMLDoc() 检查 DOM 节点是否在 XML 文档中（或者是 XML 文档）
jQuery.makeArray() 将类数组对象转换为真正的 JavaScript 数组
jQuery.map() 将数组或对象中的所有项转换为新的项数组
jQuery.merge() 将两个数组的内容合并到第一个数组中
jQuery.noop() 空函数
jQuery.now() 返回代表当前时间的数字
jQuery.parseHTML() 将字符串解析为 DOM 节点数组
jQuery.parseJSON() 获取格式正确的 JSON 字符串并返回生成的 JavaScript 值
jQuery.parseXML() 将字符串解析为 XML 文档
jQuery.proxy() 接受一个函数并返回一个总是有特定上下文的新函数
jQuery.support 表示存在不同浏览器功能或错误的属性集合。 用于 jQuery 的内部使用； 当内部不再需要特定属性以提高页面启动性能时，可能会删除它们。 对于您自己项目的功能检测需求，我们强烈建议使用外部库（例如 Modernizr），而不是依赖于 jQuery.support 中的属性
jQuery.trim() 删除字符串开头和结尾的空格
jQuery.type() 确定对象的内部 JavaScript [[Class]]
jQuery.unique() 对 DOM 元素数组进行适当的排序，并删除重复项。 请注意，这仅适用于 DOM 元素数组，不适用于字符串或数字
jQuery.uniqueSort() 对 DOM 元素数组进行适当的排序，并删除重复项。 请注意，这仅适用于 DOM 元素数组，不适用于字符串或数字



DOM 元素方法
.get() 检索与 jQuery 对象匹配的元素之一
.index() 从匹配的元素中搜索给定的元素
.size() 返回 jQuery 对象中元素的数量
.toArray() 检索 jQuery 集合中包含的所有元素，作为数组



内部结构
.jquery 包含 jQuery 版本号的字符串
.context 最初传递给 jQuery() 的 DOM 节点上下文； 如果未通过，则上下文可能是文档
jQuery.error() 获取一个字符串并抛出包含它的异常
.length jQuery 对象中元素的数量
.pushStack() 将一组 DOM 元素添加到 jQuery 堆栈中
.selector 代表选择器的选择器在创建原始集合时传递给 jQuery()，如果有的话



回调对象
jQuery.Callbacks() 一个多用途回调列表对象，提供了一种管理回调列表的强大方法
callbacks.add() 将回调或回调集合添加到回调列表
callbacks.disable() 禁止回调列表做更多的事情
callbacks.disabled() 确定回调列表是否已被禁用
callbacks.empty() 从列表中删除所有回调
callbacks.fire() 使用给定参数调用所有回调
callbacks.fired() 确定回调是否已至少被调用一次
callbacks.fireWith() 使用给定的上下文和参数调用列表中的所有回调
callbacks.has() 确定列表是否附加了任何回调。如果回调作为参数提供，请确定它是否在列表中
callbacks.lock() 将回调列表锁定在其当前状态
callbacks.locked() 判断回调列表是否被锁定
callbacks.remove() 从回调列表中删除回调或回调集合


]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>Pyhton备忘录</title>
    <url>/2025/01/08/pyhton%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[Python 3 备忘清单Python 备忘单是 Python 3 编程语言的单页参考表
入门介绍
Python 官方网站  (python.org)
Python 文档  (docs.python.org)
Y 分钟学会 Python (learnxinyminutes.com)
Python 中的正则表达式 (jaywcjlove.github.io)

控制台打印&gt;&gt;&gt; print(&quot;Hello, World!&quot;)Hello, World!

著名的“Hello World”程序在 Python 中的实现
变量age = 18       # 年龄是 int 类型name = &quot;John&quot;  # 名字现在是 str 类型print(name)


Python 不能在没有赋值的情况下声明变量
变量可以存放不同类型的值

内置数据类型
序列指一批有序的元素，集合指一批无序且不重复的元素



:-
:-



str
文本／字符串（Text）


int, float, complex
数值（Numeric）


dict
映射／键值对（Mapping）


list, tuple, range
序列（Sequence）


set, frozenset
集合（Set）


bool
布尔值／逻辑值（Boolean）


bytes, bytearray,  memoryview
二进制数据（Binary）


查看: 数据类型
字符串切片&gt;&gt;&gt; msg = &quot;Hello, World!&quot;&gt;&gt;&gt; print(msg[2:5])llo

查看: 字符串
列表mylist = []mylist.append(1)mylist.append(2)for item in mylist:    print(item) # 打印输出 1,2

查看: 列表
判断num = 200if num &gt; 0:    print(&quot;num is greater than 0&quot;)else:    print(&quot;num is not greater than 0&quot;)

查看: 判断
循环for item in range(6):    if item == 3: break    print(item)else:    print(&quot;Finally finished!&quot;)

查看: 循环
函数&gt;&gt;&gt; def my_function():...     print(&quot;来自函数的你好&quot;)...&gt;&gt;&gt; my_function()来自函数的你好

查看: 函数
文件处理

with open(&quot;myfile.txt&quot;, &quot;r&quot;, encoding=&#x27;utf8&#x27;) as file:    for line in file:        print(line)

查看: 文件处理
算术result = 10 + 30 # =&gt; 40result = 40 - 10 # =&gt; 30result = 50 * 5  # =&gt; 250result = 16 / 4  # =&gt; 4.0 (Float Division)result = 16 // 4 # =&gt; 4 (Integer Division)result = 25 % 2  # =&gt; 1result = 5 ** 3  # =&gt; 125

/ 表示 x 和 y 的商，// 表示 x 和 y 的底商，另见 StackOverflow
加等于counter = 0counter += 10           # =&gt; 10counter = 0counter = counter + 10  # =&gt; 10message = &quot;Part 1.&quot;# =&gt; Part 1.Part 2.message += &quot;Part 2.&quot;   

f-字符串 (Python 3.6+)&gt;&gt;&gt; website = &#x27;Quick Reference&#x27;&gt;&gt;&gt; f&quot;Hello, &#123;website&#125;&quot;&quot;Hello, Quick Reference&quot;&gt;&gt;&gt; num = 10&gt;&gt;&gt; f&#x27;&#123;num&#125; + 10 = &#123;num + 10&#125;&#x27;&#x27;10 + 10 = 20&#x27;

查看: f-字符串
Python 数据类型字符串hello = &quot;Hello World&quot;hello = &#x27;Hello World&#x27;multi_string = &quot;&quot;&quot;Multiline StringsLorem ipsum dolor sit amet,consectetur adipiscing elit &quot;&quot;&quot;

查看: 字符串
数值x = 1    # 整数y = 2.8  # 浮点小数z = 1j   # 复数&gt;&gt;&gt; print(type(x))&lt;class &#x27;int&#x27;&gt;

只要内存足够，可以容纳无限大(小)的数值
布尔值my_bool = True my_bool = Falsebool(0)     # =&gt; Falsebool(1)     # =&gt; True

bool 是 int 的子类
列表list1 = [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]list2 = [True, False, False]list3 = [1, 5, 7, 9, 3]list4 = list((1, 5, 7, 9, 3))

查看: 列表
元组my_tuple = (1, 2, 3)my_tuple = tuple((1, 2, 3))

类似列表，但自身不可变
集合set1 = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;   set2 = set((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))

类似列表，但里面的元素是无序而不重复的
字典&gt;&gt;&gt; empty_dict = &#123;&#125;&gt;&gt;&gt; a = &#123;&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3&#125;&gt;&gt;&gt; a[&quot;one&quot;]1&gt;&gt;&gt; a.keys()dict_keys([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])&gt;&gt;&gt; a.values()dict_values([1, 2, 3])&gt;&gt;&gt; a.update(&#123;&quot;four&quot;: 4&#125;)&gt;&gt;&gt; a.keys()dict_keys([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;])&gt;&gt;&gt; a[&#x27;four&#x27;]4

键-值对，一种像 JSON 那样对象
类型转换转换为整数x = int(1)       # 得到 1y = int(2.8)     # 得到 2z = int(&quot;3&quot;)     # 得到 3

转换为浮点数x = float(1)     # 得到 1.0y = float(2.8)   # 得到 2.8z = float(&quot;3&quot;)   # 得到 3.0w = float(&quot;4.2&quot;) # 得到 4.2

转换为字符串x = str(&quot;s1&quot;)    # 得到 &quot;s1&quot;y = str(2)       # 得到 &quot;2&quot;z = str(3.0)     # 得到 &quot;3.0&quot;

Python 字符串下标访问&gt;&gt;&gt; hello = &quot;Hello, World&quot;&gt;&gt;&gt; print(hello[1])  # 获取第二个字符e&gt;&gt;&gt; print(hello[-1])  # 获取倒数第一个字符d&gt;&gt;&gt; print(type(hello[-1]))  # 得到的还是字符串&lt;class &#x27;str&#x27;&gt;

循环&gt;&gt;&gt; for char in &quot;foo&quot;:...     print(char)foo

对字符串 for-in 可以得到每个字符（类型还是字符串）
切割字符串

 ┌───┬───┬───┬───┬───┬───┬───┐ | m | y | b | a | c | o | n | └───┴───┴───┴───┴───┴───┴───┘ 0   1   2   3   4   5   6   7-7  -6  -5  -4  -3  -2  -1


&gt;&gt;&gt; s = &#x27;mybacon&#x27;&gt;&gt;&gt; s[2:5]&#x27;bac&#x27;&gt;&gt;&gt; s[0:2]&#x27;my&#x27;


&gt;&gt;&gt; s = &#x27;mybacon&#x27;&gt;&gt;&gt; s[:2]&#x27;my&#x27;&gt;&gt;&gt; s[2:]&#x27;bacon&#x27;&gt;&gt;&gt; s[:2] + s[2:]&#x27;mybacon&#x27;&gt;&gt;&gt; s[:]&#x27;mybacon&#x27;


&gt;&gt;&gt; s = &#x27;mybacon&#x27;&gt;&gt;&gt; s[-5:-1]&#x27;baco&#x27;&gt;&gt;&gt; s[2:6]&#x27;baco&#x27;

步长&gt;&gt;&gt; s = &#x27;12345&#x27; * 5&gt;&gt;&gt; s&#x27;1234512345123451234512345&#x27;&gt;&gt;&gt; s[::5]&#x27;11111&#x27;&gt;&gt;&gt; s[4::5]&#x27;55555&#x27;&gt;&gt;&gt; s[::-5]&#x27;55555&#x27;&gt;&gt;&gt; s[::-1]&#x27;5432154321543215432154321&#x27;

获取长度&gt;&gt;&gt; hello = &quot;Hello, World!&quot;&gt;&gt;&gt; print(len(hello))13

len() 函数返回字符串的长度
重复多次&gt;&gt;&gt; s = &#x27;===+&#x27;&gt;&gt;&gt; n = 8&gt;&gt;&gt; s * n&#x27;===+===+===+===+===+===+===+===+&#x27;

存在性判断&gt;&gt;&gt; s = &#x27;spam&#x27;&gt;&gt;&gt; s in &#x27;I saw spamalot!&#x27;True&gt;&gt;&gt; s not in &#x27;I saw The Holy Grail!&#x27;True

判断 “spam” 这个字符串是否在其它字符串里
字符串拼接&gt;&gt;&gt; s = &#x27;spam&#x27;&gt;&gt;&gt; t = &#x27;egg&#x27;&gt;&gt;&gt; s + t  # 可以使用加号进行拼接&#x27;spamegg&#x27;&gt;&gt;&gt; &#x27;spam&#x27; &#x27;egg&#x27;  # 两个字符串之间可以省略加号&#x27;spamegg&#x27;

格式化

name = &quot;John&quot;print(&quot;Hello, %s!&quot; % name)


name = &quot;John&quot;age = 23print(&quot;%s is %d years old.&quot; % (name, age))

format() 方法txt1 = &quot;My name is &#123;fname&#125;, I&#x27;m &#123;age&#125;&quot;.format(fname=&quot;John&quot;, age=36)txt2 = &quot;My name is &#123;0&#125;, I&#x27;m &#123;1&#125;&quot;.format(&quot;John&quot;, 36)txt3 = &quot;My name is &#123;&#125;, I&#x27;m &#123;&#125;&quot;.format(&quot;John&quot;, 36)

转义符号




转义符号
对应的操作



\\
输出反斜杠


\&#39;
输出单引号


\&quot;
输出双引号


\n
换行


\t
水平制表符


\r
光标回到首位


\b
退格


控制台输入&gt;&gt;&gt; name = input(&quot;Enter your name: &quot;)Enter your name: Tom&gt;&gt;&gt; name&#x27;Tom&#x27;

从控制台获取输入数据
头尾判断

&gt;&gt;&gt; # 是否以 H 开头&gt;&gt;&gt; &quot;Hello, world!&quot;.startswith(&quot;H&quot;)True&gt;&gt;&gt; # 是否以 h 开头&gt;&gt;&gt; &quot;Hello, world!&quot;.startswith(&quot;h&quot;)False&gt;&gt;&gt; # 是否以 ! 结尾&gt;&gt;&gt; &quot;Hello, world!&quot;.endswith(&quot;!&quot;)True

插入分隔符拼接&gt;&gt;&gt; &quot;、&quot;.join([&quot;John&quot;, &quot;Peter&quot;, &quot;Vicky&quot;])&#x27;John、Peter、Vicky&#x27;

Python f-字符串 (Python 3.6+)f-字符串 用法

&gt;&gt;&gt; website = &#x27;Reference&#x27;&gt;&gt;&gt; f&quot;Hello, &#123;website&#125;&quot;&quot;Hello, Reference&quot;&gt;&gt;&gt; num = 10&gt;&gt;&gt; f&#x27;&#123;num&#125; + 10 = &#123;num + 10&#125;&#x27;&#x27;10 + 10 = 20&#x27;&gt;&gt;&gt; f&quot;&quot;&quot;He said &#123;&quot;I&#x27;m John&quot;&#125;&quot;&quot;&quot;&quot;He said I&#x27;m John&quot;&gt;&gt;&gt; f&#x27;5 &#123;&quot;&#123;stars&#125;&quot;&#125;&#x27;&#x27;5 &#123;stars&#125;&#x27;&gt;&gt;&gt; f&#x27;&#123;&#123;5&#125;&#125; &#123;&quot;stars&quot;&#125;&#x27;&#x27;&#123;5&#125; stars&#x27;&gt;&gt;&gt; name = &#x27;Eric&#x27;&gt;&gt;&gt; age = 27&gt;&gt;&gt; f&quot;&quot;&quot;Hello!...     I&#x27;m &#123;name&#125;....     I&#x27;m &#123;age&#125;.&quot;&quot;&quot;&quot;Hello!\n    I&#x27;m Eric.\n    I&#x27;m 27.&quot;

它从 Python 3.6 开始可用，另见: 格式字符串字面值
填充对齐&gt;&gt;&gt; f&#x27;&#123;&quot;text&quot;:10&#125;&#x27;   # 使用空格填充到指定长度&#x27;text      &#x27;&gt;&gt;&gt; f&#x27;&#123;&quot;test&quot;:*&gt;10&#125;&#x27; # 向左填充&#x27;******test&#x27;&gt;&gt;&gt; f&#x27;&#123;&quot;test&quot;:*&lt;10&#125;&#x27; # 向右填充&#x27;test******&#x27;&gt;&gt;&gt; f&#x27;&#123;&quot;test&quot;:*^10&#125;&#x27; # 居中填充&#x27;***test***&#x27;&gt;&gt;&gt; f&#x27;&#123;12345:0&gt;10&#125;&#x27;  # 使用数字填充&#x27;0000012345&#x27;

按类型输出

&gt;&gt;&gt; f&#x27;&#123;10:b&#125;&#x27;     # 输出二进制数值&#x27;1010&#x27;&gt;&gt;&gt; f&#x27;&#123;10:o&#125;&#x27;     # 输出八进制数值&#x27;12&#x27;&gt;&gt;&gt; f&#x27;&#123;200:x&#125;&#x27;    # 输出十六进制数值&#x27;c8&#x27;&gt;&gt;&gt; f&#x27;&#123;200:X&#125;&#x27;&#x27;C8&#x27;&gt;&gt;&gt; f&#x27;&#123;345600000000:e&#125;&#x27; # 科学计数法&#x27;3.456000e+11&#x27;&gt;&gt;&gt; f&#x27;&#123;65:c&#125;&#x27;       # 将整数转化为一个字符后输出&#x27;A&#x27;&gt;&gt;&gt; f&#x27;&#123;10:#b&#125;&#x27;      # [类型] 带符号（基础）&#x27;0b1010&#x27;&gt;&gt;&gt; f&#x27;&#123;10:#o&#125;&#x27;&#x27;0o12&#x27;&gt;&gt;&gt; f&#x27;&#123;10:#x&#125;&#x27;&#x27;0xa&#x27;

显示正负号&gt;&gt;&gt; f&#x27;&#123;12345:+&#125;&#x27;      # 显示正数的正号&#x27;+12345&#x27;&gt;&gt;&gt; f&#x27;&#123;-12345:+&#125;&#x27;     # 显示负数的负号&#x27;-12345&#x27;&gt;&gt;&gt; f&#x27;&#123;-12345:+10&#125;&#x27;   # 显示负号，并使用空格填充，直到长度为 10&#x27;    -12345&#x27;&gt;&gt;&gt; f&#x27;&#123;-12345:+010&#125;&#x27;  # 显示负号，并使用0填充，直到长度为 10&#x27;-000012345&#x27;

其它&gt;&gt;&gt; f&#x27;&#123;-12345:0=10&#125;&#x27;  # 负数&#x27;-000012345&#x27;&gt;&gt;&gt; f&#x27;&#123;12345:010&#125;&#x27;    # [0] 快捷方式（不对齐）&#x27;0000012345&#x27;&gt;&gt;&gt; f&#x27;&#123;-12345:010&#125;&#x27;&#x27;-000012345&#x27;&gt;&gt;&gt; import math       # [.precision]&gt;&gt;&gt; math.pi3.141592653589793&gt;&gt;&gt; f&#x27;&#123;math.pi:.2f&#125;&#x27;&#x27;3.14&#x27;&gt;&gt;&gt; f&#x27;&#123;1000000:,.2f&#125;&#x27; # [分组选项]&#x27;1,000,000.00&#x27;&gt;&gt;&gt; f&#x27;&#123;1000000:_.2f&#125;&#x27;&#x27;1_000_000.00&#x27;&gt;&gt;&gt; f&#x27;&#123;0.25:0%&#125;&#x27;      # 百分比&#x27;25.000000%&#x27;&gt;&gt;&gt; f&#x27;&#123;0.25:.0%&#125;&#x27;&#x27;25%&#x27;

Python 列表定义&gt;&gt;&gt; li1 = []&gt;&gt;&gt; li1[]&gt;&gt;&gt; li2 = [4, 5, 6]&gt;&gt;&gt; li2[4, 5, 6]&gt;&gt;&gt; li3 = list((1, 2, 3))&gt;&gt;&gt; li3[1, 2, 3]&gt;&gt;&gt; li4 = list(range(1, 11))&gt;&gt;&gt; li4[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

生成

&gt;&gt;&gt; list(filter(lambda x : x % 2 == 1, range(1, 20)))[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]&gt;&gt;&gt; [x ** 2 for x in range (1, 11) if  x % 2 == 1][1, 9, 25, 49, 81]&gt;&gt;&gt; [x for x in [3, 4, 5, 6, 7] if x &gt; 5][6, 7]&gt;&gt;&gt; list(filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7]))[6, 7]

添加元素&gt;&gt;&gt; li = []&gt;&gt;&gt; li.append(1)&gt;&gt;&gt; li[1]&gt;&gt;&gt; li.append(2)&gt;&gt;&gt; li[1, 2]&gt;&gt;&gt; li.append(4)&gt;&gt;&gt; li[1, 2, 4]&gt;&gt;&gt; li.append(3)&gt;&gt;&gt; li[1, 2, 4, 3]

切片

列表切片的语法：
a_list[start:end]a_list[start:end:step]

切片&gt;&gt;&gt; a = [&#x27;spam&#x27;, &#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;, &#x27;ham&#x27;, &#x27;lobster&#x27;]&gt;&gt;&gt; a[2:5][&#x27;bacon&#x27;, &#x27;tomato&#x27;, &#x27;ham&#x27;]&gt;&gt;&gt; a[-5:-2][&#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;]&gt;&gt;&gt; a[1:4][&#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;]

省略索引&gt;&gt;&gt; a[:4][&#x27;spam&#x27;, &#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;]&gt;&gt;&gt; a[0:4][&#x27;spam&#x27;, &#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;]&gt;&gt;&gt; a[2:][&#x27;bacon&#x27;, &#x27;tomato&#x27;, &#x27;ham&#x27;, &#x27;lobster&#x27;]&gt;&gt;&gt; a[2:len(a)][&#x27;bacon&#x27;, &#x27;tomato&#x27;, &#x27;ham&#x27;, &#x27;lobster&#x27;]&gt;&gt;&gt; a[&#x27;spam&#x27;, &#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;, &#x27;ham&#x27;, &#x27;lobster&#x27;]&gt;&gt;&gt; a[:][&#x27;spam&#x27;, &#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;, &#x27;ham&#x27;, &#x27;lobster&#x27;]

间隔索引[&#x27;spam&#x27;, &#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;, &#x27;ham&#x27;, &#x27;lobster&#x27;]&gt;&gt;&gt; a[0:6:2][&#x27;spam&#x27;, &#x27;bacon&#x27;, &#x27;ham&#x27;]&gt;&gt;&gt; a[1:6:2][&#x27;egg&#x27;, &#x27;tomato&#x27;, &#x27;lobster&#x27;]&gt;&gt;&gt; a[6:0:-2][&#x27;lobster&#x27;, &#x27;tomato&#x27;, &#x27;egg&#x27;]&gt;&gt;&gt; a[&#x27;spam&#x27;, &#x27;egg&#x27;, &#x27;bacon&#x27;, &#x27;tomato&#x27;, &#x27;ham&#x27;, &#x27;lobster&#x27;]&gt;&gt;&gt; a[::-1][&#x27;lobster&#x27;, &#x27;ham&#x27;, &#x27;tomato&#x27;, &#x27;bacon&#x27;, &#x27;egg&#x27;, &#x27;spam&#x27;]

删除&gt;&gt;&gt; li = [&#x27;bread&#x27;, &#x27;butter&#x27;, &#x27;milk&#x27;]&gt;&gt;&gt; li.pop()&#x27;milk&#x27;&gt;&gt;&gt; li[&#x27;bread&#x27;, &#x27;butter&#x27;]&gt;&gt;&gt; del li[0]&gt;&gt;&gt; li[&#x27;butter&#x27;]&gt;&gt;&gt; li.remove(&#x27;butter&#x27;)&gt;&gt;&gt; li[]

列表边界&gt;&gt;&gt; li = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]&gt;&gt;&gt; li[0]&#x27;a&#x27;&gt;&gt;&gt; li[-1]&#x27;d&#x27;&gt;&gt;&gt; li[4]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range

连接

&gt;&gt;&gt; odd = [1, 3, 5]&gt;&gt;&gt; odd.extend([9, 11, 13])&gt;&gt;&gt; odd[1, 3, 5, 9, 11, 13]&gt;&gt;&gt; odd = [1, 3, 5]&gt;&gt;&gt; odd + [9, 11, 13][1, 3, 5, 9, 11, 13]

排序和反转

&gt;&gt;&gt; li = [3, 1, 3, 2, 5]&gt;&gt;&gt; li.sort()&gt;&gt;&gt; li[1, 2, 3, 3, 5]&gt;&gt;&gt; li.reverse()&gt;&gt;&gt; li[5, 3, 3, 2, 1]

计数&gt;&gt;&gt; li = [3, 1, 3, 2, 5]&gt;&gt;&gt; li.count(3)2

重复&gt;&gt;&gt; li = [&quot;re&quot;] * 3&gt;&gt;&gt; li[&#x27;re&#x27;, &#x27;re&#x27;, &#x27;re&#x27;]

搜索&gt;&gt;&gt; nums = [40, 36, 89, 2, 36, 100, 7, -20.5, -999]&gt;&gt;&gt; nums.index(2)3&gt;&gt;&gt; nums.index(100, 3, 7)  # 搜索3-7之间的元素5&gt;&gt;&gt; nums.index(7, 4) # 搜索4之后的元素6

当寻找一个不存在的值时，抛出ValueError。
Python 判断if-elsenumber = int(input(&#x27;输入一个整数：&#x27;))if number &lt; 0:    print(&quot;您输入了一个负数。&quot;)else:    print(&quot;您输入了一个非负整数。&quot;)

if-elif-elsenumber = int(input(&#x27;输入一个整数：&#x27;))if number &lt; 0:    print(&quot;您输入了一个负数。&quot;)elif number == 0:    print(&quot;您输入了一个 0 。&quot;)else:    print(&quot;您输入了一个正数。&quot;)

三目运算scope = int(input(&#x27;输入百分制成绩：&#x27;))line = 60tip = &quot;及格&quot; if scope &gt;= line else &quot;不及格&quot;# 相当于 scope &gt;= line ? &quot;及格&quot; : &quot;不及格&quot;print(tip)

注意条件是放在中间的
Python 循环一般形式primes = [2, 3, 5, 7]for prime in primes:    print(prime)

带索引animals = [&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;]for i, value in enumerate(animals):    print(i, value)

while 循环x = 0while x &lt; 4:    print(x)    x += 1  # Shorthand for x = x + 1

跳出循环x = 0for index in range(10):    x = index * 10    if index == 5:        break    print(x)

跳过一轮循环for index in range(3, 8):     x = index * 10    if index == 5:        continue    print(x)

范围循环for i in range(4):    print(i) # Prints: 0 1 2 3for i in range(4, 8):    print(i) # Prints: 4 5 6 7for i in range(4, 10, 2):    print(i) # Prints: 4 6 8

使用 zip()name = [&#x27;Pete&#x27;, &#x27;John&#x27;, &#x27;Elizabeth&#x27;]age = [6, 23, 44]for n, a in zip(name, age):    print(&#x27;%s is %d years old&#x27; %(n, a))

列表生成式

result = [x**2 for x in range(10) if x % 2 == 0] print(result)# [0, 4, 16, 36, 64]

Python 函数基础def hello_world():      print(&#x27;Hello, World!&#x27;)

返回&#123;3&#125;def add(x, y):    print(&quot;x is %s, y is %s&quot; %(x, y))    return x + yadd(5, 6)    # =&gt; 11

位置参数def varargs(*args):    return argsvarargs(1, 2, 3)  # =&gt; (1, 2, 3)

args 的类型是 tuple
关键字参数def keyword_args(**kwargs):    return kwargs# =&gt; &#123;&quot;big&quot;: &quot;foot&quot;, &quot;loch&quot;: &quot;ness&quot;&#125;keyword_args(big=&quot;foot&quot;, loch=&quot;ness&quot;)

kwargs 的类型是 dict
返回多个def swap(x, y):    return y, xx = 1y = 2x, y = swap(x, y)  # =&gt; x = 2, y = 1

默认值def add(x, y=10):    return x + yadd(5)      # =&gt; 15add(5, 20)  # =&gt; 25

匿名函数# =&gt; True(lambda x: x &gt; 2)(3)# =&gt; 5(lambda x, y: x ** 2 + y ** 2)(2, 1)

Python 解包
解包是将一个序列内的多个元素依次重新分配到有限个容器的过程，这只发生在 变量赋值、参数传递 和 生成式生成 过程中。
_ 这个变量是命令行交互中最后一次计算得到的值，在程序设计中一般用来存放解包时不再需要的值。但它的含义会因赋值而改变，比如标准库 gettext 中常用作动态获取翻译文本。

等量解包ip, port = &quot;127.0.0.1&quot;, 80print(ip)  # -&gt; &quot;127.0.0.1&quot;print(port)  # -&gt; 80# 与以下代码等价ip, port = (&quot;127.0.0.1&quot;, 80)# 与以下代码效果相同ip, port = [&quot;127.0.0.1&quot;, 80]

适量解包ip, _, port = &quot;127.0.0.1:80&quot;.rpartition(&quot;:&quot;)print(ip)  # -&gt; &quot;127.0.0.1&quot;print(port)  # -&gt; &quot;80&quot;# _ 这个变量此刻的值是 &quot;:&quot; ，但一般不再使用。

_ 也是一个单一变量，不允许解包多个元素，因此变量与值必须一一对应。
过量解包major, minor, *parts = &quot;3.10.2.beta&quot;.split(&quot;.&quot;)print(major)  # -&gt; &quot;3&quot;print(minor)  # -&gt; &quot;10&quot;print(parts)  # -&gt; [&quot;2&quot;, &quot;beta&quot;]# 可将 parts 改为 _ 来表示不再需要后面的元素

这里的 * 就是收集序列在解包过程中多出来的元素，只能有一个，与向函数传递位置参数时的 * 别无二致。
解包取左边major, minor, *_ = &quot;3.10.2.beta&quot;.split(&quot;.&quot;)print(major)  # -&gt; &quot;3&quot;print(minor)  # -&gt; &quot;10&quot;

解包取两边major, *_, level = &quot;3.10.2.beta&quot;.split(&quot;.&quot;)print(major)  # -&gt; &quot;3&quot;print(level)  # -&gt; &quot;beta&quot;

解包取右边*_, micro, level = &quot;3.10.2.beta&quot;.split(&quot;.&quot;)print(micro)  # -&gt; &quot;2&quot;print(level)  # -&gt; &quot;beta&quot;

解包集合a, b, *_ = &#123;3, 2, 1&#125;print(a)  # -&gt; 1print(b)  # -&gt; 2print(_)  # -&gt; [3]

集合中的元素是无序的，因此解包结果不能轻易确定。
解包迭代器a, b, *_ = range(3)print(a)  # -&gt; 0print(b)  # -&gt; 1print(_)  # -&gt; [2]

支持迭代器协议的对象也可被解包。
解包字典a, b, *_ = dict(a=1, b=2, c=3)print(a)  # -&gt; &quot;a&quot;print(_)  # -&gt; [&quot;c&quot;]a, b, *_ = dict(a=1, b=2, c=3).values()print(a)  # -&gt; 1print(_)  # -&gt; [3]

生成式中的解包chars = (*&quot;abc&quot;, *&quot;def&quot;, &quot;g&quot;, &quot;h&quot;)# -&gt; (&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;)digits = [*range(10), *&quot;abcdef&quot;]# -&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9,#     &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]part = &#123;&quot;小明&quot;: 18, &quot;小亮&quot;: 22&#125;summary = &#123;&quot;小花&quot;: 16, **part&#125;print(summary)# -&gt; &#123;&quot;小花&quot;: 16, &quot;小明&quot;: 18, &quot;小亮&quot;: 22&#125;


仅在列表／元组生成式中可以使用多个 *
仅在字典生成式中可以使用多个 **

迭代中解包students = [    (&quot;小明&quot;, 18),    (&quot;小亮&quot;, 22),]for k, v in students:    print(k)  # -&gt; &quot;小明&quot;、&quot;小亮&quot;    print(v)  # -&gt; 18、22students = [    (0, (&quot;小明&quot;, 18)),    (1, (&quot;小亮&quot;, 22)),]for i, (k, v) in students:    print(i)  # -&gt; 0、1    print(k)  # -&gt; &quot;小明&quot;、&quot;小亮&quot;    print(v)  # -&gt; 18、22

函数中的解包def version(major, minor, *parts):    print(major)  # -&gt; &quot;3&quot;    print(minor)  # -&gt; &quot;10&quot;    print(parts)  # -&gt; (&quot;2&quot;, &quot;beta&quot;, &quot;0&quot;)version(&quot;3&quot;, &quot;10&quot;, &quot;2&quot;, &quot;beta&quot;, &quot;0&quot;)# 过程类似于major, minor, *parts = (&quot;3&quot;, &quot;10&quot;, &quot;2&quot;, &quot;beta&quot;, &quot;0&quot;)def version():    parts = &quot;3.10.2.beta.0&quot;.split(&quot;.&quot;)    return *parts, &quot;x64&quot;print(version())# -&gt; (&quot;3&quot;, &quot;10&quot;, &quot;2&quot;, &quot;beta&quot;, &quot;0&quot;, &quot;x64&quot;)

Python 模块导入模块import mathprint(math.sqrt(16))  # =&gt; 4.0

从一个模块导入from math import ceil, floorprint(ceil(3.7))   # =&gt; 4.0print(floor(3.7))  # =&gt; 3.0

导入一个模块的全部from math import *

给模块起别名import math as m# =&gt; Truemath.sqrt(16) == m.sqrt(16)

浏览模块的函数和属性import mathdir(math)

Python 文件处理读取文件逐行with open(&quot;myfile.txt&quot;) as file:    for line in file:        print(line)

带行号file = open(&#x27;myfile.txt&#x27;, &#x27;r&#x27;)for i, line in enumerate(file, start=1):    print(&quot;Number %s: %s&quot; % (i, line))

字符串写入一个字符串contents = &#123;&quot;aa&quot;: 12, &quot;bb&quot;: 21&#125;with open(&quot;myfile1.txt&quot;, &quot;w+&quot;) as file:    file.write(str(contents))

读取一个字符串with open(&#x27;myfile1.txt&#x27;, &quot;r+&quot;) as file:    contents = file.read()print(contents)

对象写一个对象contents = &#123;&quot;aa&quot;: 12, &quot;bb&quot;: 21&#125;with open(&quot;myfile2.txt&quot;, &quot;w+&quot;) as file:    file.write(json.dumps(contents))

读取对象with open(&#x27;myfile2.txt&#x27;, &quot;r+&quot;) as file:    contents = json.load(file)print(contents)

删除文件import osos.remove(&quot;myfile.txt&quot;)

检查和删除import osif os.path.exists(&quot;myfile.txt&quot;):    os.remove(&quot;myfile.txt&quot;)else:    print(&quot;The file does not exist&quot;)

删除文件夹import osos.rmdir(&quot;myfolder&quot;)

Python 类和继承定义class MyNewClass:    pass# 类的实例化my = MyNewClass()

构造函数class Animal:    def __init__(self, voice):        self.voice = voice cat = Animal(&#x27;Meow&#x27;)print(cat.voice)    # =&gt; Meow dog = Animal(&#x27;Woof&#x27;) print(dog.voice)    # =&gt; Woof

方法class Dog:    # 类的方法    def bark(self):        print(&quot;Ham-Ham&quot;) charlie = Dog()charlie.bark()   # =&gt; &quot;Ham-Ham&quot;

类变量

class MyClass:    class_variable = &quot;A class variable!&quot;# =&gt; 一个类变量！print(MyClass.class_variable)x = MyClass() # =&gt; 一个类变量！print(x.class_variable)

super() 函数

class ParentClass:    def print_test(self):        print(&quot;Parent Method&quot;) class ChildClass(ParentClass):    def print_test(self):        print(&quot;Child Method&quot;)        # 调用父级的 print_test()        super().print_test() 


&gt;&gt;&gt; child_instance = ChildClass()&gt;&gt;&gt; child_instance.print_test()Child MethodParent Method

repr() 方法class Employee:    def __init__(self, name):        self.name = name     def __repr__(self):        return self.name john = Employee(&#x27;John&#x27;)print(john)  # =&gt; John

用户定义的异常class CustomError(Exception):    pass

多态性class ParentClass:    def print_self(self):        print(&#x27;A&#x27;) class ChildClass(ParentClass):    def print_self(self):        print(&#x27;B&#x27;) obj_A = ParentClass()obj_B = ChildClass() obj_A.print_self() # =&gt; Aobj_B.print_self() # =&gt; B

重写class ParentClass:    def print_self(self):        print(&quot;Parent&quot;) class ChildClass(ParentClass):    def print_self(self):        print(&quot;Child&quot;) child_instance = ChildClass()child_instance.print_self() # =&gt; Child

继承class Animal:     def __init__(self, name, legs):        self.name = name        self.legs = legs        class Dog(Animal):    def sound(self):        print(&quot;Woof!&quot;) Yoki = Dog(&quot;Yoki&quot;, 4)print(Yoki.name) # =&gt; YOKIprint(Yoki.legs) # =&gt; 4Yoki.sound()     # =&gt; Woof!

Python 数据模型更多请移步 https://docs.python.org/zh-cn/3/reference/datamodel.html
自定义类创建参见 自定义类创建 。
from typing import Anyclass Object:    def __new__(cls, *args, **kwargs) -&gt; &quot;self&quot;:        # new 和 init 声明的参数必须一致        # 或者用 *args 和 **kwargs 进行兼容        return object.__new__(cls)    def __init__(self, *args, **kwargs):        # 初始化方法没有返回值，也不能返回值。        pass    def __call__(self, *args, **kwargs) -&gt; Any:        pass# 依次调用了 new 和 init，所以如果# 手动调用 new，那么别忘了调用 initobj = Object()# 触发 __call__ 方法，要给什么参数取决于声明obj()

上下文管理器
参见 上下文管理器 。
from typing import Anyclass Object:    def __enter__(self) -&gt; Optional[Any]:        # with 语句会将返回值绑定到 as 子句中的变量，如果有的话。        return    def __exit__(self, exc_type, exc_value, traceback):        # 若 with 内没有发生异常，则三个参数都是 None 。        # 不应该重新引发传入的异常，这是调用者的责任。        passwith Object() as alias:    # 进入 with 之前调用 obj.__enter__() 并得到 alias（如果有返回的话）    pass# 离开 with 后调用 obj.__exit__() ，不管是正常结束还是因异常抛出而离开。# 当需要获取 Object 的对象时可以这样写obj = Object()with obj as alias:    pass

特殊方法
下表使用 -&gt; * 代表返回值类型是任意的，或者需要视情况而定，实际上并不存在这种写法。诸如 -&gt; str 仅表示绝大多数情况下应当返回 str 类型，或者推荐返回 str 类型。没有 -&gt; 的方法一般没有返回值。参见 https://docs.python.org/zh-cn/3/reference/datamodel.html



语句
特殊方法
备注




repr(obj)
__repr__(self) -&gt; str
详见 repr() 。



str(obj)
__str__(self) -&gt; str
详见 str 类型 。



bytes(obj)
__bytes__(self) -&gt; bytes
详见 bytes() 。



format(obj, spec)
__format__(self, spec) -&gt; str
详见 format()、格式化字符串字面值、格式规格迷你语言 。



hash(obj)
__hash__(self) -&gt; int
详见 hash() 。



bool(obj)
__bool__(self) -&gt; bool
未定义时调用 obj.__len__() != 0 ，若 __len__() 也未定义，则所有对象都被视为 True 。另见 bool() 。



dir(obj)
__dir__(self) -&gt; list
返回值必须是一个序列，dir() 会把返回的序列转换为列表并对其排序。



Object[key]
__class_getitem__(cls, key) -&gt; *
不建议用于除了 模拟泛型类型 以外的用途，避免 IDE 误判。




自定义实例及子类检查，参见 https://docs.python.org/zh-cn/3/reference/datamodel.html#customizing-instance-and-subclass-checks




语句
特殊方法
备注




isinstance(instance, class)
class.__instancecheck__(self, instance) -&gt; bool
如果 instance 应被视为 class 的一个（直接或间接）实例则返回真值。



issubclass(subclass, class)
class.__subclasscheck__(self, subclass) -&gt; bool
如果 subclass 应被视为 class 的一个（直接或间接）子类则返回真值。




“富比较”方法，参见 https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__lt__




语句
特殊方法
备注




obj &lt; other
__lt__(self, other) -&gt; bool




obj &lt;= other
__le__(self, other) -&gt; bool




obj == other
__eq__(self, other) -&gt; bool
默认返回 obj is other ，如果结果为 False ，则会返回 NotImplemented 。



obj != other
__ne__(self, other) -&gt; bool
默认返回 not obj.__eq__(other) 。



obj &gt; other
__gt__(self, other) -&gt; bool




obj &gt;= other
__ge__(self, other) -&gt; bool





自定义属性访问，参见 https://docs.python.org/zh-cn/3/reference/datamodel.html#customizing-attribute-access




语句
特殊方法
备注




obj.name
__getattr__(self, name) -&gt; *
优先调用。当抛出 AttributeError 时转向调用 __getattribute__() 。



obj.name
__getattribute__(self, name) -&gt; *
参见 自定义属性访问 避免无限递归。



obj.name = value
__setattr__(self, name, value)




del obj.name
__delattr__(self, name)
仅在 del obj.name 对于该对象有意义时才应该被实现。




模拟容器类型，参见 https://docs.python.org/zh-cn/3/reference/datamodel.html#emulating-container-types




语句
特殊方法
备注




len(obj)
__len__(self) -&gt; int




op.length_hint(obj)
__length_hint__(self) -&gt; int
在使用标准库 operator 的 length_hint() 时会被调用（Python 3.4+）。



obj[key]
__getitem__(self, key) -&gt; *
需要抛出 IndexError 以便正确地结束 for 循环。



obj[key]
__missing__(self, key) -&gt; *
仅在 dict 的子类找不到键时被调用（不能重写 __getitem__ 方法）。



obj[key] = value
__setitem__(self, key, value)
a[1:2] = b 实际上是 a[slice(1, 2, None)] = b ，其它情形及在其余方法中同理。详见 slice() 。



del obj[key]
__delitem__(self, key)




调用途径有很多
__iter__(self) -&gt; Iterator
在需要创建一个 迭代器 时被调用，例如使用 iter() 、 for 循环 。最好返回一个新对象，因为迭代器在语义上是一次性的。若返回 self ，则必须实现 __next__() 方法。



reversed(obj)
__reversed__(self) -&gt; *
详见 reversed() 。



item in obj
__contains__(self, item) -&gt; bool
对于未定义该方法的对象在 in 和 not in 时，参考 成员检测运算 。




模拟数字类型，参见 https://docs.python.org/zh-cn/3/reference/datamodel.html#emulating-numeric-types




语句
特殊方法
备注




+obj
__neg__(self) -&gt; *




-obj
__pos__(self) -&gt; *




~obj
__invert__(self) -&gt; *




abs(obj)
__abs__(self) -&gt; *




int(obj)
__int__(self) -&gt; *




float(obj)
__float__(self) -&gt; *




complex(obj)
__complex__(self) -&gt; *




round(obj)
__round__(self) -&gt; int
详见 round() 。



round(obj)
__round__(self, ndigits) -&gt; *
详见 round() 。



math.ceil(obj)
__ceil__(self) -&gt; int
详见标准库 math 的 ceil() 。



math.floor(obj)
__floor__(self) -&gt; int
详见标准库 math 的 floor() 。



math.trunc(obj)
__trunc__(self) -&gt; int
详见标准库 math 的 trunc() 。




__index__(self) -&gt; int
需要无损地将数值转换为整数的时候会被调用。详见 这里 。



obj + other
__add__(self, other) -&gt; *




obj - other
__sub__(self, other) -&gt; *




obj * other
__mul__(self, other) -&gt; *




obj @ other
__matmul__(self, other) -&gt; *
为第三方库而生的矩阵乘法运算符，这里提了一嘴。（Python 3.5+）



obj / other
__truediv__(self, other) -&gt; *




obj // other
__floordiv__(self, other) -&gt; *




obj % other
__mod__(self, other) -&gt; *




divmod(obj, other)
__divmod__(self, other) -&gt; tuple
divmod(a, b) 返回一个元组 (a // b, a % b) ，详见 divmod() 。



obj ** exp
__pow__(self, exp) -&gt; *




pow(obj, exp, mod)
__pow__(self, exp, mod) -&gt; *
pow(base, exp, mod) 比 pow(base, exp) % mod 更高效。



obj &lt;&lt; other
__lshift__(self, other) -&gt; *




obj &gt;&gt; other
__rshift__(self, other) -&gt; *




obj &amp; other
__and__(self, other) -&gt; *




obj ^ other
__xor__(self, other) -&gt; *




obj | other
__or__(self, other) -&gt; *




other + obj
__radd__(self, obj) -&gt; *
仅当 obj 未定义 __add__() 或其返回 NotImplemented ，且与 other 互相都没有继承关系时，调用 other 的 __radd__() 。详见 这里 。



other - obj
__rsub__(self, obj) -&gt; *
以下，如此类推。



other * obj
__rmul__(self, obj) -&gt; *




other @ obj
__rmatmul__(self, obj) -&gt; *




other / obj
__rtruediv__(self, obj) -&gt; *




other // obj
__rfloordiv__(self, obj) -&gt; *




other % obj
__rmod__(self, obj) -&gt; *




divmod(other, obj)
__rdivmod__(self, obj) -&gt; tuple




other ** obj
__rpow__(self, obj) -&gt; *





__rpow__(self, obj, mod) -&gt; *
pow(obj, other, mod) 不会尝试调用 other.__rpow__(obj, mod) ，因为强制转换规则会太过复杂。



other &lt;&lt; obj
__rlshift__(self, obj) -&gt; *




other &gt;&gt; obj
__rrshift__(self, obj) -&gt; *




other &amp; obj
__rand__(self, obj) -&gt; *




other ^ obj
__rxor__(self, obj) -&gt; *




other | obj
__ror__(self, obj) -&gt; *




obj += other
__iadd__(self, other) -&gt; *
若方法已定义，则 a += b 等价于 a.__iadd(b) ；若未定义，则回退到 a + b 选择 x.__add__(y) 和 y.__radd__(x) 。



obj -= other
__isub__(self, other) -&gt; *
以下，如此类推。



obj *= other
__imul__(self, other) -&gt; *




obj @= other
__imatmul__(self, other) -&gt; *




obj /= other
__itruediv__(self, other) -&gt; *




obj //= other
__ifloordiv__(self, other) -&gt; *




obj %= other
__imod__(self, other) -&gt; *




obj **= exp
__ipow__(self, other) -&gt; *




obj &lt;&lt;= other
__ilshift__(self, other) -&gt; *




obj &gt;&gt;= other
__irshift__(self, other) -&gt; *




obj &amp;= other
__iand__(self, other) -&gt; *




obj ^= other
__ixor__(self, other) -&gt; *




obj |= other
__ior__(self, other) -&gt; *




Python 类型标注 (Python 3.5+)变量string: str = &quot;ha&quot;times: int = 3print(string * times)  # =&gt; hahaha

变量result: str = 1 + 2print(result)  # =&gt; 3

错误的类型标注不会影响正常运行，也不会报错
参数def say(name: str, start: str = &quot;Hi&quot;):    return start + &quot;, &quot; + nameprint(say(&quot;Python&quot;))  # =&gt; Hi, Python

位置参数def calc_summary(*args: int):    return sum(args)print(calc_summary(3, 1, 4))  # =&gt; 8

表示 args 的所有元素都是 int 类型的。
返回值def say_hello(name) -&gt; str:    return &quot;Hello, &quot; + namevar = &quot;Python&quot;print(say_hello(var))  # =&gt; Hello, Python

多种可能的返回值from typing import Uniondef resp200(meaningful) -&gt; Union[int, str]:    return &quot;OK&quot; if meaningful else 200

表示返回值可能是 int，也可能是 str 。
关键字参数def calc_summary(**kwargs: int):    return sum(kwargs.values())print(calc_summary(a=1, b=2))  # =&gt; 3

表示 kwargs 的所有值都是 int 类型的。
多个返回值def resp200() -&gt; (int, str):    return 200, &quot;OK&quot;

多种可能的返回值 (3.10+)def resp200(meaningful) -&gt; int | str:    return &quot;OK&quot; if meaningful else 200

自 Python 3.10 起可用。
属性class Employee:    name: str    age: int    def __init__(self, name, age):        self.name = name        self.age = age        self.graduated: bool = False

标注自己class Employee:    name: str    age: int    def set_name(self, name) -&gt; &quot;Employee&quot;:        self.name = name        return self

这里表示 set_name() 返回了一个 Employee 对象。
标注自己 (3.11+)from typing import Selfclass Employee:    name: str    age: int    def set_name(self: Self, name) -&gt; Self:        self.name = name        return self

标注一个值为类型的参数
from typing import TypeVar, TypeT = TypeVar(&quot;T&quot;)# &quot;mapper&quot; 的值是一个像 int、str、MyClass 这样的类型# &quot;default&quot; 是一个 T 类型的值，比如 314、&quot;string&quot;、MyClass()# 函数的返回值也是一个 T 类型的值def converter(raw, mapper: Type[T], default: T) -&gt; T:    try:        return mapper(raw)    except:        return defaultraw: str = input(&quot;请输入一个整数：&quot;)result: int = converter(raw, mapper=int, default=0)

标注一个值为函数的参数

from typing import TypeVar, Callable, AnyT = TypeVar(&quot;T&quot;)def converter(raw, mapper: Callable[[Any], T], default: T) -&gt; T:    try:        return mapper(raw)    except:        return default# Callable[[Any], T] 表示值是一个像这样声明的函数:# def anynomous(arg: Any) -&gt; T:#     passdef is_success(value) -&gt; bool:    return value in (0, &quot;OK&quot;, True, &quot;success&quot;)resp = dict(code=0, message=&quot;OK&quot;, data=[])successed: bool = converter(resp.message, mapper=is_success, default=False)

各种各样的注释# 这是单行注释


&quot;&quot;&quot; 可以写多行字符串    使用三个&quot;，并且经常使用    作为文档。&quot;&quot;&quot;


&#x27;&#x27;&#x27; 可以写多行字符串    使用三个&#x27;，并且经常使用    作为文档。&#x27;&#x27;&#x27;

生成器def double_numbers(iterable):    for i in iterable:        yield i + i

生成器可帮助您编写惰性代码
要列出的生成器values = (-x for x in [1,2,3,4,5])gen_to_list = list(values)# =&gt; [-1, -2, -3, -4, -5]print(gen_to_list)

处理异常

try:    # 使用“raise”来引发错误    raise IndexError(&quot;这是一个索引错误&quot;)except IndexError as e:    pass                 # pass只是一个空操作。 通常你会在这里做恢复。except (TypeError, NameError):    pass                 # 如果需要，可以一起处理多个异常。else:                    # try/except 块的可选子句。 必须遵循除块之外的所有内容    print(&quot;All good!&quot;)   # 仅当 try 中的代码未引发异常时运行finally:                 # 在所有情况下执行    print(&quot;我们可以在这里清理资源&quot;)

pyenv &amp; pipenv

pvenv 用于管理python版本，pipenv 用于管理项目包版本
pyenv# 安装 pyenvcurl https://pyenv.run | bash

更多安装方式
# 安装 python 版本pyenv install 3.10.12# 设置 python 版本pyenv global 3.10.12 # 全局设置pyenv shell  3.10.12 # 针对当前 shell sessionpyenv local  3.10.12 # 针对当前目录 

pipenv# 安装 pipenvpip install pipenv --user  # pipbrew install pipenv        # homebrew# 更新 pipenvpip install --user --upgrade pipenv # pipbrew upgrade pipenv                 # homebrew

# 将 pipenv 命令加入到系统环境变量 $PATH 中 (Unix and MacOS)dir=$(python -c &#x27;import site; print(site.USER_BASE + &quot;/bin&quot;)&#x27;) # 打印 python site-packages bin 路径echo &#x27;export PATH=&quot;&#x27;$dir&#x27;:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc # 将 dir 路径加入到 PATH 中source ~/.zshrc# 安装 packagepipenv install &lt;package name&gt; # 不指定版本pipenv install &lt;package name&gt;==&lt;version&gt;    # 精确指定版本pipenv install &lt;package name&gt;~=&lt;version&gt;    # 指定版本范围，例如 1.1则表示安装1.x的最新版本，1.0.1则表示安装1.0.x的最新版本pipenv install &quot;&lt;package name&gt;=&lt;version&gt;&quot;   # 大于等于指定版本pipenv install &quot;&lt;package name&gt;=&lt;version&gt;&quot;   # 小于等于指定版本

# 指定 python 版本pipenv --python 3.10.12# 激活当前目录虚拟环境pipenv shell

另见
Python 官方网站  (python.org)
Python 文档  (docs.python.org)
Y 分钟学会 Python (learnxinyminutes.com)
Python 中的正则表达式 (jaywcjlove.github.io)

]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>后端编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3 备忘录</title>
    <url>/2025/01/08/vue%20(1)/</url>
    <content><![CDATA[Vue 3 备忘清单
渐进式 JavaScript 框架 Vue 3 备忘清单的快速参考列表，包含常用 API 和示例


入门介绍Vue 是一套用于构建用户界面的渐进式框架

Vue 3.x 官方文档 (cn.vuejs.org)
Vue Router 4.x 官方文档 (router.vuejs.org)
Vue 2 备忘清单



注意：Vue 3.x 版本对应 Vue Router 4.x 路由版本
创建应用

已安装 16.0 或更高版本的 Node.js
$ npm init vue@latest

指令将会安装并执行 create-vue，它是 Vue 官方的项目脚手架工具
✔ Project name: … &lt;your-project-name&gt;✔ Add TypeScript? … No/Yes✔ Add JSX Support? … No/Yes✔ Add Vue Router for Single Page Application development? … No/Yes✔ Add Pinia for state management? … No/Yes✔ Add Vitest for Unit testing? … No/Yes✔ Add Cypress for both Unit and End-to-End testing? … No/Yes✔ Add ESLint for code quality? … No/Yes✔ Add Prettier for code formatting? … No/YesScaffolding project in ./&lt;your-project-name&gt;...Done.


安装依赖并启动开发服务器
$ cd &lt;your-project-name&gt;$ npm install$ npm run dev

当你准备将应用发布到生产环境时，请运行：
$ npm run build

此命令会在 ./dist 文件夹中为你的应用创建一个生产环境的构建版本
应用实例

import &#123; createApp, ref &#125; from &#x27;vue&#x27;const app = createApp(&#123;  setup() &#123;    const message = ref(&quot;Hello Vue3&quot;)    return &#123;      message    &#125;  &#125;&#125;)app.mount(&#x27;#app&#x27;)

挂载应用
&lt;div id=&quot;app&quot;&gt;  &lt;button @click=&quot;count++&quot;&gt;    &#123;&#123; count &#125;&#125;  &lt;/button&gt;&lt;/div&gt;

通过 CDN 使用 Vue&lt;script src=&quot;https://unpkg.com/vue@3/dist/vue.global.js&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt;  const &#123; createApp, ref &#125; = Vue  createApp(&#123;    setup() &#123;      const message = ref(&quot;Hello Vue3&quot;)      return &#123;        message      &#125;    &#125;  &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt;


使用 ES 模块构建版本&lt;div id=&quot;app&quot;&gt;&#123;&#123; message, ref &#125;&#125;&lt;/div&gt;&lt;script type=&quot;module&quot;&gt;  import &#123; createApp, ref &#125; from &#x27;https://unpkg.com/vue@3/dist/vue.esm-browser.js&#x27;  createApp(&#123;    setup() &#123;      const message = ref(&quot;Hello Vue3&quot;)      return &#123;        message      &#125;    &#125;  &#125;).mount(&#x27;#app&#x27;)&lt;/script&gt;


模板语法文本插值&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;

使用的是 Mustache 语法 (即双大括号)，每次 msg 属性更改时它也会同步更新
原始 HTML

&lt;p&gt;Using text interpolation: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;

双大括号&#123;&#123;&#125;&#125;会将数据解释为纯文本，使用 v-html 指令，将插入 HTML
Attribute 绑定&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;

简写
&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;

布尔型 Attribute&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;  Button&lt;/button&gt;


动态绑定多个值

通过不带参数的 v-bind，你可以将它们绑定到单个元素上
&lt;script setup&gt;  import comp from &quot;./Comp.vue&quot;  import &#123;ref&#125; from &quot;vue&quot;  const a = ref(&quot;hello&quot;)  const b = ref(&quot;world&quot;)&lt;/script&gt;&lt;template&gt;  &lt;comp v-bind=&quot;&#123;a, b&#125;&quot;&gt;&lt;/comp&gt;&lt;/template&gt;

如果你是使用的 setup 语法糖。需要使用 defineprops 声名（可以直接使用a&#x2F;b）
const props = defineProps(&#123;  a: String,  b: String&#125;)

使用 JavaScript 表达式&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;&lt;div :id=&quot;`list-$&#123;id&#125;`&quot;&gt;&lt;/div&gt;

仅支持表达式(例子都是无效)&lt;!-- 这是一个语句，而非表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 条件控制也不支持，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;

调用函数&lt;span :title=&quot;toTitleDate(date)&quot;&gt;  &#123;&#123; formatDate(date) &#125;&#125;&lt;/span&gt;

指令 Directives&lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;

参数 Arguments&lt;a v-bind:href=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :href=&quot;url&quot;&gt; ... &lt;/a&gt;

绑定事件&lt;a v-on:click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt; ... &lt;/a&gt;


动态参数&lt;a v-bind:[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt;

这里的 attributeName 会作为一个 JS 表达式被动态执行
动态的事件名称&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt;&lt;!-- 简写 --&gt;&lt;a @[eventName]=&quot;doSomething&quot;&gt;

修饰符 Modifiers&lt;form @submit.prevent=&quot;onSubmit&quot;&gt;  ...&lt;/form&gt;

.prevent 修饰符会告知 v-on 指令对触发的事件调用 event.preventDefault()
指令语法v-on:submit.prevent=&quot;onSubmit&quot;──┬─ ─┬──── ─┬─────  ─┬──────  ┆   ┆      ┆        ╰─ Value 解释为JS表达式  ┆   ┆      ╰─ Modifiers 由前导点表示  ┆   ╰─ Argument 跟随冒号或速记符号  ╰─ Name 以 v- 开头使用速记时可以省略

响应式基础声明状态&lt;div&gt;&#123;&#123; state.count &#125;&#125;&lt;/div&gt;


&#123;6,7,11&#125;import &#123; defineComponent, reactive &#125; from &#x27;vue&#x27;;// `defineComponent`用于IDE推导类型export default defineComponent(&#123;  // setup 用于组合式 API 的特殊钩子函数  setup() &#123;    const state = reactive(&#123; count: 0 &#125;);    // 暴露 state 到模板    return &#123;      state    &#125;;  &#125;,&#125;);


声明方法&lt;button @click=&quot;increment&quot;&gt;  &#123;&#123; state.count &#125;&#125;&lt;/button&gt;


&#123;7-9,14&#125;import &#123; defineComponent, reactive &#125; from &#x27;vue&#x27;;export default defineComponent(&#123;  setup() &#123;    const state = reactive(&#123; count: 0 &#125;);    function increment() &#123;      state.count++;    &#125;    // 不要忘记同时暴露 increment 函数    return &#123;      state,      increment    &#125;;  &#125;,&#125;)


&lt;script setup&gt; setup语法糖&#123;1&#125;&lt;script setup&gt;import &#123; reactive &#125; from &#x27;vue&#x27;;const state = reactive(&#123; count: 0 &#125;)function increment() &#123;  state.count++&#125;&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;    &#123;&#123; state.count &#125;&#125;  &lt;/button&gt;&lt;/template&gt;

setup 语法糖用于简化代码，尤其是当需要暴露的状态和方法越来越多时
用 ref() 定义响应式变量

reactive只能用于对象、数组和 Map、Set 这样的集合类型，对 string、number 和 boolean 这样的原始类型则需要使用ref
import &#123; ref &#125; from &#x27;vue&#x27;;const count = ref(0);console.log(count); // &#123; value: 0 &#125;console.log(count.value); // 0count.value++;console.log(count.value); // 1const objectRef = ref(&#123; count: 0 &#125;);// 这是响应式的替换objectRef.value = &#123; count: 1 &#125;;const obj = &#123;  foo: ref(1),  bar: ref(2)&#125;;// 该函数接收一个 ref// 需要通过 .value 取值// 但它会保持响应性callSomeFunction(obj.foo);// 仍然是响应式的const &#123; foo, bar &#125; = obj;

在 html 模板中不需要带 .value 就可以使用
&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const count = ref(0);&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &#123;&#123; count &#125;&#125;  &lt;/div&gt;&lt;/template&gt;

有状态方法

import &#123; reactive, defineComponent, onUnmounted &#125; from &#x27;vue&#x27;;import &#123; debounce &#125; from &#x27;lodash-es&#x27;;export default defineComponent(&#123;  setup() &#123;    // 每个实例都有了自己的预置防抖的处理函数    const debouncedClick = debounce(click, 500);    function click() &#123;      // ... 对点击的响应 ...    &#125;    // 最好是在组件卸载时    // 清除掉防抖计时器    onUnmounted(() =&gt; &#123;      debouncedClick.cancel();    &#125;);  &#125;,&#125;);

响应式样式

&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const open = ref(false);&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;open = !open&quot;&gt;Toggle&lt;/button&gt;  &lt;div&gt;Hello Vue!&lt;/div&gt;  &lt;/template&gt;&lt;style scope&gt;  div&#123;    transition: height 0.1s linear;    overflow: hidden;    height: v-bind(open ? &#x27;30px&#x27; : &#x27;0px&#x27;);  &#125;&lt;/style&gt;

响应式进阶 —— watch 和 computed监听状态

&lt;script setup&gt;import &#123; ref, watch &#125; from &#x27;vue&#x27;;const count = ref(0)const isEvent = ref(false)function increment() &#123;  state.count++&#125;watch(count, function() &#123;  isEvent.value = count.value % 2 === 0&#125;)&lt;/script&gt;&lt;template&gt;  &lt;button @click=&quot;increment&quot;&gt;    &#123;&#123; count &#125;&#125;  &lt;/button&gt;  &lt;p&gt;    is event: &#123;&#123; isEvent ? &#x27;yes&#x27; : &#x27;no&#x27; &#125;&#125;  &lt;/p&gt;&lt;/template&gt;

立即监听状态

watch(count, function() &#123;  isEvent.value = count.value % 2 === 0&#125;, &#123;  // 上例中的 watch 不会立即执行，导致 isEvent 状态的初始值不准确。配置立即执行，会在一开始的时候立即执行一次  immediate: true&#125;)


监听多个值

&lt;template&gt;  &lt;h1&gt; &#123;&#123; count1 &#125;&#125; &lt;/h1&gt;  &lt;h1&gt; &#123;&#123; count2 &#125;&#125; &lt;/h1&gt;  &lt;button @click=&quot;count1++&quot;&gt;count1&lt;/button&gt;  &lt;button @click=&quot;count2++&quot;&gt;count2&lt;/button&gt;&lt;/template&gt;&lt;script setup&gt;  import &#123; watch, ref &#125; from &#x27;vue&#x27;;    const count1 = ref(0)  const count2 = ref(0)    watch(    // 监听的表达式或函数    () =&gt; (&#123;      count1: count1.value,      count2: count2.value    &#125;),    // 回调函数    (newValue, oldValue) =&gt; &#123;      // 在这里执行需要的逻辑      console.log(&#x27;count1 或 count2 变化了：&#x27;, newValue);    &#125;,    // immediate: true 表示在初始渲染时立即执行一次回调函数，以便处理初始的状态。    // deep: true 表示深度监听，即对 newValue 和 oldValue 进行深层比较，而不是简单的引用比较。    &#123; immediate: true, deep: true &#125;  );&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;

计算状态&lt;script setup&gt;import &#123; ref, computed &#125; from &#x27;vue&#x27;;const text = ref(&#x27;&#x27;)// computed 的回调函数里// 会根据已有并用到的状态计算出新的状态const capital = computed(function()&#123;  return text.value.toUpperCase();&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;text&quot; /&gt;  &lt;p&gt;to capital: &#123;&#123; capital &#125;&#125;&lt;/p&gt;&lt;/template&gt;

组件通信defineProps&lt;script setup&gt;import &#123; defineProps &#125; from &#x27;vue&#x27;;// 这里可以将 `username` 解构出来，// 但是一旦解构出来再使用，就不具备响应式能力defineProps(&#123;  username: String&#125;)&lt;/script&gt;&lt;template&gt;  &lt;p&gt;username: &#123;&#123; username &#125;&#125;&lt;/p&gt;&lt;/template&gt;

子组件定义需要的参数
&lt;script setup&gt;const username = &#x27;vue&#x27;&lt;/script&gt;&lt;template&gt;  &lt;children :username=&quot;username&quot; /&gt;&lt;/template&gt;

父组件参入参数
defineEmits&lt;script setup&gt;import &#123; defineEmits, ref &#125; from &#x27;vue&#x27;;const emit = defineEmits([&#x27;search&#x27;])const keyword = ref(&#x27;&#x27;)const onSearch = function() &#123;  emit(&#x27;search&#x27;, keyword.value)&#125;&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;keyword&quot; /&gt;  &lt;button @click=&quot;onSearch&quot;&gt;search&lt;/button&gt;&lt;/template&gt;

子组件定义支持 emit 的函数
&lt;script setup&gt;const onSearch = function(keyword)&#123;  console.log(keyword)&#125;&lt;/script&gt;&lt;template&gt;  &lt;children @search=&quot;onSearch&quot; /&gt;&lt;/template&gt;

父组件绑定子组件定义的事件
defineExpose&lt;script setup&gt;import &#123; defineExpose, ref &#125; from &#x27;vue&#x27;;const keyword = ref(&#x27;&#x27;)const onSearch = function() &#123;  console.log(keyword.value)&#125;defineExpose(&#123; onSearch &#125;)&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;keyword&quot; /&gt;&lt;/template&gt;

子组件对父组件暴露方法
&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;  const childrenRef = ref(null)const onSearch = function() &#123;  childrenRef.value.onSearch()&#125;&lt;/script&gt;&lt;template&gt;  &lt;children ref=&#x27;childrenRef&#x27; /&gt;  &lt;button @click=&quot;onSearch&quot;&gt;search&lt;/button&gt;&lt;/template&gt;

父组件调用子组件的方法
Provide &#x2F; Injectimport type &#123; InjectionKey, Ref &#125; from &#x27;vue&#x27;export const ProvideKey = Symbol() as InjectionKey&lt;Ref&lt;string&gt;&gt;


在应用中使用 ProvideKey
&lt;script setup lang=&quot;ts&quot;&gt;import &#123; provide, ref &#125; from &#x27;vue&#x27;import &#123; ProvideKey &#125; from &#x27;./types&#x27;const text = ref&lt;string&gt;(&#x27;123&#x27;)provide(ProvideKey, text)&lt;/script&gt;&lt;template&gt;  &lt;input v-model=&quot;text&quot; /&gt;&lt;/template&gt;

父组件为后代组件提供数据
&lt;script setup lang=&quot;ts&quot;&gt;import &#123; inject &#125; from &#x27;vue&#x27;import &#123; ProvideKey &#125; from &#x27;./types&#x27;const value = inject(ProvideKey)&lt;/script&gt;&lt;template&gt;  &lt;h4&gt;&#123;&#123;value&#125;&#125;&lt;/h4&gt;&lt;/template&gt;

后代组件注入父组件提供的数据


路由1. 路由的基本使用开启命名空间后，组件中读取state数据方式一：自己直接读取
this.$store.state.personAbout.list

方式二：借助 mapState 读取：
...mapState(&#x27;countAbout&#x27;,[  &#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),

开启命名空间后，组件中读取getters数据方式一：自己直接读取
this.$store.getters[  &#x27;personAbout/firstPersonName&#x27;]

方式二：借助 mapGetters 读取：
...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;])

开启命名空间后，组件中调用dispatch方式一：自己直接 dispatch
this.$store.dispatch(  &#x27;personAbout/addPersonWang&#x27;, person)

方式二：借助mapActions:
...mapActions(&#x27;countAbout&#x27;,&#123;  incrementOdd:&#x27;jia0dd&#x27;,  incrementWait:&#x27;jiaWait&#x27;&#125;)

开启命名空间后，组件中调用commit方式一：自己直接 commit
this.$store.commit(  &#x27;personAbout/ADD_PERSON&#x27;, person)

方式二：借助 mapMutations:
...mapMutations(&#x27;countAbout&#x27;, &#123;  increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;),

2. 路由的使用import VueRouter from &#x27;vue-router&#x27;// 引入Luyou 组件import About from &#x27;../components/About&#x27;import Home from &#x27;../components/Home&#x27;// 创建router实例对象，去管理一组一组的路由规则const router = new VueRouter(&#123;  routes: [    path: &#x27;/about&#x27;,    component: About    path: &#x27;/home&#x27;,    component: Home  ]&#125;)// 暴露 routerexport default router

实现切换（active-class可配置高亮样式）
&lt;router-link  active-class=&quot;active&quot;  to=&quot;/about&quot;&gt;  About&lt;/router-link&gt;

指定展示位置
&lt;router-diew&gt;&lt;/router-view&gt;

几个注意点

路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹。
通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。
每个组件都有自己的$route属性，里面存储着自己的路由信息。
整个应用只有一个router，可以通过组件的srouter 属性获取到。



3.路由的query&lt;template&gt;  &lt;div&gt;    &lt;ul class=&quot;list&quot;&gt;        &lt;!-- to的对象写法 --&gt;        &lt;li v-for=&quot;item of data&quot; :key=&quot;item.id&quot;&gt;            &lt;router-link                 class=&quot;link&quot;                 :to=&quot;&#123;                    path:&#x27;/home/message/mes&#x27;,                    query: &#123; id:item.id, title:item.mes &#125;                &#125;&quot;            &gt;&#123;&#123;item.mes&#125;&#125;&lt;/router-link&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;hr&gt;    &lt;router-view&gt;&lt;/router-view&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;    name:&#x27;HomeChild1&#x27;,    data() &#123;      return &#123;        data:[            &#123;id:1,mes:&quot;消息1&quot;&#125;,            &#123;id:2,mes:&quot;消息2&quot;&#125;,            &#123;id:3,mes:&quot;消息3&quot;&#125;        ]      &#125;    &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;  .list &#123; margin-left:80px; &#125;  .link&#123;    color: orange;    text-decoration: none;    background-color: skyblue;  &#125;&lt;/style&gt;


接收参数 &#123;&#123;$route.query.id&#125;&#125;

跳转路由并携带参数&lt;li v-for=&quot;item of data&quot; :key=&quot;item.id&quot;&gt;    &lt;router-link         class=&quot;link&quot;         :to=&quot;`/home/message/mes?id=$&#123;item.id&#125;&amp;title=$&#123;item.mes&#125;`&quot;    &gt;      &#123;&#123;item.mes&#125;&#125;    &lt;/router-link&gt;&lt;/li&gt;

4. 命名路由routes:[    &#123; path:&#x27;/about&#x27;, component:AboutBody &#125;,    &#123;        path:&#x27;/home&#x27;,        component:HomeBody,        children:[            &#123; path:&#x27;news&#x27;, component:HomeChild &#125;,            &#123;               path:&#x27;message&#x27;,              component:HomeChild1,              //多级路由              children:[                  &#123; name:&#x27;richu&#x27;, path:&#x27;mes&#x27;, component:HomeMessage &#125;              ]            &#125;        ]    &#125;]

使用
&lt;router-link :to=&quot;&#123;   name:&#x27;&#x27;,  path:&#x27;/home/message/mes&#x27;,​  query:&#123; id:item.id,title:item.mes &#125;&#125;&quot;&gt;```  ### 5.params参数的使用#### 1. 声明接收```javascriptchildren:[    &#123;        name:&#x27;richu&#x27;,        path:&#x27;mes/:id/:title&#x27;,        component:HomeMessage    &#125;]

2. 传递&lt;li v-for=&quot;item of data&quot; :key=&quot;item.id&quot;&gt;    &lt;router-link       class=&quot;link&quot;       :to=&quot;`/home/message/mes/$&#123;item.id&#125;/$&#123;item.mes&#125;`&quot;      &gt;&#123;&#123;item.mes&#125;&#125;    &lt;/router-link&gt;&lt;/li&gt;

3. 接收&lt;li&gt;编号&#123;&#123;$route.params.id&#125;&#125;&lt;/li&gt;&lt;li&gt;标题&#123;&#123;$route.params.title&#125;&#125;&lt;/li&gt;

6.props的使用路由的props配置
&#123;  name: &#x27;xiangqing&#x27;,  path:&#x27;detail/:id&#x27;,  component:Detail&#125;

作用：让路由组件更方便的收到参数
//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detai1组件// props:&#123;a:900]//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detai1组件// props:true//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件props(route)&#123;  return &#123;    id:route.query.id,    title:route.query.title  &#125;&#125;

&lt;router-link&gt; 的 replace 属性

作用：控制路由跳转时操作浏览器历史记录的模式
浏览器的历史记录有两种写入方式：分别为 push和replace,默认为push
如何开启replace 模式： push 是追加历史记录,replace 是替换当前记录[路由跳转时候 &lt;router-link replace&gt;News\&lt;/router-link&gt;]

7. 编程式路由导航作用：不借助router-link实现路由跳转，让跳转更加灵活
this.$router.push(&#123;    name:&#x27;xiangqing&#x27;,    params:&#123;        id: xxx,        title: xxx        // 实现路由跳转，让路由跳转更加灵活    &#125;&#125;)this.$router.replace(&#123;    name:&#x27;xiangqing&#x27;,    params:&#123;        id:xxx,        title:xxx    &#125;&#125;)this.$router.forward();this.$router.back();this.$router.go(3);

8.缓存路由组件让不展示的路由组件保持挂载，不被销毁，示例：
&lt;keep-alive include=&quot;news&quot;&gt;    &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt;


include 里面写模块名,用于保存指定的模块

9.新生命周期钩子
作用：路由组件独有的，用于捕获路由组件的激活状态


activated 路由组件被激活时触发
deactivated 路由组件失活时触发

路由守卫1.前置路由守卫route.beforeEach((from,to,next)=&gt;&#123;    if (to.meta.isAuth)&#123;        alert(&quot;1&quot;);        next();    &#125;else&#123;        next();    &#125;&#125;)

前置路由
2.后置路由守卫route.afterEach((from,to)=&gt;&#123;    console.log(to);    document.title=from.meta.title;&#125;)

后置路由
3.独享路由守卫&#123;    path:&#x27;news&#x27;,    component:HomeChild,    meta:&#123;title:&quot;新闻&quot;&#125;,        beforeEnter: (from,to,next)=&gt;&#123;        &#125;&#125;,

独享路由守卫只有前置路由守卫没有后置路由守卫
4.组件内路由守卫通过路由规则，进入该组件时被调用
beforeRouteEnter (to, from, next) &#123;    // ...&#125;

通过路由规则，离开组件时被调用
beforeRouteLeave (to, from, next) &#123;    // ...&#125;

Vue 中使用 TypeScript为组件的 props 标注类型

当使用 &lt;script setup&gt; 时，defineProps() 宏函数支持从它的参数中推导类型
&lt;script setup lang=&quot;ts&quot;&gt;const props = defineProps(&#123;  foo: &#123; type: String, required: true &#125;,  bar: Number&#125;)props.foo // stringprops.bar // number | undefined&lt;/script&gt;

对同一个文件中的一个接口或对象类型字面量的引用：
interface Props &#123;/* ... */&#125;defineProps&lt;Props&gt;()

Props 解构默认值export interface Props &#123;  msg?: string  labels?: string[]&#125;const props = withDefaults(defineProps&lt;Props&gt;(), &#123;  msg: &#x27;hello&#x27;,  labels: () =&gt; [&#x27;one&#x27;, &#x27;two&#x27;]&#125;)

使用目前为实验性的响应性语法糖
&lt;script setup lang=&quot;ts&quot;&gt;interface Props &#123;  name: string  count?: number&#125;// 对 defineProps() 的响应性解构// 默认值会被编译为等价的运行时选项const &#123;  name, count = 100&#125; = defineProps&lt;Props&gt;()&lt;/script&gt;

为组件的 emits 标注类型&lt;script setup lang=&quot;ts&quot;&gt;// 运行时const emit = defineEmits([&#x27;change&#x27;, &#x27;update&#x27;])// 基于类型const emit = defineEmits&lt;&#123;  (e: &#x27;change&#x27;, id: number): void  (e: &#x27;update&#x27;, value: string): void&#125;&gt;()&lt;/script&gt;

为 ref() 标注类型ref 会根据初始化时的值推导其类型：
import &#123; ref &#125; from &#x27;vue&#x27;import type &#123; Ref &#125; from &#x27;vue&#x27;const year: Ref&lt;string | number&gt; = ref(&#x27;2020&#x27;)year.value = 2020 // 成功！

为 reactive() 标注类型import &#123; reactive &#125; from &#x27;vue&#x27;interface Book &#123;  title: string  year?: number&#125;const book: Book = reactive(&#123;  title: &#x27;Vue 3 指引&#x27;&#125;)

为 computed() 标注类型你还可以通过泛型参数显式指定类型：
const double = computed&lt;number&gt;(() =&gt; &#123;  // 若返回值不是 number 类型则会报错&#125;)

为事件处理函数标注类型

&lt;script setup lang=&quot;ts&quot;&gt;function handleChange(event) &#123;  // `event` 隐式地标注为 `any` 类型  console.log(event.target.value)&#125;&lt;/script&gt;&lt;template&gt;  &lt;input    type=&quot;text&quot;    @change=&quot;handleChange&quot; /&gt;&lt;/template&gt;

显式地为事件处理函数的参数标注类型
function handleChange(event: Event) &#123;  const target = event.target as HTMLInputElement  console.log(target.value)&#125;

为 provide &#x2F; inject 标注类型import &#123; provide, inject &#125; from &#x27;vue&#x27;import type &#123; InjectionKey &#125; from &#x27;vue&#x27;const key = Symbol() as InjectionKey&lt;string&gt;// 若提供的是非字符串值会导致错误provide(key, &#x27;foo&#x27;)// foo 的类型：string | undefinedconst foo = inject(key)

为模板引用标注类型&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;const el = ref&lt;HTMLInputElement | null&gt;(null)onMounted(() =&gt; &#123;  el.value?.focus()&#125;)&lt;/script&gt;&lt;template&gt;  &lt;input ref=&quot;el&quot; /&gt;&lt;/template&gt;

为组件模板引用标注类型&lt;!-- MyModal.vue --&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;const isContentShown = ref(false)const open =       () =&gt; (isContentShown.value = true)defineExpose(&#123;  open&#125;)&lt;/script&gt;

使用 TypeScript 内置的 InstanceType 工具类型来获取其实例类
&lt;!-- App.vue --&gt;&lt;script setup lang=&quot;ts&quot;&gt;import MyModal from &#x27;./MyModal.vue&#x27;type Modal = InstanceType&lt;typeof MyModal&gt;const modal = ref&lt;Modal | null&gt;(null)const openModal = () =&gt; &#123;  modal.value?.open()&#125;&lt;/script&gt;

选项式 API 为组件的 props 标注类型

import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123;  // 启用了类型推导  props: &#123;    name: String,    id: [Number, String],    msg: &#123; type: String, required: true &#125;,    metadata: null  &#125;,  mounted() &#123;    // 类型：string | undefined    this.name    // 类型：number|string|undefined    this.id    // 类型：string    this.msg    // 类型：any    this.metadata  &#125;&#125;)

使用 PropType 这个工具类型来标记更复杂的 props 类型
import &#123; defineComponent &#125; from &#x27;vue&#x27;import type &#123; PropType &#125; from &#x27;vue&#x27;interface Book &#123;  title: string  author: string  year: number&#125;export default defineComponent(&#123;  props: &#123;    book: &#123;      // 提供相对 `Object` 更确定的类型      type: Object as PropType&lt;Book&gt;,      required: true    &#125;,    // 也可以标记函数    callback: Function as PropType&lt;(id: number) =&gt; void&gt;  &#125;,  mounted() &#123;    this.book.title // string    this.book.year // number    // TS Error: argument of type &#x27;string&#x27; is not    // assignable to parameter of type &#x27;number&#x27;    this.callback?.(&#x27;123&#x27;)  &#125;&#125;)

选项式 API 为组件的 emits 标注类型import &#123; defineComponent &#125; from &#x27;vue&#x27;type Payload = &#123; bookName: string &#125;export default defineComponent(&#123;  emits: &#123;    addBook(payload: Payload) &#123;      // 执行运行时校验      return payload.bookName.length &gt; 0    &#125;  &#125;,  methods: &#123;    onSubmit() &#123;      this.$emit(&#x27;addBook&#x27;, &#123;        bookName: 123 // 类型错误      &#125;)      // 类型错误      this.$emit(&#x27;non-declared-event&#x27;)    &#125;  &#125;&#125;)

选项式 API 为计算属性标记类型

计算属性会自动根据其返回值来推导其类型：
import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123;  data() &#123;    return &#123;      message: &#x27;Hello!&#x27;    &#125;  &#125;,  computed: &#123;    greeting() &#123;      return this.message + &#x27;!&#x27;    &#125;  &#125;,  mounted() &#123;    this.greeting // 类型：string  &#125;&#125;)

在某些场景中，你可能想要显式地标记出计算属性的类型以确保其实现是正确的：
import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123;  data() &#123;    return &#123;      message: &#x27;Hello!&#x27;    &#125;  &#125;,  computed: &#123;    // 显式标注返回类型    greeting(): string &#123;      return this.message + &#x27;!&#x27;    &#125;,    // 标注一个可写的计算属性    greetingUppercased: &#123;      get(): string &#123;        return this.greeting.toUpperCase()      &#125;,      set(newValue: string) &#123;        this.message = newValue.toUpperCase()      &#125;    &#125;  &#125;&#125;)

选项式 API 为事件处理函数标注类型import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123;  methods: &#123;    handleChange(event: Event) &#123;      console.log((event.target as HTMLInputElement).value)    &#125;  &#125;&#125;)

选项式 API 扩展全局属性import axios from &#x27;axios&#x27;declare module &#x27;vue&#x27; &#123;  interface ComponentCustomProperties &#123;    $http: typeof axios    $translate: (key: string) =&gt; string  &#125;&#125;

类型扩展的位置我们可以将这些类型扩展放在一个 .ts 文件，或是一个影响整个项目的 *.d.ts 文件中
// 不工作，将覆盖原始类型。declare module &#x27;vue&#x27; &#123;  interface ComponentCustomProperties &#123;    $translate: (key: string) =&gt; string  &#125;&#125;


// 正常工作。export &#123;&#125;declare module &#x27;vue&#x27; &#123;  interface ComponentCustomProperties &#123;    $translate: (key: string) =&gt; string  &#125;&#125;

选项式 API 扩展自定义选项某些插件，比如 vue-router，提供了一些自定义的组件选项，比如 beforeRouteEnter：
import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123;  beforeRouteEnter(to, from, next) &#123;    // ...  &#125;&#125;)

如果没有确切的类型标注，这个钩子函数的参数会隐式地标注为 any 类型。我们可以为 ComponentCustomOptions 接口扩展自定义的选项来支持：
import &#123; Route &#125; from &#x27;vue-router&#x27;declare module &#x27;vue&#x27; &#123;  interface ComponentCustomOptions &#123;    beforeRouteEnter?(      to: Route,      from: Route,      next: () =&gt; void    ): void  &#125;&#125;

API 参考全局 API - 应用实例




:-
:-



createApp()
创建一个应用实例 #


createSSRApp()
以 SSR 激活模式创建一个应用实例 #


app.mount()
将应用实例挂载在一个容器元素中 #


app.unmount()
卸载一个已挂载的应用实例 #


app.provide()
提供一个可以在应用中的所有后代组件中注入使用的值 #


app.component()
注册或获取全局组件 #


app.directive()
注册或获取全局指令 #


app.use()
安装一个插件 #


app.mixin()
全局注册一个混入 #


app.version
当前应用所使用的 Vue 版本号 #


app.config
获得应用实例的配置设定 #


app.config.errorHandler
为应用内抛出的未捕获错误指定一个全局处理函数 #


app.config.warnHandler
为 Vue 的运行时警告指定一个自定义处理函数 #


app.config.performance
在浏览器开发工具中追踪性能表现 #


app.config.compilerOptions
配置运行时编译器的选项 #


app.config.globalProperties
注册全局属性对象 #


app.config.optionMergeStrategies
定义自定义组件选项的合并策略的对象 #




全局 API - 通用




:-
:-



version
Vue 版本号 #


nextTick()
等待下一次 DOM 更新后执行回调 #


defineComponent()
在定义 Vue 组件时提供类型推导的辅助函数 #


defineAsyncComponent()
定义一个异步组件 #


defineCustomElement()
和 defineComponent 接受的参数相同，不同的是会返回一个原生自定义元素类的构造器 #




组合式 API - setup()


:-
:-



基本使用
#


访问 Props
#


Setup 上下文
#


与渲染函数一起使用
#


组合式 API - 依赖注入


:-
:-



provide()
提供一个可以被后代组件中注入使用的值 #


inject()
注入一个由祖先组件提供的值 #


组合式 API - 生命周期钩子


:-
:-



onMounted()
组件挂载完成后执行 #


onUpdated()
状态变更而更新其 DOM 树之后调用 #


onUnmounted()
组件实例被卸载之后调用 #


onBeforeMount()
组件被挂载之前被调用 #


onBeforeUpdate()
状态变更而更新其 DOM 树之前调用 #


onBeforeUnmount()
组件实例被卸载之前调用 #


onErrorCaptured()
捕获了后代组件传递的错误时调用 #


onRenderTracked()
组件渲染过程中追踪到响应式依赖时调用 #


onRenderTriggered()
响应式依赖的变更触发了组件渲染时调用 #


onActivated()
若组件实例是 &lt;KeepAlive&gt; 缓存树的一部分，当组件被插入到 DOM 中时调用 #


onDeactivated()
若组件实例是 &lt;KeepAlive&gt; 缓存树的一部分，当组件从 DOM 中被移除时调用 #


onServerPrefetch()
组件实例在服务器上被渲染之前调用 #




组合式 API - 响应式: 工具


:-
:-



isRef()
判断是否为 ref #


unref()
是 ref，返回内部值，否则返回参数本身 #


toRef()
创建一个属性对应的 ref #


toRefs()
将对象上的每一个可枚举属性转换为 ref #


isProxy()
检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理 #


isReactive()
检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理。  #


isReadonly()
检查传入的值是否为只读对象 #




组合式 API - 响应式: 核心


:-
:-



ref()
返回一个 ref 对象 #


computed ()
定义一个计算属性 #


reactive()
返回一个对象的响应式代理 #


readonly()
返回一个原值的只读代理 #


watchEffect()
立即运行一个函数，同时监听 #


watchPostEffect()
watchEffect() 使用 flush: &#39;post&#39; 选项时的别名。 #


watchSyncEffect()
watchEffect() 使用 flush: &#39;sync&#39; 选项时的别名。 #


watch()
侦听一个或多个响应式数据源 #




选项式 API - 状态选项


:-
:-



data
声明组件初始响应式状态 #


props
声明一个组件的 props #


computed
声明要在组件实例上暴露的计算属性 #


methods
声明要混入到组件实例中的方法 #


watch
声明在数据更改时调用的侦听回调 #


emits
声明由组件触发的自定义事件 #


expose
声明当组件实例被父组件通过模板引用访问时暴露的公共属性 #




选项式 API - 生命周期选项




:-
:-



beforeCreate
组件实例初始化完成之后立即调用 #


created
组件实例处理完所有与状态相关的选项后调用 #


beforeMount
组件被挂载之前调用 #


mounted
组件被挂载之后调用 #


beforeUpdate
状态变更而更新其 DOM 树之前调用 #


updated
状态变更而更新其 DOM 树之后调用 #


beforeUnmount
组件实例被卸载之前调用 #


unmounted
组件实例被卸载之后调用 #


errorCaptured
捕获了后代组件传递的错误时调用 #


renderTracked Dev only
组件渲染过程中追踪到响应式依赖时调用 #


renderTriggered Dev only
响应式依赖的变更触发了组件渲染时调用 #


activated
若组件实例是  缓存树的一部分，当组件被插入到 DOM 中时调用 #


deactivated
若组件实例是  缓存树的一部分，当组件从 DOM 中被移除时调用 #


serverPrefetch SSR only
组件实例在服务器上被渲染之前调用 #




选项式 API - 其他杂项


:-
:-



name
显式声明组件展示时的名称 #


inheritAttrs
是否启用默认的组件 attribute 透传行为 #


components
注册对当前组件实例可用的组件 #


directives
注册对当前组件实例可用的指令 #




选项式 API - 渲染选项


:-
:-



template
声明组件的字符串模板 #


render
编程式地创建组件虚拟 DOM 树的函数 #


compilerOptions
配置组件模板的运行时编译器选项 #




选项式 API - 组件实例




:-
:-



$data
观察的数据对象 #


$props
组件已解析的 props 对象 #


$el
实例管理的 DOM 根节点 #


$options
实例的初始化选项 #


$parent
父实例 #


$root
当前组件树的根实例 #


$slots
访问被插槽分发的内容 #


$refs
DOM 元素和组件实例 #


$attrs
包含了组件所有透传 attributes #


$watch()
观察 Vue 实例上的一个表达式或者一个函数计算结果的变化 #


$emit()
触发一个自定义事件 #


$forceUpdate()
强制该组件重新渲染 #


$nextTick()
回调延迟执行 #


选项式 API - 组合选项


:-
:-



provide
提供可以被后代组件注入的值 #


inject
注入一个由祖先组件提供的值 #


mixins
接收一个混入对象的数组 #


extends
要继承的“基类”组件 #


内置内容 - 指令




:-
:-



v-text
更新元素的 textContent #


v-html
更新元素的 innerHTML #


v-show
切换元素的 display css 属性 #


v-if
有条件地渲染元素 #


v-else
#


v-else-if
#


v-for
多次渲染元素或模板块 #


v-on
绑定事件监听器 #


v-bind
动态地绑定一个或多个属性 #


v-model
创建双向绑定 #


v-slot
提供插槽或接收 props 的插槽 #


v-pre
跳过元素和它的子元素编译过程 #


v-once
只渲染元素和组件一次 #


v-memo (3.2+)
缓存一个模板的子树 #


v-cloak
保持在元素上直到实例结束编译 #


serverPrefetch SSR only
组件实例在服务器上被渲染之前调用 #


内置内容 - 组件


:-
:-



&lt;Transition&gt;
单个元素&#x2F;组件的过渡效果 #


&lt;TransitionGroup&gt;
多个元素&#x2F;组件的过渡效果 #


&lt;KeepAlive&gt;
缓存包裹在其中的动态切换组件 #


&lt;Teleport&gt;
将其插槽内容渲染到 DOM 中的另一个位置 #


&lt;Suspense&gt; (Experimental)
协调对组件树中嵌套的异步依赖的处理 #




内置内容 - 特殊 Attributes


:-
:-



key
用在 Vue 的虚拟 DOM 算法 #


ref
元素或子组件注册引用信息 #


is
绑定动态组件 #


内置内容 - 特殊元素


:-
:-



&lt;component&gt;
渲染一个“元组件”用于动态组件或元素 #


&lt;slot&gt;
组件模板中的插槽内容出口 #


单文件组件 - 语法定义




:-
:-



总览
#


相应语言块
#


自动名称推导
#


预处理器
#


Src 导入
#


注释
#


单文件组件 - &lt;script setup&gt;




:-
:-



基本语法
#


响应式
#


使用组件
#


使用自定义指令
#


defineProps() 和 defineEmits()
#


defineExpose
#


useSlots() 和 useAttrs()
#


与普通的 &amp;lt;script&amp;gt; 一起使用
#


顶层 await
#


针对 TypeScript 的功能
#


限制
#


单文件组件 - CSS 功能


:-
:-



组件作用域 CSS
#


CSS Modules
#


CSS 中的 v-bind()
#


进阶 API - 渲染函数


:-
:-



h()
创建虚拟 DOM 节点 #


mergeProps()
合并多个 props 对象 #


cloneVNode()
克隆一个 vnode #


isVNode()
判断一个值是否为 vnode 类型 #


resolveComponent()
按名称手动解析已注册的组件 #


resolveDirective()
按名称手动解析已注册的指令 #


withDirectives()
用于给 vnode 增加自定义指令 #


withModifiers()
用于向事件处理函数添加内置 v-on 修饰符 #


进阶 API - 服务端渲染


:-
:-



renderToString()
#


renderToNodeStream()
#


pipeToNodeWritable()
#


renderToWebStream()
#


pipeToWebWritable()
#


renderToSimpleStream()
#


useSSRContext()
#


进阶 API - TypeScript 工具类型


:-
:-



PropType&lt;T&gt;
在用运行时 props 声明时给一个 prop 标注更复杂的类型定义 #


ComponentCustomProperties
增强组件实例类型以支持自定义全局属性 #


ComponentCustomOptions
扩展组件选项类型以支持自定义选项 #


ComponentCustomProps
扩展全局可用的 TSX props #


CSSProperties
扩展在样式属性绑定上允许的值的类型 #




进阶 API - 自定义渲染


:-
:-



createRenderer()
创建一个自定义渲染器 #


另见
Vue 3.x 官方文档
Vue Router 4.x 官方文档

]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Yaml 备忘录</title>
    <url>/2025/01/08/yaml/</url>
    <content><![CDATA[YAML 备忘清单这是理解和编写 YAML 格式配置文件的快速参考备忘单。
入门介绍YAML 是一种数据序列化语言，旨在供人类直接读写

YAML 不允许使用制表符
元素部分之间必须有空间
YAML 区分大小写
以 .yaml 或 .yml 扩展名结束您的 YAML 文件
YAML 是 JSON 的超集
Ansible playbook 是 YAML 文件



标量类型

n1: 1            # 整数n2: 1.234        # 浮点s1: &#x27;abc&#x27;        # 字符串s2: &quot;abc&quot;        # 字符串s3: abc          # 字符串b: false         # 布尔类型d: 2015-04-05    # 日期类型

↓ 等效的 JSON&#123;  &quot;n1&quot;: 1,  &quot;n2&quot;: 1.234,  &quot;s1&quot;: &quot;abc&quot;,  &quot;s2&quot;: &quot;abc&quot;,  &quot;s3&quot;: &quot;abc&quot;,  &quot;b&quot;: false,  &quot;d&quot;: &quot;2015-04-05&quot;&#125;

使用空格缩进。 元素部分之间必须有空间。
变量some_thing: &amp;VAR_NAME foobarother_thing: *VAR_NAME

↓ 等效的 JSON&#123;  &quot;some_thing&quot;: &quot;foobar&quot;,  &quot;other_thing&quot;: &quot;foobar&quot;&#125;

注释# A single line comment example# block level comment example# comment line 1# comment line 2# comment line 3

多行字符串description: |  hello  world

↓ 等效的 JSON&#123;&quot;description&quot;: &quot;hello\nworld\n&quot;&#125;

继承

parent: &amp;defaults  a: 2  b: 3child:  &lt;&lt;: *defaults  b: 4

↓ 等效的 JSON&#123;  &quot;parent&quot;: &#123;    &quot;a&quot;: 2,    &quot;b&quot;: 3  &#125;,  &quot;child&quot;: &#123;    &quot;a&quot;: 2,    &quot;b&quot;: 4  &#125;&#125;

参考

values: &amp;ref  - Will be  - reused below  other_values:  i_am_ref: *ref

↓ 等效的 JSON&#123;  &quot;values&quot;: [    &quot;Will be&quot;,    &quot;reused below&quot;  ],  &quot;other_values&quot;: &#123;    &quot;i_am_ref&quot;: [      &quot;Will be&quot;,      &quot;reused below&quot;    ]  &#125;&#125;

折叠的字符串description: &gt;  hello  world

↓ 等效的 JSON&#123;&quot;description&quot;: &quot;hello world\n&quot;&#125;

两份文件---document: this is doc 1---document: this is doc 2

YAML使用---将指令与文档内容分开。
YAML Collections序列- Mark McGwire- Sammy Sosa- Ken Griffey

↓ 等效的 JSON[  &quot;Mark McGwire&quot;,  &quot;Sammy Sosa&quot;,  &quot;Ken Griffey&quot;]

映射hr:  65       # Home runsavg: 0.278    # Batting averagerbi: 147      # Runs Batted In

↓ 等效的 JSON&#123;  &quot;hr&quot;: 65,  &quot;avg&quot;: 0.278,  &quot;rbi&quot;: 147&#125;

映射到序列attributes:  - a1  - a2methods: [getter, setter]

↓ 等效的 JSON&#123;  &quot;attributes&quot;: [&quot;a1&quot;, &quot;a2&quot;],  &quot;methods&quot;: [&quot;getter&quot;, &quot;setter&quot;]&#125;

映射序列children:  - name: Jimmy Smith    age: 15  - name: Jimmy Smith    age: 15  -    name: Sammy Sosa    age: 12

↓ 等效的 JSON&#123;  &quot;children&quot;: [    &#123;&quot;name&quot;: &quot;Jimmy Smith&quot;, &quot;age&quot;: 15&#125;,    &#123;&quot;name&quot;: &quot;Jimmy Smith&quot;, &quot;age&quot;: 15&#125;,    &#123;&quot;name&quot;: &quot;Sammy Sosa&quot;, &quot;age&quot;: 12&#125;  ]&#125;

序列的序列my_sequences:  - [1, 2, 3]  - [4, 5, 6]  -      - 7    - 8    - 9    - 0 

↓ 等效的 JSON&#123;  &quot;my_sequences&quot;: [    [1, 2, 3],    [4, 5, 6],    [7, 8, 9, 0]  ]&#125;

映射的映射Mark McGwire: &#123;hr: 65, avg: 0.278&#125;Sammy Sosa: &#123;    hr: 63,    avg: 0.288  &#125;

↓ 等效的 JSON&#123;  &quot;Mark McGwire&quot;: &#123;    &quot;hr&quot;: 65,    &quot;avg&quot;: 0.278  &#125;,  &quot;Sammy Sosa&quot;: &#123;    &quot;hr&quot;: 63,    &quot;avg&quot;: 0.288  &#125;&#125;

嵌套集合Jack:  id: 1  name: Franc  salary: 25000  hobby:    - a    - b  location: &#123;country: &quot;A&quot;, city: &quot;A-A&quot;&#125;

↓ 等效的 JSON&#123;  &quot;Jack&quot;: &#123;    &quot;id&quot;: 1,    &quot;name&quot;: &quot;Franc&quot;,    &quot;salary&quot;: 25000,    &quot;hobby&quot;: [&quot;a&quot;, &quot;b&quot;],    &quot;location&quot;: &#123;        &quot;country&quot;: &quot;A&quot;, &quot;city&quot;: &quot;A-A&quot;    &#125;  &#125;&#125;

无序集set1: !!set  ? one  ? twoset2: !!set &#123;&#x27;one&#x27;, &quot;two&quot;&#125;

↓ 等效的 JSON&#123;  &quot;set1&quot;: &#123;&quot;one&quot;: null, &quot;two&quot;: null&#125;,  &quot;set2&quot;: &#123;&quot;one&quot;: null, &quot;two&quot;: null&#125;&#125;

集合表示为一个映射，其中每个键都与一个空值相关联
有序映射ordered: !!omap- Mark McGwire: 65- Sammy Sosa: 63- Ken Griffy: 58

↓ 等效的 JSON&#123;  &quot;ordered&quot;: [     &#123;&quot;Mark McGwire&quot;: 65&#125;,     &#123;&quot;Sammy Sosa&quot;: 63&#125;,     &#123;&quot;Ken Griffy&quot;: 58&#125;  ]&#125;

YAML 参考条款
序列又名数组或列表
标量又名字符串或数字
映射又名哈希或字典



基于 YAML.org refcard。
文档指标


:-
:-



%
指令指标


---
文档标题


...
文档终结者


收集指标




:-
:-



?
关键指标


:
价值指标


-
嵌套系列条目指示器


,
单独的内联分支条目


[]
环绕串联系列分支


&#123;&#125;
环绕在线键控分支


别名指标


:-
:-



&amp;
锚属性


*
别名指示符


特殊键


:-
:-



=
默认“值”映射键


&lt;&lt;
合并来自另一个映射的键


标量指标


:-
:-



&#39;&#39;
环绕内联未转义标量


&quot;
环绕内嵌转义标量


&#96;
&#96;


&gt;
折叠标量指示器


-
剥离 chomp 修饰符（|- 或 &gt;-）


+
保留 chomp 修饰符（|+ 或 &gt;+）


1-9
显式缩进修饰符（|1 或 &gt;2）。  修饰符可以组合（|2-, &gt;+1）


标签属性（通常未指定）




:-
:-



none
未指定的标签（由应用程序自动解析）


!
非特定标签（默认情况下，!!map&#x2F;!!seq&#x2F;!!str）


!foo
主要（按照惯例，表示本地 !foo 标记）


!!foo
次要的（按照惯例，表示 tag:yaml.org,2002:foo）


!h!foo
需要 %TAG !h! &lt;prefix&gt;（然后表示 &lt;prefix&gt;foo）


!&lt;foo&gt;
逐字标记（始终表示“foo”）




杂项指标







#
一次性评论指示器


`@
两者都保留供将来使用


核心类型（默认自动标签）









!!map
&#123;Hash table, dictionary, mapping&#125;


!!seq
&#123;List, array, tuple, vector, sequence&#125;


!!str
Unicode 字符串


转义码

Numeric
\x12 (8-bit)
\u1234 (16-bit)
\U00102030 (32-bit)



Protective
\\ (\)
\&quot; (“)
\ ( )
\&lt;TAB&gt; (TAB)



C
\0 (NUL)
\a (BEL)
\b (BS)
\f (FF)
\n (LF)
\r (CR)
\t (TAB)
\v (VTAB)



额外的
\e (ESC)
\_ (NBSP)
\N (NEL)
\L (LS)
\P (PS)


更多类型







!!set
&#123;cherries, plums, apples&#125;


!!omap
[one: 1, two: 2]


与语言无关的标量类型









&#123;~, null&#125;
空（无值）。


[1234, 0x4D2, 02333]
[十进制整数、十六进制整数、八进制整数]


[1_230.15, 12.3015e+02]
[固定浮点数，指数浮点数]


[.inf, -.Inf, .NAN]
[无穷大（浮点数），负数，不是数字]


&#123;Y, true, Yes, ON&#125;
布尔真


&#123;n, FALSE, No, off&#125;
布尔假




另见
YAML Reference Card (yaml.org)
Learn X in Y minutes (learnxinyminutes.com)
YAML lint online (yamllint.com)
INI 格式配置文件备忘清单 (jaywcjlove.github.io)
TOML 格式配置文件备忘清单 (jaywcjlove.github.io)

]]></content>
      <categories>
        <category>配置框架</category>
      </categories>
      <tags>
        <tag>Yaml</tag>
        <tag>配置框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue2 备忘录</title>
    <url>/2025/01/08/vue2%20(1)/</url>
    <content><![CDATA[Vue 2 备忘清单渐进式 JavaScript 框架 Vue 2 备忘清单的快速参考列表，包含常用 API 和示例。
入门介绍Vue 是一套用于构建用户界面的渐进式框架

Vue 2.x 官方文档 (v2.cn.vuejs.org)
Vue Router 3.x 官方文档 (v3.router.vuejs.org)
Vue 3 备忘清单



注意：Vue 2.x 版本对应 Vue Router 3.x 路由版本
快速创建 Vue 项目npx @vue/cli create hello-world

参考: Vue CLI 创建一个项目
声明式渲染&lt;div id=&quot;app&quot;&gt;  &#123;&#123; message &#125;&#125;&lt;/div&gt;


var app = new Vue(&#123;  el: &#x27;#app&#x27;,  data: &#123;    message: &#x27;Hello Vue!&#x27;  &#125;&#125;)

基础例子

&lt;div id=&quot;example&quot;&gt;  &lt;p&gt;原始信息: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;  &lt;p&gt;    计算的反向信息: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;  &lt;/p&gt;&lt;/div&gt;


var vm = new Vue(&#123;  el: &#x27;#example&#x27;,  data: &#123;    message: &#x27;Hello&#x27;  &#125;,  computed: &#123;    // 计算属性的 getter    reversedMessage: function () &#123;      // `this` 指向 vm 实例      return this.message.split(&#x27;&#x27;)          .reverse().join(&#x27;&#x27;)    &#125;  &#125;&#125;)

结果
原始信息:  &quot;Hello&quot;计算的反向信息:  &quot;olleH&quot;

绑定元素属性&lt;div id=&quot;app-2&quot;&gt;  &lt;span v-bind:title=&quot;message&quot;&gt;    鼠标悬停几秒钟查看此处动态绑定的提示信息！  &lt;/span&gt;&lt;/div&gt;


var app2 = new Vue(&#123;  el: &#x27;#app-2&#x27;,  data: &#123;    message: &#x27;页面加载于 &#x27; + new Date()        .toLocaleString()  &#125;&#125;)

条件&lt;div id=&quot;app-3&quot;&gt;  &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;


var app3 = new Vue(&#123;  el: &#x27;#app-3&#x27;,  data: &#123;    seen: true  &#125;&#125;)

控制切换一个元素是否显示
循环&lt;div id=&quot;app-4&quot;&gt;  &lt;ol&gt;    &lt;li v-for=&quot;todo in todos&quot;&gt;      &#123;&#123; todo.text &#125;&#125;    &lt;/li&gt;  &lt;/ol&gt;&lt;/div&gt;


var app4 = new Vue(&#123;  el: &#x27;#app-4&#x27;,  data: &#123;    todos: [      &#123; text: &#x27;学习 JavaScript&#x27; &#125;,      &#123; text: &#x27;学习 Vue&#x27; &#125;,      &#123; text: &#x27;整个牛项目&#x27; &#125;    ]  &#125;&#125;)

点击事件处理&lt;div id=&quot;app-5&quot;&gt;  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;  &lt;button v-on:click=&quot;reverseMessage&quot;&gt;    反转消息  &lt;/button&gt;&lt;/div&gt;


var app5 = new Vue(&#123;  el: &#x27;#app-5&#x27;,  data: &#123;    message: &#x27;Hello Vue.js!&#x27;  &#125;,  methods: &#123;    reverseMessage: function () &#123;      this.message = this.message.split(&#x27;&#x27;)            .reverse().join(&#x27;&#x27;)    &#125;  &#125;&#125;)

输入事件处理&lt;div id=&quot;app-6&quot;&gt;  &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;  &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;

v-model 指令，它能轻松实现表单输入和应用状态之间的双向绑定
var app6 = new Vue(&#123;  el: &#x27;#app-6&#x27;,  data: &#123;    message: &#x27;Hello Vue!&#x27;  &#125;&#125;)

模板语法文本&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;span v-once&gt;  这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;

使用 v-once 指令，执行一次性地插值，当数据改变时，插值处的内容不会更新
原始 HTML&lt;p&gt;解释为普通文本: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;  使用 v-html 指令:   &lt;span v-html=&quot;rawHtml&quot;&gt;&lt;/span&gt;&lt;/p&gt;

使用 v-html 指令，输出真正的 HTML
属性&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;&lt;button v-bind:disabled=&quot;isDisabled&quot;&gt;  Button&lt;/button&gt;

如果 isDisabled 的值是 null&#x2F;undefined&#x2F;false 则 disabled 不会被渲染出来
JavaScript 表达式&lt;div id=&quot;app&quot;&gt;  &lt;span&gt;消息: &#123;&#123; msg &#125;&#125;&lt;/span&gt;  &lt;span&gt;&#123;&#123; msg + &#x27;这是字符串&#x27; &#125;&#125;&lt;/span&gt;  &lt;span&gt;&#123;&#123; isWorking ? &#x27;是&#x27;:&#x27;否&#x27; &#125;&#125;&lt;/span&gt;  &lt;span&gt;&#123;&#123; msg.getDetials() &#125;&#125;&lt;/span&gt;  &lt;div v-bind:id=&quot;&#x27;list-&#x27; + id&quot;&gt;&lt;/div&gt;&lt;div&gt;

指令&lt;p v-if=&quot;seen&quot;&gt;  现在你看到我了&lt;/p&gt;

v-if 指令将根据表达式 seen 的值的真假来插入&#x2F;移除 &lt;p&gt; 元素
指令参数&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;

v-bind 指令将该元素 href 属性与表达式 url 的值绑定
&lt;a v-on:click=&quot;doSomething&quot;&gt;...&lt;/a&gt;

v-on 指令，用于监听 DOM 事件，oSomething 是事件名
指令动态参数 v2.6&lt;a v-on:[eventName]=&quot;doSomething&quot;&gt;...&lt;/a&gt;

当 eventName 的值为 focus 时，v-on:[eventName] 将等价于 v-on:focus
指令修饰符&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;  ...&lt;/form&gt;

.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()
指令缩写&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;...&lt;/a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]=&quot;url&quot;&gt; ... &lt;/a&gt;

Class 与 Style 绑定对象语法&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;

传给 v-bind:class 一个对象，以动态地切换 class
与普通的 class 属性共存

&#123;2&#125;&lt;div  class=&quot;static&quot;  v-bind:class=&quot;&#123;    active: isActive,    &#x27;text-danger&#x27;: hasError  &#125;&quot;&gt;&lt;/div&gt;

如下 data
data: &#123;  isActive: true,  hasError: false&#125;

结果渲染为
&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;

绑定的数据对象不必内联定义在模板里

&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;

如下 data
data: &#123;  classObject: &#123;    active: true,    &#x27;text-danger&#x27;: false  &#125;&#125;

结果渲染为
&lt;div class=&quot;static active&quot;&gt;&lt;/div&gt;

三元表达式&lt;div v-bind:class=&quot;[  isActive ? activeClass : &#x27;&#x27;]&quot;&gt;&lt;/div&gt;

数组&lt;div v-bind:class=&quot;[  &#123; active: isActive &#125;, errorClass]&quot;&gt;&lt;/div&gt;

数组语法&lt;div v-bind:class=&quot;[  activeClass, errorClass]&quot;&gt;&lt;/div&gt;

如下 data
data: &#123;  activeClass: &#x27;active&#x27;,  errorClass: &#x27;text-danger&#x27;&#125;

结果渲染为
&lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;

内联样式&lt;div v-bind:style=&quot;&#123;    color: activeColor,    fontSize: fontSize + &#x27;px&#x27;&#125;&quot;&gt;&lt;/div&gt;

如下 data
data: &#123;  activeColor: &#x27;red&#x27;,  fontSize: 30&#125;

结果渲染为
&lt;div style=&quot;color: red; font-size: 30px;&quot;&gt;&lt;/div&gt;

内联样式对象通常更好&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;

如下 data
data: &#123;  styleObject: &#123;    color: &#x27;red&#x27;,    fontSize: &#x27;13px&#x27;  &#125;&#125;

同样的，对象语法常常结合返回对象的计算属性使用
内联样式数组语法&lt;div v-bind:style=&quot;[  baseStyles, overridingStyles]&quot;&gt;&lt;/div&gt;

内联样式多重值&lt;div :style=&quot;&#123;  display: [&#x27;-webkit-box&#x27;, &#x27;flex&#x27;]&#125;&quot;&gt;&lt;/div&gt;

条件渲染v-if&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;

v-else-if

&lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt;B&lt;/div&gt;&lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt;C&lt;/div&gt;&lt;div v-else&gt;  Not A/B/C&lt;/div&gt;

@2.1.0 新增，必须紧跟在带 v-if 或者 v-else-if 的元素之后
v-else

&lt;div v-if=&quot;Math.random() &gt; 0.5&quot;&gt;  现在你看到我了&lt;/div&gt;&lt;div v-else&gt;  现在你看不见我了&lt;/div&gt;

v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面
&lt;template&gt; 上使用 v-if 条件渲染分组&lt;template v-if=&quot;ok&quot;&gt;  &lt;p&gt;Paragraph 1&lt;/p&gt;&lt;/template&gt;

用 key 管理可复用的元素

&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;  &lt;label&gt;Username&lt;/label&gt;  &lt;input placeholder=&quot;输入用户名&quot; key=&quot;username-input&quot;&gt;&lt;/template&gt;&lt;template v-else&gt;  &lt;label&gt;Email&lt;/label&gt;  &lt;input placeholder=&quot;输入邮箱&quot; key=&quot;email-input&quot;&gt;&lt;/template&gt;

v-show&lt;h1 v-show=&quot;ok&quot;&gt;  Hello!&lt;/h1&gt;

带有 v-show 的元素始终会被渲染并保留在 DOM 中，只是简单地切换元素的 CSS 属性 display
列表渲染v-for&#123;3&#125;&lt;ul id=&quot;example-1&quot;&gt;  &lt;li    v-for=&quot;item in items&quot;    :key=&quot;item.message&quot;&gt;    &#123;&#123; item.message &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;

var example1 = new Vue(&#123;  el: &#x27;#example-1&#x27;,  data: &#123;    items: [      &#123; message: &#x27;Foo&#x27; &#125;,      &#123; message: &#x27;Bar&#x27; &#125;    ]  &#125;&#125;)

v-for 可选的第二个参数(索引)&#123;2&#125;&lt;li v-for=&quot;(item, index) in items&quot;&gt;  &#123;&#123; index &#125;&#125;  &#123;&#123; item.message &#125;&#125;&lt;/li&gt;

如下 data
data: &#123;  items: [    &#123; message: &#x27;Foo&#x27; &#125;,    &#123; message: &#x27;Bar&#x27; &#125;  ]&#125;

也可以用 of 替代 in 作为分隔符
&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;

v-for 使用对象

&lt;li v-for=&quot;value in object&quot;&gt;  &#123;&#123; value &#125;&#125;&lt;/li&gt;

如下 data
data: &#123;  object: &#123;    title: &#x27;How to do lists in Vue&#x27;,    author: &#x27;Jane Doe&#x27;,    publishedAt: &#x27;2016-04-10&#x27;  &#125;&#125;

渲染结果
How to do lists in VueJane Doe2016-04-10

提供第二个的参数为 property 名称 (也就是键名)
&lt;div v-for=&quot;(value, name) in object&quot;&gt;  &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;

还可以用第三个参数作为索引
&lt;div v-for=&quot;(value,name,index) in object&quot;&gt;  &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt;

v-for&#x2F;v-if&#123;2,3&#125;&lt;li  v-for=&quot;todo in todos&quot;  v-if=&quot;!todo.isComplete&quot;&gt;  &#123;&#123; todo &#125;&#125;&lt;/li&gt;

只渲染未完成的 todo，下面加上 v-else 示例
&lt;ul v-if=&quot;todos.length&quot;&gt;  &lt;li v-for=&quot;todo in todos&quot;&gt;    &#123;&#123; todo &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt;

注意: v-for 和 v-if 不推荐一起使用参考官方文档
组件上使用 v-for&lt;my-component  v-for=&quot;(item, index) in items&quot;  v-bind:item=&quot;item&quot;  v-bind:index=&quot;index&quot;  v-bind:key=&quot;item.id&quot;&gt;&lt;/my-component&gt;

2.2.0+ 的版本里，当在组件上使用 v-for 时，key 现在是必须的
事件处理监听事件&#123;2&#125;&lt;div id=&quot;example-1&quot;&gt;  &lt;button v-on:click=&quot;counter += 1&quot;&gt;    +1  &lt;/button&gt;  &lt;p&gt;按钮已被点击 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt;

var example1 = new Vue(&#123;  el: &#x27;#example-1&#x27;,  data: &#123;    counter: 0  &#125;&#125;)

事件处理方法

&#123;3&#125;&lt;div id=&quot;example-2&quot;&gt;  &lt;!-- `greet` 是在下面定义的方法名 --&gt;  &lt;button v-on:click=&quot;greet&quot;&gt;    你好  &lt;/button&gt;&lt;/div&gt;

var example2 = new Vue(&#123;  el: &#x27;#example-2&#x27;,  data: &#123;    name: &#x27;Vue.js&#x27;  &#125;,  // 在 `methods` 对象中定义方法  methods: &#123;    greet: function (event) &#123;      // `this` 在方法里指向当前 Vue 实例      alert(&#x27;Hello &#x27; + this.name + &#x27;!&#x27;)      // `event` 是原生 DOM 事件      if (event) &#123;        alert(event.target.tagName)      &#125;    &#125;  &#125;&#125;)

也可以用 JavaScript 直接调用方法
example2.greet() // =&gt; &#x27;Hello Vue.js!&#x27;

内联处理器中的方法

&#123;2,5&#125;&lt;div id=&quot;example-3&quot;&gt;  &lt;button v-on:click=&quot;say(&#x27;hi&#x27;)&quot;&gt;    弹出 hi  &lt;/button&gt;  &lt;button v-on:click=&quot;say(&#x27;what&#x27;)&quot;&gt;    弹出 what  &lt;/button&gt;&lt;/div&gt;

&#123;4&#125;new Vue(&#123;  el: &#x27;#example-3&#x27;,  methods: &#123;    say: function (message) &#123;      alert(message)    &#125;  &#125;&#125;)

访问原始的 DOM 事件，用特殊变量 $event
&lt;button v-on:click=&quot;say(&#x27;what&#x27;, $event)&quot;&gt;  提交&lt;/button&gt;

methods: &#123;  say: function (message, event) &#123;    // 现在我们可以访问原生事件对象    if (event) &#123;      event.preventDefault()    &#125;    alert(message)  &#125;&#125;

事件修饰符&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;submit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即内部元素触发的事件先在此处理 --&gt;&lt;!-- 然后交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 当 event.target 是当前元素自身时触发 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;

事件修饰符 passive&lt;!-- 滚动事件的默认行为(即滚动行为)会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成  --&gt;&lt;!-- 包含 event.preventDefault() 的情况 --&gt;&lt;p v-on:scroll.passive=&quot;onScroll&quot;&gt;  ...&lt;/p&gt;

这个 .passive 修饰符尤其能够提升移动端的性能。
按键修饰符&lt;!-- 在 key 是 Enter 时调用 vm.submit() --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 在 key 是 PageDown 时被调用 --&gt;&lt;input v-on:keyup.page-down=&quot;onPageDown&quot;&gt;&lt;!-- Alt + C --&gt;&lt;input v-on:keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div v-on:click.ctrl=&quot;doSomething&quot;&gt;

.exact 修饰符&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button v-on:click.ctrl.exact=&quot;ctrlClick&quot;&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button v-on:click.exact=&quot;onClick&quot;&gt;

计算属性和侦听器基础例子&lt;div id=&quot;example&quot;&gt;  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;  &lt;p&gt;    计算的反向消息： &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;  &lt;/p&gt;&lt;/div&gt;

var vm = new Vue(&#123;  el: &#x27;#example&#x27;,  data: &#123;    message: &#x27;Hello&#x27;  &#125;,  computed: &#123;    // 计算属性的 getter    reversedMessage: function () &#123;      // `this` 指向 vm 实例      return this.message.split(&#x27;&#x27;)                  .reverse().join(&#x27;&#x27;)    &#125;  &#125;&#125;)

计算属性缓存 vs 方法&lt;p&gt;  计算的反向消息：&quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;&lt;/p&gt;

在组件中，我们可以将同一函数定义为一个方法而不是一个计算属性
methods: &#123;  reversedMessage: function () &#123;    return this.message.split(&#x27;&#x27;)                .reverse().join(&#x27;&#x27;)  &#125;&#125;

两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应式依赖进行缓存的。
计算属性 vs 侦听属性

&lt;div id=&quot;demo&quot;&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;

var vm = new Vue(&#123;  el: &#x27;#demo&#x27;,  data: &#123;    firstName: &#x27;Foo&#x27;,    lastName: &#x27;Bar&#x27;,    fullName: &#x27;Foo Bar&#x27;  &#125;,  watch: &#123;    firstName: function (val) &#123;      this.fullName =           val + &#x27; &#x27; + this.lastName    &#125;,    lastName: function (val) &#123;      this.fullName =          this.firstName + &#x27; &#x27; + val    &#125;  &#125;&#125;)

上面代码是命令式且重复的。将它与计算属性的版本进行比较：
var vm = new Vue(&#123;  el: &#x27;#demo&#x27;,  data: &#123;    firstName: &#x27;Foo&#x27;,    lastName: &#x27;Bar&#x27;  &#125;,  computed: &#123;    fullName: function () &#123;      return this.firstName         + &#x27; &#x27; + this.lastName    &#125;  &#125;&#125;)

计算属性的 setter

computed: &#123;  fullName: &#123;    get: function () &#123;         // getter      return this.firstName + &#x27; &#x27; + this.lastName    &#125;,    set: function (newValue) &#123; // setter      var names = newValue.split(&#x27; &#x27;)      this.firstName = names[0]      this.lastName = names[names.length - 1]    &#125;  &#125;&#125;

表单输入绑定文本&lt;input v-model=&quot;msg&quot; placeholder=&quot;编辑我&quot;&gt;&lt;p&gt;msg is: &#123;&#123; msg &#125;&#125;&lt;/p&gt;

多行文本&#123;3&#125;&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;textarea  v-model=&quot;message&quot;  placeholder=&quot;添加多行&quot;&gt;&lt;/textarea&gt;&lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;

复选框&#123;4&#125;&lt;input  type=&quot;checkbox&quot;  id=&quot;checkbox&quot;  v-model=&quot;checked&quot;&gt;&lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked&#125;&#125;&lt;/label&gt;

多个复选框

&lt;input type=&quot;checkbox&quot; id=&quot;jack&quot; value=&quot;Jack&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;jack&quot;&gt;Jack&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;john&quot; value=&quot;John&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;john&quot;&gt;John&lt;/label&gt;&lt;input type=&quot;checkbox&quot; id=&quot;mike&quot; value=&quot;Mike&quot; v-model=&quot;checkedNames&quot;&gt;&lt;label for=&quot;mike&quot;&gt;Mike&lt;/label&gt;&lt;br&gt;&lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;

如下 data
new Vue(&#123;  el: &#x27;...&#x27;,  data: &#123;    checkedNames: []  &#125;&#125;)

单选按钮&lt;div id=&quot;example-4&quot;&gt;  &lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot;    v-model=&quot;picked&quot;&gt;  &lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;  &lt;br&gt;  &lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot;    v-model=&quot;picked&quot;&gt;  &lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;  &lt;div&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/div&gt;&lt;/div&gt;


new Vue(&#123;  el: &#x27;#example-4&#x27;,  data: &#123;    picked: &#x27;&#x27;  &#125;&#125;)

选择框&lt;select v-model=&quot;selected&quot;&gt;  &lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;  &lt;option&gt;A&lt;/option&gt;  &lt;option&gt;B&lt;/option&gt;  &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;


new Vue(&#123;  el: &#x27;...&#x27;,  data: &#123;    selected: &#x27;&#x27;  &#125;&#125;)

选择框(数组)&lt;select v-model=&quot;selected&quot; multiple&gt;  &lt;option&gt;A&lt;/option&gt;  &lt;option&gt;B&lt;/option&gt;  &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt;


new Vue(&#123;  el: &#x27;...&#x27;,  data: &#123;    selected: []  &#125;&#125;)

v-for 渲染的动态选项

&#123;3-4&#125;&lt;select v-model=&quot;selected&quot;&gt;  &lt;option    v-for=&quot;option in options&quot;    v-bind:value=&quot;option.value&quot;  &gt;    &#123;&#123; option.text &#125;&#125;  &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;


&#123;6-8&#125;new Vue(&#123;  el: &#x27;...&#x27;,  data: &#123;    selected: &#x27;A&#x27;,    options: [      &#123; text: &#x27;One&#x27;, value: &#x27;A&#x27; &#125;,      &#123; text: &#x27;Two&#x27;, value: &#x27;B&#x27; &#125;,      &#123; text: &#x27;Three&#x27;, value: &#x27;C&#x27; &#125;    ]  &#125;&#125;)

值绑定&lt;!-- 当选中时，pc 为字符串 &quot;a&quot; --&gt;&lt;input type=&quot;radio&quot; v-model=&quot;pc&quot; value=&quot;a&quot;&gt;&lt;!-- toggle 为 true 或 false --&gt;&lt;input type=&quot;checkbox&quot; v-model=&quot;toggle&quot;&gt;&lt;!-- 选中第一个选项时selected为字符串 abc --&gt;&lt;select v-model=&quot;selected&quot;&gt;  &lt;option value=&quot;abc&quot;&gt;ABC&lt;/option&gt;&lt;/select&gt;

单选按钮&lt;input  type=&quot;radio&quot;  v-model=&quot;pick&quot;  v-bind:value=&quot;a&quot;&gt;

当选中时
vm.pick === vm.a

复选框&#123;3&#125;&lt;input  type=&quot;checkbox&quot;  v-model=&quot;toggle&quot;  true-value=&quot;yes&quot;  false-value=&quot;no&quot;&gt;


// 当选中时vm.toggle === &#x27;yes&#x27;// 当没有选中时vm.toggle === &#x27;no&#x27;

选择框的选项&lt;select v-model=&quot;selected&quot;&gt;  &lt;!-- 内联对象字面量 --&gt;  &lt;option v-bind:value=&quot;&#123; number: 123 &#125;&quot;&gt;    123  &lt;/option&gt;&lt;/select&gt;

当选中时
typeof vm.selected // =&gt; &#x27;object&#x27;vm.selected.number // =&gt; 123

修饰符&lt;!-- lazy:在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot;&gt;&lt;!-- number:自动将用户的输入值转为数值类型 --&gt;&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;&lt;!-- trim:自动过滤用户输入的首尾空白字符 --&gt;&lt;input v-model.trim=&quot;msg&quot;&gt;

组件基础单文件组件


将 HTML&#x2F;CSS&#x2F;JS 三部分存放到一个 Hello.vue 文件中
&lt;template&gt;  &lt;p&gt;&#123;&#123; title &#125;&#125; World!&lt;/p&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &#x27;Hello&#x27;,    props: &#123;      title: &#123;        type: String,        default: &#x27;Hello&#x27;      &#125;    &#125;,    data: function() &#123;      return &#123;        greeting: &quot;Hello&quot;      &#125;;    &#125;  &#125;;&lt;/script&gt;&lt;style scoped&gt;  p &#123;    font-size: 2em;    text-align: center;  &#125;&lt;/style&gt;

使用 Hello.vue 组件
&lt;script&gt;  import Vue from &quot;vue&quot;;  import Hello from &quot;./Hello&quot;;  export default &#123;    components: &#123; Hello &#125;  &#125;&lt;/script&gt;&lt;template&gt;  &lt;div&gt;    &lt;Hello :title=&quot;&#x27;aaaa&#x27;&quot;&gt;&lt;/Hello&gt;  &lt;/div&gt;&lt;/template&gt;



基本示例

Vue.component(&#x27;button-counter&#x27;, &#123;  data: function () &#123;    return &#123;      count: 0    &#125;  &#125;,  template: `    &lt;button v-on:click=&quot;count++&quot;&gt;      你点击了我 &#123;&#123; count &#125;&#125; 次    &lt;/button&gt;  `&#125;)

组件是可复用的 Vue 实例
&lt;div id=&quot;components-demo&quot;&gt;  &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;


new Vue(&#123;  el: &#x27;#components-demo&#x27;&#125;)

组件的复用
&lt;div id=&quot;components-demo&quot;&gt;  &lt;button-counter&gt;&lt;/button-counter&gt;  &lt;button-counter&gt;&lt;/button-counter&gt;  &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;

单个根元素&#123;4&#125;Vue.component(&#x27;blog-post&#x27;, &#123;  props: [&#x27;post&#x27;],  template: `    &lt;div class=&quot;blog-post&quot;&gt;      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  `&#125;)


&lt;blog-post  v-for=&quot;post in posts&quot;  v-bind:key=&quot;post.id&quot;  v-bind:post=&quot;post&quot;&gt;&lt;/blog-post&gt;

向子组件传递数据Vue.component(&#x27;blog-post&#x27;, &#123;  props: [&#x27;title&#x27;],  template: &#x27;&lt;h3&gt;&#123;&#123; title &#125;&#125;&lt;/h3&gt;&#x27;&#125;)

当值传递给一个 prop attribute 的时候，变成了组件实例的一个 property
&lt;blog-post title=&quot;写博客&quot;&gt;&lt;/blog-post&gt;&lt;blog-post title=&quot;如此有趣&quot;&gt;&lt;/blog-post&gt;

data 必须是一个函数data: function () &#123;  return &#123;    count: 0  &#125;&#125;

组件的 data 选项必须是一个函数
监听子组件事件

&#123;7&#125;Vue.component(&#x27;blog-post&#x27;, &#123;  props: [&#x27;post&#x27;],  template: `    &lt;div class=&quot;blog-post&quot;&gt;      &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt;      &lt;button        v-on:click=&quot;$emit(&#x27;enlarge-txt&#x27;)&quot;      &gt;放大文字      &lt;/button&gt;      &lt;div v-html=&quot;post.content&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  `&#125;)


&#123;3&#125;&lt;blog-post  ...  v-on:enlarge-text=&quot;postFontSize += 0.1&quot;&gt;&lt;/blog-post&gt;

可以使用 $emit 的第二个参数来提供这个值
&#123;2&#125;&lt;button  v-on:click=&quot;$emit(&#x27;enlarge-text&#x27;, 0.1)&quot;&gt;  Enlarge text&lt;/button&gt;

通过 $event 访问到被抛出的这个值
&#123;3&#125;&lt;blog-post  ...  v-on:enlarge-text=&quot;postFontSize += $event&quot;&gt;&lt;/blog-post&gt;

如果这个事件处理函数是一个方法
&#123;3&#125;&lt;blog-post  ...  v-on:enlarge-text=&quot;onEnlargeText&quot;&gt;&lt;/blog-post&gt;

那么这个值将会作为第一个参数传入这个方法
methods: &#123;  onEnlargeText: function(enlargeAmount) &#123;    this.postFontSize += enlargeAmount  &#125;&#125;

在组件上使用 v-model

自定义事件也可以用于创建支持 v-model 的自定义输入组件。
&lt;input v-model=&quot;searchText&quot;&gt;

等价于
&lt;input  v-bind:value=&quot;searchText&quot;  v-on:input=&quot;searchText = $event.target.value&quot;&gt;

当用在组件上时，v-model 则会这样：
&lt;custom-input  v-bind:value=&quot;searchText&quot;  v-on:input=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt;

为了让它正常工作，这个组件内的 &lt;input&gt; 必须：

将其 value attribute 绑定到一个名叫 value 的 prop 上
在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出


Vue.component(&#x27;custom-input&#x27;, &#123;  props: [&#x27;value&#x27;],  template: `    &lt;input      v-bind:value=&quot;value&quot;      v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;    &gt;  `&#125;)

现在 v-model 就应该可以在这个组件上完美地工作起来了
&#123;2&#125;&lt;custom-input  v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;

通过插槽分发内容&lt;alert-box&gt;  发生了不好的事情。&lt;/alert-box&gt;


&#123;5&#125;Vue.component(&#x27;alert-box&#x27;, &#123;  template: `    &lt;div class=&quot;demo-alert-box&quot;&gt;      &lt;strong&gt;Error!&lt;/strong&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/div&gt;  `&#125;)

动态组件示例

&lt;div id=&quot;dynamic-component-demo&quot; class=&quot;demo&quot;&gt;  &lt;button    v-for=&quot;tab in tabs&quot;    v-bind:key=&quot;tab&quot;    v-bind:class=&quot;[&#x27;tab-button&#x27;, &#123; active: currentTab === tab &#125;]&quot;    v-on:click=&quot;currentTab = tab&quot;  &gt;    &#123;&#123; tab &#125;&#125;  &lt;/button&gt;  &lt;component v-bind:is=&quot;currentTabComponent&quot; class=&quot;tab&quot;&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt;  Vue.component(&quot;tab-home&quot;, &#123;    template: &quot;&lt;div&gt;Home component&lt;/div&gt;&quot;  &#125;);  Vue.component(&quot;tab-posts&quot;, &#123;    template: &quot;&lt;div&gt;Posts component&lt;/div&gt;&quot;  &#125;);  Vue.component(&quot;tab-archive&quot;, &#123;    template: &quot;&lt;div&gt;Archive component&lt;/div&gt;&quot;  &#125;);  new Vue(&#123;    el: &quot;#dynamic-component-demo&quot;,    data: &#123;      currentTab: &quot;Home&quot;,      tabs: [&quot;Home&quot;, &quot;Posts&quot;, &quot;Archive&quot;]    &#125;,    computed: &#123;      currentTabComponent: function() &#123;        return &quot;tab-&quot; + this.currentTab.toLowerCase();      &#125;    &#125;  &#125;);&lt;/script&gt;

解析 DOM 模板时的注意事项有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。有些元素，诸如 &lt;li&gt;、&lt;tr&gt; 和 &lt;option&gt;，只能出现在其它某些特定的元素内部
&lt;table&gt;  &lt;blog-post-row&gt;&lt;/blog-post-row&gt;&lt;/table&gt;

&lt;blog-post-row&gt; 会被作为无效的内容提升到外部

如果我们从以下来源使用模板的话，这条限制是不存在的

字符串 (例如：template: &#39;...&#39;)
单文件组件 (.vue)
&lt;script type=&quot;text/x-template&quot;&gt;



过渡 &amp; 动画单元素&#x2F;组件的过渡

&lt;template&gt;  &lt;button v-on:click=&quot;show = !show&quot;&gt;    切换  &lt;/button&gt;  &lt;transition name=&quot;fade&quot;&gt;    &lt;p v-if=&quot;show&quot;&gt;切换内容&lt;/p&gt;  &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data: function() &#123;      return &#123;        show: true      &#125;;    &#125;  &#125;;&lt;/script&gt;&lt;style scoped&gt;  .fade-enter-active, .fade-leave-active &#123;    transition: opacity .5s;  &#125;  /* .fade-leave-active 低于 2.1.8 版本 */  .fade-enter, .fade-leave-to &#123;    opacity: 0;  &#125;&lt;/style&gt;

CSS 过渡

&lt;template&gt;  &lt;button @click=&quot;show = !show&quot;&gt;    切换渲染  &lt;/button&gt;  &lt;transition name=&quot;slide-fade&quot;&gt;    &lt;p v-if=&quot;show&quot;&gt;切换内容&lt;/p&gt;  &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data: function() &#123;      return &#123;        show: true      &#125;;    &#125;  &#125;;&lt;/script&gt;&lt;style scoped&gt;  /* 可以设置不同的进入和离开动画 */  /* 设置持续时间和动画函数 */  .slide-fade-enter-active &#123;    transition: all .3s ease;  &#125;  .slide-fade-leave-active &#123;    transition: all .8s cubic-bezier(1.0, 0.5, 0.8, 1.0);  &#125;  /* .slide-fade-leave-active 用于 2.1.8 以下版本 */   .slide-fade-enter, .slide-fade-leave-to &#123;    transform: translateX(10px);    opacity: 0;  &#125;&lt;/style&gt;

CSS 动画

&lt;template&gt;  &lt;button @click=&quot;show = !show&quot;&gt;切换展示&lt;/button&gt;  &lt;transition name=&quot;bounce&quot;&gt;    &lt;p v-if=&quot;show&quot;&gt;切换内容&lt;/p&gt;  &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data: function() &#123;      return &#123;        show: true      &#125;;    &#125;  &#125;;&lt;/script&gt;&lt;style scoped&gt;.bounce-enter-active &#123;  animation: bounce-in .5s;&#125;.bounce-leave-active &#123;  animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123;  0% &#123;    transform: scale(0);  &#125;  50% &#123;    transform: scale(1.5);  &#125;  100% &#123;    transform: scale(1);  &#125;&#125;&lt;/style&gt;

过渡的类名




:-
:-



v-enter
定义进入过渡的开始状态 #


v-enter-active
定义进入过渡生效时的状态 #


v-enter-to (2.1.8)
定义进入过渡的结束状态 #


v-leave
定义离开过渡的开始状态 #


v-leave-active
定义离开过渡生效时的状态 #


v-leave-to (2.1.8)
定义离开过渡的结束状态 #


如果你使用了 &lt;transition name=&quot;my-tran&quot;&gt;，那么 v-enter 会替换为 my-tran-enter。
自定义过渡的类名


:-
:-



enter-class
#


enter-active-class
#


enter-to-class (2.1.8+)
#


leave-class
#


leave-active-class
#


leave-to-class (2.1.8+)
#



&lt;transition  name=&quot;custom-classes-transition&quot;  enter-active-class=&quot;animated tada&quot;  leave-active-class=&quot;animated bounceOutRight&quot;&gt;  &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;&lt;/transition&gt;

显性的过渡持续时间&lt;transition&gt; 组件上的 duration prop 定制一个显性的过渡持续时间 (以毫秒计)：
&lt;transition :duration=&quot;1000&quot;&gt;  ...&lt;/transition&gt;

你也可以定制进入和移出的持续时间：
&lt;transition :duration=&quot;&#123;  enter: 500,  leave: 800&#125;&quot;&gt;  ...&lt;/transition&gt;

初始渲染的过渡

可以通过 appear attribute 设置节点在初始渲染的过渡
&lt;transition appear&gt;  &lt;!-- ... --&gt;&lt;/transition&gt;

这里默认和进入&#x2F;离开过渡一样，同样也可以自定义 CSS 类名
&lt;transition  appear  appear-class=&quot;custom-appear-class&quot;  appear-to-class=&quot;custom-appear-to-class&quot;  appear-active-class=&quot;custom-appear-active-class&quot;&gt;  &lt;!-- ... --&gt;&lt;/transition&gt;

自定义 JavaScript 钩子：
&lt;transition  appear  v-on:before-appear=&quot;customBeforeAppearHook&quot;  v-on:appear=&quot;customAppearHook&quot;  v-on:after-appear=&quot;customAfterAppearHook&quot;  v-on:appear-cancelled=&quot;customAppearCancelledHook&quot;&gt;  &lt;!-- ... --&gt;&lt;/transition&gt;

无论是 appear attribute 还是 v-on:appear 钩子都会生成初始渲染过渡
JavaScript 钩子&lt;transition  v-on:before-enter=&quot;beforeEnter&quot;  v-on:enter=&quot;enter&quot;  v-on:after-enter=&quot;afterEnter&quot;  v-on:enter-cancelled=&quot;enterCancelled&quot;  v-on:before-leave=&quot;beforeLeave&quot;  v-on:leave=&quot;leave&quot;  v-on:after-leave=&quot;afterLeave&quot;  v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;  &lt;!-- ... --&gt;&lt;/transition&gt;

钩子函数可以结合 CSS transitions&#x2F;animations 使用，也可以单独使用
列表的进入&#x2F;离开过渡

&lt;template&gt;  &lt;button v-on:click=&quot;add&quot;&gt;添加&lt;/button&gt;  &lt;button v-on:click=&quot;remove&quot;&gt;删除&lt;/button&gt;  &lt;transition-group name=&quot;list&quot; tag=&quot;p&quot;&gt;    &lt;span v-for=&quot;item in items&quot; v-bind:key=&quot;item&quot; class=&quot;list-item&quot;&gt;      &#123;&#123; item &#125;&#125;    &lt;/span&gt;  &lt;/transition-group&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    data: function() &#123;      return &#123;        items: [1,2,3,4,5,6,7,8,9],        nextNum: 10      &#125;;    &#125;,    methods: &#123;      randomIndex: function () &#123;        return Math.floor(Math.random() * this.items.length)      &#125;,      add: function () &#123;        this.items.splice(this.randomIndex(), 0, this.nextNum++)      &#125;,      remove: function () &#123;        this.items.splice(this.randomIndex(), 1)      &#125;,    &#125;  &#125;;&lt;/script&gt;&lt;style scoped&gt;  .list-item &#123;    display: inline-block;    margin-right: 10px;  &#125;  .list-enter-active, .list-leave-active &#123;    transition: all 1s;  &#125;  /* .list-leave-active 适用于 2.1.8 以下版本 */  .list-enter, .list-leave-to &#123;    opacity: 0;    transform: translateY(30px);  &#125;&lt;/style&gt;

Vue 2 API 参考全局配置




:-
:-



silent
取消所有的日志与警告 #


optionMergeStrategies
自定义合并策略的选项 #


devtools
是否允许 devtools 检查 #


errorHandler
未捕获错误的处理函数 (开发模式生效) #


warnHandler (2.4.0)
运行时警告处理函数 #


ignoredElements
忽略 Vue 之外的 (自定义元素) #


keyCodes
v-on 自定义键位别名 #


performance (2.2.0)
性能追踪 #


productionTip (2.2.0)
是否生成生产提示 #


全局 API




:-
:-



Vue.extend
Vue 构造器，创建一个“子类” #


Vue.nextTick
执行延迟回调 #


Vue.set
向响应式对象中添加一个属性 #


Vue.delete
删除对象的 property #


Vue.directive
注册或获取全局指令 #


Vue.filter
注册或获取全局过滤器 #


Vue.component
注册或获取全局组件 #


Vue.use
安装 Vue.js 插件 #


Vue.mixin
全局注册一个混入 #


Vue.compile
将模板字符串编译成 render 函数 #


Vue.observable (2.6.0)
让一个对象可响应 #


Vue.version
Vue 安装版本号 #


数据


:-
:-



data
实例的数据对象 #


props
接收来自父组件的数据 #


propsData
创建实例时传递 props #


computed
计算属性将被混入到 Vue 实例中 #


methods
将被混入到 Vue 实例中 #


watch
对象键是观察的表达式，值是回调函数 #


DOM


:-
:-



el
实例的挂载目标 #


template
字符串模板作为 Vue 实例的标识使用 #


render
字符串模板的代替方案 #


renderError (2.2.0)
render错误时提供另一种渲染 #


生命周期钩子




:-
:-



beforeCreate
实例初始化之后 #


created
实例创建完成后被立即同步调用 #


beforeMount
在挂载开始之前被调用 #


mounted
实例被挂载后调用 #


beforeUpdate
数据改变后 DOM 更新之前调用 #


updated
数据更改更新完毕之后被调用 #


activated
keep-alive 缓存组件激活时调用 #


deactivated
keep-alive 缓存的组件失活时调用 #


beforeDestroy
实例销毁之前调用 #


destroyed
实例销毁后调用 #


errorCaptured (2.5.0)
来自后代组件的错误时被调用 #


资源


:-
:-



directives
包含 Vue 实例可用指令的哈希表 #


filters
包含 Vue 实例可用过滤器的哈希表 #


components
包含 Vue 实例可用组件的哈希表 #


组合


:-
:-



parent
指定已创建的实例之父实例 #


mixins
接收一个混入对象的数组 #


extends
声明扩展另一个组件 #


provide/inject (2.2.0)
祖组件向所有子孙后代注入依赖 #


其它


:-
:-



name
允许组件模板递归地调用自身 #


delimiters
改变纯文本插入分隔符 #


functional
使组件无状态和无实例 #


model (2.2.0)
使用 v-model 时定制 prop 和 event #


inheritAttrs (2.4.0)
#


comments (2.4.0)
是否保留模板中的HTML注释 #


实例方法 &#x2F; 数据


:-
:-



vm.$watch
观察 Vue 实例上的一个表达式或者一个函数计算结果的变化 #


vm.$set
全局 Vue.set 的别名 #


vm.$delete
全局 Vue.delete 的别名 #


实例 property




:-
:-



vm.$data
观察的数据对象 #


vm.$props (2.2.0)
组件接收的 props 对象 #


vm.$el
实例使用的根 DOM 元素 #


vm.$options
实例的初始化选项 #


vm.$parent
父实例 #


vm.$root
当前组件树的根实例 #


vm.$children
当前实例的直接子组件 #


vm.$slots
访问被插槽分发的内容 #


vm.$scopedSlots (2.1.0)
访问作用域插槽 #


vm.$refs
DOM 元素和组件实例 #


vm.$isServer
是否运行于服务器 #


vm.$attrs (2.4.0)
包含父作用域中不作为 prop 被识别的属性绑定 ( #


vm.$listeners (2.4.0)
包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器 #


实例方法 &#x2F; 事件


:-
:-



vm.$on
监听当前实例上的自定义事件 #


vm.$once
监听一个自定义事件，只触发一次 #


vm.$off
移除自定义事件监听器 #


vm.$emit
触发当前实例上的事 #


实例方法 &#x2F; 生命周期


:-
:-



vm.$mount
手动地挂载一个未挂载的实例 #


vm.$forceUpdate
迫使 Vue 实例重新渲染 #


vm.$nextTick
回调延迟执行 #


vm.$destroy
完全销毁一个实例 #


指令




:-
:-



v-text
更新元素的 textContent #


v-html
更新元素的 innerHTML #


v-show
切换元素的 display css 属性 #


v-if
有条件地渲染元素 #


v-else
#


v-else-if (2.1.0)
#


v-for
多次渲染元素或模板块 #


v-on
绑定事件监听器 #


v-bind
动态地绑定一个或多个属性  #


v-model
创建双向绑定 #


v-slot
提供插槽或接收 prop 的插槽 #


v-pre
跳过元素和它的子元素编译过程 #


v-cloak
保持在元素上直到实例结束编译 #


v-once
只渲染元素和组件一次 #


特殊 attribute


:-
:-



key
用在 Vue 的虚拟 DOM 算法 #


ref
元素或子组件注册引用信息 #


is
限制是否更新 #


slot
推荐 2.6.0 新增的 v-slot #


slot-scope
推荐 2.6.0 新增的 v-slot #


scope
2.5.0 新增的 slot-scope 取代 #


内置的组件


:-
:-



&lt;component&gt;
渲染一个元组件为动态组件 #


&lt;transition&gt;
单个元素&#x2F;组件的过渡效果 #


&lt;transition-group&gt;
多个元素&#x2F;组件的过渡效果 #


&lt;keep-alive&gt;
不活动的实例缓存不销毁 #


&lt;slot&gt;
组件模板中的内容分发插槽 #


v-on (事件)修饰符




:-
:-



v-on:click.stop #
调用 event.stopPropagation()。


v-on:click.prevent #
调用 event.preventDefault()。


v-on:click.capture #
添加事件侦听器时使用 capture 模式。


v-on:click.self #
只当事件是从侦听器绑定的元素本身触发时才触发回调。


v-on:click.&#123;keyCode|keyAlias&#125; #
只当事件是从特定键触发时才触发回调。


v-on:click.native #
监听组件根元素的原生事件。


v-on:click.once #
只触发一次回调。


v-on:click.passive (2.3.0) #
以 { passive: true } 模式添加侦听器




v-on (鼠标)修饰符


:-
:-



v-on:click.left #
只当点击鼠标左键时触发


v-on:click.right #
只当点击鼠标右键时触发


v-on:click.middle #
只当点击鼠标中键时触发


在 (2.2.0) 中新增
系统修饰键


:-
:-



v-on:keyup.ctrl (2.1.0)
#


v-on:keyup.alt (2.1.0)
#


v-on:keyup.shift (2.1.0)
#


v-on:keyup.meta (2.1.0)
#


Keyboard 按键修饰符


:-
:-



v-on:keyup.enter
#


v-on:keyup.tab
#


v-on:keyup.delete
捕获“删除”和“退格”键 #


v-on:keyup.esc
#


v-on:keyup.space
#


v-on:keyup.up
#


v-on:keyup.down
#


v-on:keyup.left
#


v-on:keyup.right
#


v-bind 修饰符


:-
:-



v-bind.prop #
作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？)


v-bind.camel (2.1.0+) #
将 kebab-case attribute 名转换为 camelCase。


v-bind.sync (2.3.0+) #
语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。




另见
Vue Essentials Cheat-Sheet.pdf (vuemastery.com)
Vue 2 官方文档 (vuejs.org)
Vue 2 实例方法事件 (marozed.com)

]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>前端技术</tag>
        <tag>Vue2</tag>
      </tags>
  </entry>
  <entry>
    <title>Java备忘录</title>
    <url>/2025/01/07/java%E8%AF%AD%E6%B3%95%E9%80%9F%E8%AE%B0/</url>
    <content><![CDATA[Java 备忘清单该备忘单是针对 Java 初学者的速成课程，有助于复习 Java 语言的基本语法。
入门Hello.java

public class Hello &#123;  // 主要方法  public static void main(String[] args)  &#123;    // 输出: Hello, world!    System.out.println(&quot;Hello, world!&quot;);  &#125;&#125;

编译和运行
$ javac Hello.java$ java HelloHello, world!

变量 Variablesint num = 5;float floatNum = 5.99f;char letter = &#x27;D&#x27;;boolean bool = true;String site = &quot;jaywcjlove.github.io&quot;;

原始数据类型




数据类型
大小
默认
范围



byte
1 byte
0
-128 ^to^ 127


short
2 byte
0
-2^15^ ^to^ 2^15^-1


int
4 byte
0
-2^31^ ^to^ 2^31^-1


long
8 byte
0
-2^63^ ^to^ 2^63^-1


float
4 byte
0.0f
N&#x2F;A


double
8 byte
0.0d
N&#x2F;A


char
2 byte
\u0000
0 ^to^ 65535


boolean
N&#x2F;A
false
true &#x2F; false




字符串 StringsString first = &quot;John&quot;;String last = &quot;Doe&quot;;String name = first + &quot; &quot; + last;System.out.println(name);

查看: Strings
循环 LoopsString word = &quot;QuickRef&quot;;for (char c: word.toCharArray()) &#123;  System.out.print(c + &quot;-&quot;);&#125;// 输出: Q-u-i-c-k-R-e-f-

查看: Loops
数组 Arrayschar[] chars = new char[10];chars[0] = &#x27;a&#x27;chars[1] = &#x27;b&#x27;String[] letters = &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125;;int[] mylist = &#123;100, 200&#125;;boolean[] answers = &#123;true, false&#125;;

查看: Arrays
交换变量 Swapint a = 1;int b = 2;System.out.println(a + &quot; &quot; + b); // 1 2int temp = a;a = b;b = temp;System.out.println(a + &quot; &quot; + b); // 2 1

类型转换 Type Casting// Widening// byte&lt;short&lt;int&lt;long&lt;float&lt;doubleint i = 10;long l = i;               // 10// Narrowingdouble d = 10.02;long l = (long)d;         // 10String.valueOf(10);       // &quot;10&quot;Integer.parseInt(&quot;10&quot;);   // 10Double.parseDouble(&quot;10&quot;); // 10.0

条件语句 Conditionalsint j = 10;if (j == 10) &#123;  System.out.println(&quot;I get printed&quot;);&#125; else if (j &gt; 10) &#123;  System.out.println(&quot;I don&#x27;t&quot;);&#125; else &#123;  System.out.println(&quot;I also don&#x27;t&quot;);&#125;

查看: [Conditionals](#条件语句 Conditionals)
用户输入Scanner in = new Scanner(System.in);String str = in.nextLine();System.out.println(str);int num = in.nextInt();System.out.println(num);

Java 字符串基本的String str1 = &quot;value&quot;;String str2 = new String(&quot;value&quot;);String str3 = String.valueOf(123);

字符串连接String s = 3 + &quot;str&quot; + 3;     // 3str3String s = 3 + 3 + &quot;str&quot;;     // 6strString s = &quot;3&quot; + 3 + &quot;str&quot;;   // 33strString s = &quot;3&quot; + &quot;3&quot; + &quot;23&quot;;  // 3323String s = &quot;&quot; + 3 + 3 + &quot;23&quot;; // 3323String s = 3 + 3 + 23;        // 29

字符串生成器

StringBuilder sb = new StringBuilder(10);


┌───┬───┬───┬───┬───┬───┬───┬───┬───┐|   |   |   |   |   |   |   |   |   |└───┴───┴───┴───┴───┴───┴───┴───┴───┘0   1   2   3   4   5   6   7   8   9


sb.append(&quot;Reference&quot;);


┌───┬───┬───┬───┬───┬───┬───┬───┬───┐| R | e | f | e | r | e | n | c | e |└───┴───┴───┴───┴───┴───┴───┴───┴───┘0   1   2   3   4   5   6   7   8   9


sb.delete(3, 9);


┌───┬───┬───┬───┬───┬───┬───┬───┬───┐| R | e | f |   |   |   |   |   |   |└───┴───┴───┴───┴───┴───┴───┴───┴───┘0   1   2   3   4   5   6   7   8   9


sb.insert(0, &quot;My &quot;);


┌───┬───┬───┬───┬───┬───┬───┬───┬───┐| M | y |   | R | e | f |   |   |   |└───┴───┴───┴───┴───┴───┴───┴───┴───┘0   1   2   3   4   5   6   7   8   9


sb.append(&quot;!&quot;);


┌───┬───┬───┬───┬───┬───┬───┬───┬───┐| M | y |   | R | e | f | ! |   |   |└───┴───┴───┴───┴───┴───┴───┴───┴───┘0   1   2   3   4   5   6   7   8   9

比较String s1 = &quot;QuickRef&quot;;String s2 = new String(&quot;QuickRef&quot;);s1 == s2                     // falses1.equals(s2)                // true// intern 方法获得字符串常量池中的惟一引用s1 == s2.intern()            // true&quot;AB&quot;.equalsIgnoreCase(&quot;ab&quot;)  // true

操纵String str = &quot;Abcd&quot;;str.toUpperCase();     // ABCDstr.toLowerCase();     // abcdstr.concat(&quot;#&quot;);       // Abcd#str.replace(&quot;b&quot;, &quot;-&quot;); // A-cd&quot;  abc &quot;.trim();       // abc&quot;ab&quot;.toCharArray();    // &#123;&#x27;a&#x27;, &#x27;b&#x27;&#125;

信息String str = &quot;abcd&quot;;str.charAt(2);       // cstr.indexOf(&quot;a&quot;)     // 0str.indexOf(&quot;z&quot;)     // -1str.length();        // 4str.toString();      // abcdstr.substring(2);    // cdstr.substring(2,3);  // cstr.contains(&quot;c&quot;);   // truestr.endsWith(&quot;d&quot;);   // truestr.startsWith(&quot;a&quot;); // truestr.isEmpty();       // false

不可变String str = &quot;hello&quot;;str.concat(&quot;world&quot;);// 输出: helloSystem.out.println(str);


String str = &quot;hello&quot;;String concat = str.concat(&quot;world&quot;);// 输出: helloworldSystem.out.println(concat);

一旦创建就不能修改，任何修改都会创建一个新的String
Java 数组声明 Declareint[] a1;int[] a2 = &#123;1, 2, 3&#125;;int[] a3 = new int[]&#123;1, 2, 3&#125;;int[] a4 = new int[3];a4[0] = 1;a4[2] = 2;a4[3] = 3; // 会出现索引越界异常

修改 Modifyint[] a = &#123;1, 2, 3&#125;;System.out.println(a[0]); // 1a[0] = 9;System.out.println(a[0]); // 9System.out.println(a.length); // 3

循环 (读 &amp; 写)int[] arr = &#123;1, 2, 3&#125;;for (int i=0; i &lt; arr.length; i++) &#123;    arr[i] = arr[i] * 2;    System.out.print(arr[i] + &quot; &quot;);&#125;// 输出: 2 4 6

Loop (Read)String[] arr = &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125;;for (int a: arr) &#123;    System.out.print(a + &quot; &quot;);&#125;// 输出: a b c

二维数组 Multidimensional Arraysint[][] matrix = &#123; &#123;1, 2, 3&#125;, &#123;4, 5&#125; &#125;;int x = matrix[1][0];  // 4// [[1, 2, 3], [4, 5]]Arrays.deepToString(matrix)for (int i = 0; i &lt; a.length; ++i) &#123;  for(int j = 0; j &lt; a[i].length; ++j) &#123;    System.out.println(a[i][j]);  &#125;&#125;// 输出: 1 2 3 4 5 6 7

排序 Sortchar[] chars = &#123;&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;&#125;;Arrays.sort(chars);// [a, b, c]Arrays.toString(chars);

Java 条件语句运算符


+ (加法运算符(也用于字符串连接))
- (减法运算符)
* (乘法运算符)
/ (分区运算符)
% (余数运算符)
= (简单赋值运算符)
++ (增量运算符；将值增加 1)
-- (递减运算符；将值减 1)
! (逻辑补码运算符；反转布尔值)





== (等于)
!= (不等于)
&gt; (比…更棒)
&gt;= (大于或等于)
&lt; (少于)
&lt;= (小于或等于)





&amp;&amp; 条件与
|| 条件或
?: 三元(if-then-else 语句的简写)





instanceof (将对象与指定类型进行比较)





~ (一元按位补码)
&lt;&lt; (签名左移)
&gt;&gt; (有符号右移)
&gt;&gt;&gt; (无符号右移)
&amp; (按位与)
^ (按位异或)
| (按位包含 OR)



If elseint k = 15;if (k &gt; 20) &#123;  System.out.println(1);&#125; else if (k &gt; 10) &#123;  System.out.println(2);&#125; else &#123;  System.out.println(3);&#125;

Switch

int month = 3;String str;switch (month) &#123;  case 1:    str = &quot;January&quot;;    break;  case 2:    str = &quot;February&quot;;    break;  case 3:    str = &quot;March&quot;;    break;  default:    str = &quot;Some other month&quot;;    break;&#125;// 输出: Result MarchSystem.out.println(&quot;Result &quot; + str);

三元运算符int a = 10;int b = 20;int max = (a &gt; b) ? a : b;// 输出: 20System.out.println(max);

逻辑运算符// 与运算if (condition1 &amp;&amp; condition2) &#123;  // 如果 condition1 和 condition2 都成立  // 则执行此处的代码&#125;// 或运算if (condition1 || condition2) &#123;  // 如果condition1或condition2任意一个成立  // 则执行此处的代码&#125;// 非运算if (!condition) &#123;  // 如果条件不成立，则执行此处的代码&#125;

比较运算// 等于if (a == b) &#123;    // 如果a等于b，则执行此处的代码&#125;// 不等于if (a != b) &#123;    // 如果a不等于b，则执行此处的代码&#125;// 大于、大于等于、小于、小于等于if (a &gt; b) &#123;&#125;if (a &gt;= b) &#123;&#125;if (a &lt; b) &#123;&#125;if (a &lt;= b) &#123;&#125;

Java 循环For 循环for (int i = 0; i &lt; 10; i++) &#123;  System.out.print(i);&#125;// 输出: 0123456789


for (int i = 0,j = 0; i &lt; 3; i++,j--) &#123;  System.out.print(j + &quot;|&quot; + i + &quot; &quot;);&#125;// 输出: 0|0 -1|1 -2|2

增强的 For 循环int[] numbers = &#123;1,2,3,4,5&#125;;for (int number: numbers) &#123;  System.out.print(number);&#125;// 输出: 12345

用于循环数组或列表
While 循环int count = 0;while (count &lt; 5) &#123;  System.out.print(count);  count++;&#125;// 输出: 01234

Do While 循环int count = 0;do &#123;  System.out.print(count);  count++;&#125; while (count &lt; 5);// 输出: 01234

继续声明for (int i = 0; i &lt; 5; i++) &#123;  if (i == 3) &#123;    continue;  &#125;  System.out.print(i);&#125;// 输出: 01245

中断语句for (int i = 0; i &lt; 5; i++) &#123;  System.out.print(i);  if (i == 3) &#123;    break;  &#125;&#125;// 输出: 0123

Java 多线程创建线程

// 实现Runnable接口public class RunnableThread implements Runnable &#123;    @Override    public void run() &#123;       // todo something    &#125;&#125;

实现Callable接口,T 替换成实际类型
public class CallableTask implements Callable&lt;T&gt; &#123;    @Override    public T call() throws Exception &#123;        // todo something        return null;    &#125;&#125;

继承Thrad类
public class ExtendsThread extends Thread &#123;    @Override    public void run() &#123;       // todo something    &#125;&#125;

运行线程
public static void main(String[] args) throws ExecutionException, InterruptedException &#123;    new Thread(new RunnableThread()).start();    new ExtendsThread2().start();    FutureTask&lt;Integer&gt; integerFutureTask = new FutureTask&lt;&gt;(new CallableTask());    integerFutureTask.run();&#125;

线程池
corePoolSize: 核心线程数
maximumPoolSize: 最大线程数
keepAliveTime: 线程空闲时间
timeUni: 线程空闲时间单位
workQueue: 线程等待队列
threadFactory: 线程创建工厂
handler: 拒绝策略

ThreadPoolExecutor threadPoolExecutor  = new ThreadPoolExecutor(  2, 5,  5, TimeUnit.SECONDS,  new ArrayBlockingQueue&lt;&gt;(10),  new DefaultThreadFactory(&quot;pollName&quot;),  new ThreadPoolExecutor.CallerRunsPolicy());// 内置的线程池, 不推荐生产使用Executors.newCachedThreadPool();Executors.newFixedThreadPool(10);Executors.newScheduledThreadPool(10);Executors.newSingleThreadExecutor();

synchronized// 代码块synchronized(obj) &#123;   ...&#125;// (静态)方法public synchronized  (static) void methodName() &#123;   ...&#125;

线程编排

// CountDownLatchCountDownLatch countDownLatch = new CountDownLatch(2);new Thread(() -&gt; &#123;    try &#123;       ...    &#125;finally &#123;       countDownLatch.countDown();    &#125;&#125;).start();countDownLatch.await();

CompletableFuture
CompletableFuture&lt;Void&gt; task1 = CompletableFuture.runAsync(() -&gt; &#123;&#125;);CompletableFuture&lt;Void&gt; task2 = CompletableFuture.runAsync(() -&gt; &#123;&#125;);CompletableFuture&lt;Void&gt; task3 = CompletableFuture.runAsync(() -&gt; &#123;&#125;);CompletableFuture.allOf(task1, task2, task3).get();

Semaphore
Semaphore semaphore = new Semaphore(5);try &#123;    semaphore.acquire();&#125; finally &#123;    semaphore.release();&#125;

ThreadLocalThreadLocal&lt;Integer&gt; threadLocal    = new ThreadLocal&lt;&gt;();

使用完之后一定要记得 remove, 否则会内存泄露
threadLocal.set(1);threadLocal.get();threadLocal.remove();

线程等待与唤醒// 需要synchronized修饰的代码块才能使用wait();notify();notifyAll();// 使用lock的条件唤醒ReentrantLock lock = new ReentrantLock();Condition condition= lock.newCondition();lock.lock();try&#123;   // 当前线程唤醒或等待    condition.await();    condition.signal();    condition.signalAll();&#125; finally &#123;  lock.unlock&#125;// LockSupport,可以先unpark,后续park不会阻塞线程LockSupport.park(obj);LockSupport.unpark(thread);

Java 框架搜集Java 集合




集合
Interface
有序
已排序
线程安全
复制
Nullable



ArrayList
List
Y
N
N
Y
Y


Vector
List
Y
N
Y
Y
Y


LinkedList
List, Deque
Y
N
N
Y
Y


CopyOnWriteArrayList
List
Y
N
Y
Y
Y


HashSet
Set
N
N
N
N
One null


LinkedHashSet
Set
Y
N
N
N
One null


TreeSet
Set
Y
Y
N
N
N


CopyOnWriteArraySet
Set
Y
N
Y
N
One null


ConcurrentSkipListSet
Set
Y
Y
Y
N
N


HashMap
Map
N
N
N
N (key)
One null (key)


HashTable
Map
N
N
Y
N (key)
N (key)


LinkedHashMap
Map
Y
N
N
N (key)
One null (key)


TreeMap
Map
Y
Y
N
N (key)
N (key)


ConcurrentHashMap
Map
N
N
Y
N (key)
N


ConcurrentSkipListMap
Map
Y
Y
Y
N (key)
N


ArrayDeque
Deque
Y
N
N
Y
N


PriorityQueue
Queue
Y
N
N
Y
N


ConcurrentLinkedQueue
Queue
Y
N
Y
Y
N


ConcurrentLinkedDeque
Deque
Y
N
Y
Y
N


ArrayBlockingQueue
Queue
Y
N
Y
Y
N


LinkedBlockingDeque
Deque
Y
N
Y
Y
N


PriorityBlockingQueue
Queue
Y
N
Y
Y
N




ArrayListList&lt;Integer&gt; nums = new ArrayList&lt;&gt;();// 添加nums.add(2);nums.add(5);nums.add(8);// 检索System.out.println(nums.get(0));// 为循环迭代编制索引for (int i = 0; i &lt; nums.size(); i++) &#123;    System.out.println(nums.get(i));&#125;nums.remove(nums.size() - 1);nums.remove(0); // 非常慢for (Integer value : nums) &#123;    System.out.println(value);&#125;// lambda 打印元素nums.forEach(  e -&gt; System.out.println(e.toString()));

HashMapMap&lt;Integer, String&gt; m = new HashMap&lt;&gt;();m.put(5, &quot;Five&quot;);m.put(8, &quot;Eight&quot;);m.put(6, &quot;Six&quot;);m.put(4, &quot;Four&quot;);m.put(2, &quot;Two&quot;);// 检索System.out.println(m.get(6));// Lambda forEachm.forEach((key, value) -&gt; &#123;    String msg = key + &quot;: &quot; + value;    System.out.println(msg);&#125;);

ConcurrentHashMapConcurrentHashMap&lt;Integer, String&gt; m            = new ConcurrentHashMap&lt;&gt;();m.put(100, &quot;Hello&quot;);m.put(101, &quot;Geeks&quot;);m.put(102, &quot;Geeks&quot;);// 移除m.remove(101, &quot;Geeks&quot;);// 如果不存在，就添加，存在就不变更m.putIfAbsent(103, &quot;Hello&quot;);// 替换m.replace(101, &quot;Hello&quot;, &quot;For&quot;);System.out.println(m);

HashSetSet&lt;String&gt; set = new HashSet&lt;&gt;();if (set.isEmpty()) &#123;    System.out.println(&quot;Empty!&quot;);&#125;set.add(&quot;dog&quot;);set.add(&quot;cat&quot;);set.add(&quot;mouse&quot;);set.add(&quot;snake&quot;);set.add(&quot;bear&quot;);if (set.contains(&quot;cat&quot;)) &#123;    System.out.println(&quot;Contains cat&quot;);&#125;set.remove(&quot;cat&quot;);for (String element : set) &#123;    System.out.println(element);&#125;set.forEach(  e -&gt; System.out.println(e.toString()));

ArrayDequeDeque&lt;String&gt; a = new ArrayDeque&lt;&gt;();// 使用 add()a.add(&quot;Dog&quot;);// 使用 addFirst()a.addFirst(&quot;Cat&quot;);// 使用 addLast()a.addLast(&quot;Horse&quot;);// [Cat, Dog, Horse]System.out.println(a);// 访问元素System.out.println(a.peek());// 移除元素System.out.println(a.pop());

Java I&#x2F;O流常见的类和操作

字节流

InputStream 字节输入流的抽象基类
FileInputStream 从文件中读取字节的输入流
ByteArrayInputStream 从字节数组中读取字节的输入流
OutputStream 字节输出流的抽象基类
FileOutputStream 向文件中写入字节的输出流
ByteArrayOutputStream 将字节写入到字节数组的输出流

字符流

Reader 字符输入流的抽象基类
FileReader 从文件中读取字符的输入流
BufferedReader 带缓冲区的字符输入流
InputStreamReader 字节流到字符流的桥接器
Writer 字符输出流的抽象基类
FileWriter 向文件中写入字符的输出流
BufferedWriter 带缓冲区的字符输出流
OutputStreamWriter 字符流到字节流的桥接器

对象流

ObjectInputStream 从输入流中读取Java对象的流
ObjectOutputStream 将Java对象写入输出流的流

缓冲流

BufferedInputStream 带缓冲区的字节输入流
BufferedOutputStream 带缓冲区的字节输出流
BufferedReader 带缓冲区的字符输入流
BufferedWriter 带缓冲区的字符输出流

数据流

DataInputStream 从输入流中读取基本数据类型的数据
DataOutputStream 将基本数据类型数据写入输出流

文件类

File 文件和目录路径名的抽象表示
FileReader 从文件中读取字符的输入流
FileWriter 向文件中写入字符的输出流

输入输出异常处理

IOException Java I&#x2F;O操作中的通用异常
FileNotFoundException 当试图打开指定文件失败时抛出
EOFException 在尝试读取流的末尾时抛出

其他流

PrintStream 打印格式化表示的对象的输出流
PrintWriter 格式化的文本输出流
RandomAccessFile 随机访问文件的类，支持读取和写入操作

字节流// 文件输入流InputStream inputStream  = new FileInputStream(&quot;input.txt&quot;);// 文件输出流OutputStream outputStream  = new FileOutputStream(&quot;output.txt&quot;);// 缓冲字节输入流InputStream bufferedInputStream  = new BufferedInputStream(inputStream);// 缓冲字节输出流OutputStream bufferedOutputStream  = new BufferedOutputStream(outputStream);

字符流// 文件字符输入流Reader fileReader  = new FileReader(&quot;input.txt&quot;);// 文件字符输出流Writer fileWriter  = new FileWriter(&quot;output.txt&quot;);// 缓冲字符输入流Reader bufferedFileReader  = new BufferedReader(    new FileReader(&quot;input.txt&quot;)  );// 缓冲字符输出流Writer bufferedFileWriter  = new BufferedWriter(    new FileWriter(&quot;output.txt&quot;)  );

数据流// 数据输入流DataInputStream dataInputStream  = new DataInputStream(inputStream);// 数据输出流DataOutputStream dataOutputStream  = new DataOutputStream(outputStream);

对象流// 对象输入流ObjectInputStream objectInputStream  = new ObjectInputStream(inputStream);// 对象输出流ObjectOutputStream objectOutputStream  = new ObjectOutputStream(outputStream);

序列化与反序列化

序列化对象到文件
try (  ObjectOutputStream objectOutputStream    = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;))) &#123;    objectOutputStream.writeObject(object);&#125;

从文件反序列化对象
try (  ObjectInputStream objectInputStream    = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;))) &#123;    Object object = objectInputStream.readObject();&#125;

标准输入输出流标准输入流
InputStream standardInputStream      = System.in;

标准输出流
PrintStream standardOutputStream      = System.out;

基本操作

// 读取字节数据int byteData = inputStream.read();// 写入字节数据outputStream.write(byteData);// 读取字符数据int charData = reader.read();// 写入字符数据writer.write(charData);

关闭流// 关闭输入流inputStream.close();// 关闭输出流outputStream.close();

Java Stream 流

创建流从集合创建流
List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);Stream&lt;String&gt; streamFromList = list.stream();

从数组创建流
String[] array = &#123;&quot;d&quot;, &quot;e&quot;, &quot;f&quot;&#125;;Stream&lt;String&gt; streamFromArray = Arrays.stream(array);

创建空流
Stream&lt;String&gt; emptyStream = Stream.empty();

创建无限流
Stream&lt;Integer&gt; infiniteStream = Stream.iterate(0, n -&gt; n + 2);

中间操作// 过滤Stream&lt;String&gt; filteredStream = list.stream().filter(  s -&gt; s.startsWith(&quot;a&quot;));// 映射Stream&lt;Integer&gt; mappedStream = list.stream().map(String::length);// 排序Stream&lt;String&gt; sortedStream = list.stream().sorted();// 去重Stream&lt;String&gt; distinctStream = list.stream().distinct();// 截断Stream&lt;String&gt; limitedStream = list.stream().limit(2);// 跳过Stream&lt;String&gt; skippedStream = list.stream().skip(1);

终端操作// 聚合操作Optional&lt;String&gt; anyElement = list.stream().findAny();Optional&lt;String&gt; firstElement = list.stream().findFirst();long count = list.stream().count();Optional&lt;String&gt; maxElement = list.stream()    .max(Comparator.naturalOrder());Optional&lt;String&gt; minElement = list.stream()    .min(Comparator.naturalOrder());// 检查匹配boolean anyMatch = list.stream().anyMatch(s -&gt; s.contains(&quot;a&quot;));boolean allMatch = list.stream().allMatch(s -&gt; s.length() == 1);boolean noneMatch = list.stream().noneMatch(s -&gt; s.contains(&quot;z&quot;));// 归约Optional&lt;String&gt; reducedString = list.stream()  .reduce((s1, s2) -&gt; s1 + s2);String reducedStringWithIdentity = list.stream()  .reduce(&quot;Start:&quot;, (s1, s2) -&gt; s1 + s2);// 收集List&lt;String&gt; collectedList = list.stream()    .collect(Collectors.toList());Set&lt;String&gt; collectedSet = list.stream()    .collect(Collectors.toSet());Map&lt;Integer, String&gt; collectedMap = list.stream()    .collect(        Collectors.toMap(String::length, Function.identity())    );

并行流List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;);List&lt;String&gt; upperCaseList = list.parallelStream()    .map(String::toUpperCase)    .collect(Collectors.toList());

反射这些是使用 Java 反射时常见的操作。使用反射需要注意性能和安全性问题，尽量避免在性能要求高的地方过度使用。
获取 Class 对象

// 通过类名获取Class对象Class&lt;?&gt; clazz1 = MyClass.class;// 通过对象获取Class对象MyClass obj = new MyClass();Class&lt;?&gt; clazz2 = obj.getClass();// 通过完整类名字符串获取Class对象Class&lt;?&gt; clazz3 = Class.forName(&quot;com.example.MyClass&quot;);

获取类的信息

获取类的名称
String className = clazz.getName();

获取类的修饰符
int modifiers = clazz.getModifiers();

获取类的包信息
Package pkg = clazz.getPackage();

获取类的父类
Class&lt;?&gt; superClass = clazz.getSuperclass();

获取类实现的接口
Class&lt;?&gt;[] interfaces = clazz.getInterfaces();

创建对象实例

// 使用默认构造函数创建对象MyClass instance = (MyClass) clazz.newInstance();// 使用带参数的构造函数创建对象Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, int.class);MyClass instanceWithArgs = (MyClass) constructor.newInstance(&quot;example&quot;, 123);

获取和设置字段值

// 获取字段值Field field = clazz.getDeclaredField(&quot;fieldName&quot;);field.setAccessible(true); // 如果字段是私有的，需要设置可访问Object value = field.get(instance);// 设置字段值field.set(instance, newValue);

处理泛型// 获取泛型信息Type genericType = field.getGenericType();

调用方法

// 获取方法Method method = clazz.getDeclaredMethod(&quot;methodName&quot;, parameterTypes);method.setAccessible(true); // 如果方法是私有的，需要设置可访问// 调用方法Object result = method.invoke(instance, args);

其他常用操作

// 判断是否是数组、枚举、注解等boolean isArray = clazz.isArray();boolean isEnum = clazz.isEnum();boolean isAnnotation = clazz.isAnnotation();// 获取构造函数、字段、方法等Constructor&lt;?&gt;[] constructors = clazz.getConstructors();Field[] fields = clazz.getDeclaredFields();Method[] methods = clazz.getDeclaredMethods();

处理注解

// 获取注解信息Annotation annotation = field.getAnnotation(MyAnnotation.class);

方法引用方法引用

Java 的 Consumer 接口里的 accept 方法接受参数但不返回值。要让它打印传入的参数，可以这样做：
Consumer&lt;String&gt; test = new Consumer&lt;String&gt;() &#123;    @Override    public void accept(String s) &#123;      System.out.println(s);    &#125;  &#125;;test.accept(&quot;test&quot;);

更简单的，我们可以直接传入Lambda表达式
Consumer&lt;String&gt; test = System.out::println;

方法引用通过方法的名字指向一个方法，使语言构造更简洁，减少冗余代码。
使用方式
引用方法
引用构造方法
引用数组

静态方法引用Comparator&lt;Integer&gt; comparator = Math::max;int result = comparator.compare(1, 2);// 返回 2

实例方法引用String str = &quot;HELLO&quot;;String lowerCase = str::toLowerCase;// 返回 &quot;hello&quot;

构造方法引用Supplier&lt;String&gt; supplier = String::new;String str = supplier.get();// 返回一个空字符串

数组构造方法引用Function&lt;Integer, String[]&gt; function = String[]::new;String[] array = function.apply(5);// 返回 5 个空字符串的数组


对象中的方法引用String someStr = &quot;HELLO&quot;;String lowerCase = someStr::toLowerCase;// 返回 &quot;hello&quot;

对象中的静态方法引用SomeClass someObject = new SomeClass();int result = someObject::staticMethod;// 调用静态方法

杂项 Misc访问修饰符




修饰符
Class
Package
Subclass
World



public
Y
Y
Y
Y


protected
Y
Y
Y
N


no modifier
Y
Y
N
N


private
Y
N
N
N




常用表达String text = &quot;I am learning Java&quot;;// 删除所有空格text.replaceAll(&quot;\\s+&quot;, &quot;&quot;);// 拆分字符串text.split(&quot;\\|&quot;);text.split(Pattern.quote(&quot;|&quot;));

查看: Regex in java
注释 Comment// 我是单行注释！/*而我是一个多行注释！*//**  * 这个  * 是  * 文档  * 注释 */

关键字


abstract
continue
for
new
switch
assert
default
goto
package
synchronized
boolean
do
if
private
this
break
double
implements
protected
throw
byte
else
import
public
throws
case
enum
instanceof
return
transient
catch
extends
int
short
try
char
final
interface
static
void
class
finally
long
strictfp
volatile
const
float
native
super
while



数学方法




方法
说明



Math.max(a,b)
a 和 b 的最大值


Math.min(a,b)
a 和 b 的最小值


Math.abs(a)
绝对值


Math.sqrt(a)
a 的平方根


Math.pow(a,b)
b 的幂


Math.round(a)
最接近的整数


Math.sin(ang)
正弦


Math.cos(ang)
ang 的余弦


Math.tan(ang)
ang 的切线


Math.asin(ang)
ang 的反正弦


Math.log(a)
a 的自然对数


Math.toDegrees(rad)
以度为单位的角度弧度


Math.toRadians(deg)
以弧度为单位的角度度


异常 Try&#x2F;Catch&#x2F;Finallytry &#123;  // something&#125; catch (Exception e) &#123;  e.printStackTrace();&#125; finally &#123;  System.out.println(&quot;always printed&quot;);&#125;

util工具类


ArrayDeque: 可调整大小的数组双端队列，实现了Deque接口
Arrays: 提供静态工厂，允许将数组视为列表
Collections: 包含操作集合或返回集合的静态方法
Date: 表示特定时间瞬间，精度为毫秒
Dictionary: 抽象父类，可用于键值对映射，例如Hashtable
EnumMap: 专门用于枚举键的Map实现
EnumSet: 专门用于枚举键的Set实现
Formatter: 提供对布局、对齐、数字、字符串和日期&#x2F;时间数据的格式化支持，以及特定于语言环境的输出
SecureRandom: 生成安全的伪随机数流的实例
UUID: 表示不可变的通用唯一标识符
Vector: 实现了可增长的对象数组
LocalDate: 表示无时区的日期，仅包含年月日，不可变且线程安全，适用于Java 8及更高版本
LocalTime: 表示无时区的时间，仅包含时分秒，不可变且线程安全，适用于Java 8及更高版本
LocalDateTime: 表示无时区的日期时间，包含年月日时分秒，不可变且线程安全，适用于Java 8及更高版本

Collections 工具类// 计算出现频率List&lt;Integer&gt; list = new ArrayList&lt;&gt;();list.add(1);list.add(2);list.add(2);list.add(3);list.add(3);list.add(3);int frequency = Collections      .frequency(list, 2); // frequency = 2

操纵数据库JDBCString url = &quot;jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&quot;;String user = &quot;root&quot;;String password = &quot;123456&quot;;String sql = &quot;SELECT 1 as a, &#x27;2&#x27; as b&quot;;String preparedSql = &quot;SELECT * FROM t_user WHERE id = ?&quot;;Connection conn = null;Statement sm = null;ResultSet rs = null;try &#123;  // 1.注册驱动  Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);&#125; catch (ClassNotFoundException e) &#123;  // 驱动找不到  throw new RuntimeException(e);&#125;// 2.建立连接try (Connection connection = DriverManager.getConnection(url, user, password)) &#123;  conn = connection;  // 3.创建Statement对象  try (Statement statement = connection.createStatement()) &#123;    sm = statement;    // 4.执行SQL语句    try (ResultSet resultSet = statement.executeQuery(sql)) &#123;      rs = resultSet;      // 5.处理结果集      while (resultSet.next()) &#123;        // 按照列名取值        System.out.println(resultSet.getLong(&quot;a&quot;));        // 按照索引取值        System.out.println(resultSet.getString(2));      &#125;    &#125;  &#125;  // 3.创建PreparedStatement对象  try (PreparedStatement preparedStatement = connection.prepareStatement(preparedSql)) &#123;    sm = preparedStatement;    preparedStatement.setLong(1, 1_000L);    // 4.执行SQL语句    try (ResultSet resultSet = preparedStatement.executeQuery()) &#123;      rs = resultSet;      // 5.处理结果集      while (resultSet.next()) &#123;        System.out.println(resultSet.getLong(&quot;id&quot;));        System.out.println(resultSet.getString(2));      &#125;    &#125;  &#125;&#125; catch (SQLException e) &#123;  // 数据库异常  throw new RuntimeException(e);&#125; finally &#123;  // 6.关闭资源  // 上面的try块里已经自动关闭，否则（JDK 7以前）按照以下顺序关闭  // 先打开的后关闭，后打开的先关闭  if (null != rs) &#123;    try &#123;      rs.close();    &#125; catch (SQLException ignored) &#123;    &#125;  &#125;  if (null != sm) &#123;    try &#123;      sm.close();    &#125; catch (SQLException ignored) &#123;    &#125;  &#125;  if (null != conn) &#123;    try &#123;      conn.close();    &#125; catch (SQLException ignored) &#123;    &#125;  &#125;  // 也可以直接工具类， 注意顺序  IOUtils.close(rs);  IOUtils.close(sm);  IOUtils.close(conn);&#125;

JDBC注册驱动Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);DriverManager.registerDriver(new org.postgresql.Driver());// 支持多个同时注册System.setProperty(&quot;jdbc.drivers&quot;, &quot;com.mysql.cj.jdbc.Driver:org.postgresql.Driver&quot;);

另见
Java 官网 (oracle.com&#x2F;cn&#x2F;java)

]]></content>
      <categories>
        <category>后端编程</category>
      </categories>
      <tags>
        <tag>后端编程</tag>
        <tag>java</tag>
      </tags>
  </entry>
</search>
